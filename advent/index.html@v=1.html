<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Adventi naptár</title>
<meta property="og:title" content="InfoC :: Adventi naptár">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="InfoC :: Adventi naptár">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="InfoC :: Adventi naptár">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="../modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v10.css">
<script src="../modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="../index.html">InfoC</a></div>
<ul>
<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="../index.html">Kezdőlap</a>
<li><a href="../nhf.html">Nagy házi feladat</a>
<li><a href="../elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="../ea01.html">1. hét: bevezetés</a>
<li><a href="../ea02.html">2. hét: algoritmusok</a>
<li><a href="../ea03.html">3. hét: tételek, tömbök</a>
<li><a href="../ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="../ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="../ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../ea09.html">9. hét: láncolt listák</a>
<li><a href="../ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="../ea12.html">12. hét: bináris fák</a>
<li><a href="../ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="../ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="../gy02.html">2. hét: algoritmizálás</a>
<li><a href="../gy03.html">3. hét: egyszerű programok</a>
<li><a href="../gy04.html">4. hét: tételek és tömbök</a>
<li><a href="../gy05.html">5. hét: függvények</a>
<li><a href="../gy06.html">6. hét: származtatott típusok</a>
<li><a href="../gy07.html">7. hét: mutatók használata</a>
<li><a href="../gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="../gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="../gy11.html">11. hét: láncolt listák I.</a>
<li><a href="../gy12.html">12. hét: láncolt listák II.</a>
<li><a href="../gy13.html">13. hét: bináris fák</a>
<li><a href="../gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="../lab01.html">1. hét: operációs rendszer</a>
<li><a href="../lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="../lab03.html">3. hét: egyszerű programok</a>
<li><a href="../lab04.html">4. hét: tömbök</a>
<li><a href="../lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="../lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="../lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="../lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="../lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="../lab11.html">11. hét: láncolt listák</a>
<li><a href="../lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="../lab13.html">13. hét: bináris fák</a>
<li><a href="../lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="../f01.html">1. hét: egyszerű programok</a>
<li><a href="../f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="../f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="../f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="../f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="../f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../f09.html">9. hét: láncolt listák</a>
<li><a href="../f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="../f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="../f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="../jegyzet.html">Jegyzet és puska</a>
<li><a href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="../stilus.html">Kódolási stílus</a>
<li><a href="../tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="../debugmalloc.html">Debugmalloc</a>
<li><a href="../mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="../nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="../nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="../nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="../orak.html">SVG óra galéria</a>
<li><a href="../angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="../turing.html">Mit tud a számítógép?</a>
<li><a href="../bf.html">BF</a>
<li><a href="../bitturmix.html">Bitturmix</a>
<li><a href="../labirintus.html">Labirintusok</a>
<li><a href="../tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../karakterkodolas.html">Karakterkódolások</a>
<li><a href="../strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="../internet.html">Internet</a>
</ul>

<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="../sdl.html">SDL grafika</a>
<li><a href="../sdl_telepito.html">SDL telepítés</a>
<li><a href="../fa.html">Fák rajzolása</a>
<li><a href="../lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="index.html@v=1.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="../mondatelemzo.html">Mondatelemző</a>
<li><a href="../kifejezesek.html">Kifejezések</a>
<li><a href="../derivalas.html">Deriválás</a>
<li><a href="../ast_epit.html">AST: szintaxisfák</a>
<li><a href="../ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="../ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="../advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<div class="float" style="margin-top: 0.25em; margin-bottom: 0;"><a href="../advent.html">&larr; vissza</a></div>
<h1 class="eloadascim">Adventi naptár</h1>
<h2>Színek a számítógépen</h2>

<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="index.html@v=1.html#1">R, G és B</a>
<li><a href="index.html@v=1.html#2">A formátumok kezelése</a>
<li><a href="index.html@v=1.html#3">Kép a semmiből</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>R, G és B</h2>
</div>

<img class="float arnyek" src="advent1-rgb.jpg">
<p>
A monitorok, legyenek azok buborék (képcsöves) vagy lapos (lcd) fajtájúak, a vörös,
zöld és kék szín összekeveréséből állítják elő a színeket. Minden képpont helyén
igazából három van, amelyek eltérő színű fénnyel világítanak. Ez nagyítóval
nézve látszik is, érdemes megnézni. 

<p>
Mivel a monitornak ilyen komponensekből kell összeállítaniuk a színeket, ezért azok
a videókártya memóriájába is ilyen formátumban kerülnek. A három színösszetevőt az RGB betűkkel szokás
jelölni: red, green, blue. Az egyes színösszetevők erősségét a hardver általában egy 0..255 skálán,
vagyis 8 biten tárolja. 0 a minimális fényerő (fekete), 255 a maximális.
Így három bájton 256×256×256=2<sup>8</sup>×2<sup>8</sup>×2<sup>8</sup>=2<sup>24</sup>-féle
szín keverhető ki, összesen 16&nbsp;777&nbsp;216 darab. Ez nagyjából annyi, mint amennyit az emberi szem
meg tud különböztetni.

<p>
Ha spórolni kell a memóriával vagy a számításokkal, akkor kevesebb biten, pontatlanabbul is tárolhatóak
az egyes értékek. Az elterjedt variációk:

<ul>
    <li>24 bit: a fent említett.
    <li>32 bit: igazából ez ugyanaz, mint a 3×8=24 bites, csak minden bájthármas után egy negyedik üres
        bájtot helyeznek el; azért, hogy egy képpont memóriacíme néggyel való szorzással legyen
        számítható. Ez egyszerűbb, mint a 3-mal való szorzás, mivel bitléptetéssel is megoldható.
        A négy bájt egyszerre írható és olvasható, egy 32 bites egész típussal (SDL-ben az <code>Uint32</code>
        direkt erre a célra van).
    <li>15 bit: minden komponensre 5 bit jut, vagyis 2<sup>5</sup>=32-es skálán adhatóak meg.
    <li>16 bit: egy bájt általában 8 bites, ezért a 15 bites tárolásnál egy bit szabadon
        maradt. Ezzel a bittel a zöld komponens pontosságát érdemes megnövelni, mert az emberi szem
        arra a legérzékenyebb. Vagyis: R=5 bit, G=6 bit, B=5 bit.
    <li>8 bit: ezt komponensekre felosztva már túl kevés bit jutna az egyes színekre. A 8 bites tárolásnál
        egy palettát használnak: 256 szín tömbje, amelyben a képponthoz tartozó 8 bites szám az index.
</ul>

</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>A formátumok kezelése</h2>
</div>

<p>
Az SDL az összes fent említett formátumot támogatja. Ha két különböző formátumban lévő képünk van, akkor
is másolható egyik a másikra; a szükséges átalakítást az <code>SDL_BlitSurface()</code> függvény elvégzi,
még ha lassú is lesz tőle a program. Néha azonban szükségünk van arra, hogy mi magunk manipuláljuk
az egyes képpontokat.

<p>
Minden <code>SDL_Surface</code> tartalmaz egy <code>pixels</code> nevű pointert, ez mutat a memóriában
a képpontokat tároló adatterületre. Tartalmaz továbbá egy <code>SDL_PixelFormat</code> struktúrát is,
amelyik a kép tárolási módjáról tartalmaz információkat. Ennek a lényeges adattagjai a következők:

<pre class="brush: c "  >
typedef struct {
    ...
    Uint8  BitsPerPixel;
    Uint8  BytesPerPixel;
    Uint8  Rloss, Gloss, Bloss, Aloss;
    Uint8  Rshift, Gshift, Bshift, Ashift;
    Uint32 Rmask, Gmask, Bmask, Amask;
    ...
} SDL_PixelFormat;</pre>

<p> A <code>BitsPerPixel</code> mező a fent említett formátumokra utal, értéke 
lehet pl. 8, 16 vagy 24. A <code>BytesPerPixel</code> arra használható, hogy egy 
képpont memóriacímét egy soron belül könnyen ki tudjuk számolni, mert azt mondja 
meg, hány bájt (<code>sizeof(char)</code>) egy képpont. A képponthoz tartozó 
bájtok manipulációja a többi mezőkben tárolt számok segítségével végezhető el.

<p> Egy példán a legegyszerűbb látni az egészet. Tegyük fel, hogy az R=0xEB, G=0
x68, B=0x3E színt (amelyik
<span style="background: #EB683E; color: white;">&nbsp;ez&nbsp;a&nbsp;szín&nbsp;</span>)
szeretnénk tárolni 16 biten. Az R komponensre 5,
a G-re 6, a B-re 5 bitet szánunk. Ha ezeket ilyen sorrendben is tároljuk el a 16 
biten, vagyis két bájton belül, akkor a következő formátum adódik.

<img src="advent1-pixelformat.svg" class="kozep">

<p>A vörös (R) komponens 8 bit helyett csak 5 biten tárolódik. Ezért az alsó 3 bitet el kell 
dobni. Az <code>SDL_PixelFormat</code> struktúrában az <code>Rloss</code> mező az R komponensből 
eldobott bitek számát tárolja. A kapott értéket <code>Rshift</code> bitnyivel feljebb toljuk; 
mert nem a 16 bit legalsó, hanem a legfelső helyiértékű bitjein tárolódik az R komponens. 
Ugyanígy működik ez a többi komponensnél is; a zöldet 6 biten tároljuk, ezért <code>Gloss</code> 
csak 2. A kék komponens pedig a végleges számban a legalsó helyiértékű bitekre kerül, ezért
<code>Bshift</code> 0 lesz &mdash; legalábbis ebben a példában, mert elképzelhető lenne az is, hogy 
nem R, G, B sorrendben tároljuk a komponenseket, hanem B, G, R sorrendben. Az SDL úgy hozza létre
a képeket, hogy mindig beállítja ezeket a mezőket a megfelelő értékre, megkönnyítve ezzel a 
dolgunkat. A fentiek alapján, ha egy adott r,g,b színhez keressük azt a (több bájtos) számot, 
amelyet a memóriába kell írnunk:

<pre class="brush: c "  >
adat = (r &gt;&gt; Rloss &lt;&lt; Rshift) | (g &gt;&gt; Gloss &lt;&lt; Gshift) | (b &gt;&gt; Bloss &lt;&lt; Bshift);</pre>

<p>Az <code>Rmask</code>, <code>Gmask</code> és <code>Bmask</code> mezők bitmaszkokat 
tartalmaznak. Az <code>Rmask</code> például egy olyan számot, amelyben ott vannak egyesek, ahol a
képpont adatában az R komponenshez tartozó rész található. Ezt bináris ÉS kapcsolatba hozva a 
képpont adattal ki tudjuk vágni belőle az R komponenshez tartozó részt. Ezt a helyére tolva 
visszakapjuk az eredeti r értéket. Vagyis a fenti számítás visszafelé így végezhető el:

<pre class="brush: c "  >
r = (adat &amp; Rmask) &gt;&gt; Rshift &lt;&lt; Rloss;
g = (adat &amp; Gmask) &gt;&gt; Gshift &lt;&lt; Gloss;
b = (adat &amp; Bmask) &gt;&gt; Bshift &lt;&lt; Bloss;</pre>

<p>Az <code>Aloss</code>, <code>Ashift</code> és <code>Amask</code> 
mezők a kép átlátszóságára vonatkozó információk kezelését teszik 
lehetővé, ugyanilyen módon.

<p>Lényegében egyébként ez a rajzolás egyik részfeladata, amitől igazából az SDL_gfx 
megszabadít minket.




</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>Kép a semmiből</h2>
</div>
<p>
Hozzunk létre egy képet!

<img class="float" src="advent1-plazma.svg" style="width: 16em">

<p>A plazma nevű rekurzív algoritmus a következő módon működik. Egy kép négy sarkában helyezzünk
el színeket. Ez a négy pont, a kép négy sarka, egy téglalapot határoz meg. A téglalap oldalait 
felezzük meg; az oldalfelező pontokban állítsunk be olyan színeket, amelyek a sarkok színei 
közötti átmenetek. Például a fenti középső pont legyen a két fenti sarokpont színe között félúton
lévő szín. A téglalap közepén lévő pontot is színezzük ki, mégpedig úgy, hogy annak a színe a 
négy sarok színe közötti átmenet legyen; plusz/mínusz egy véletlenszám. A véletlenszám nagysága 
legyen arányos a téglalap nagyságával, vagyis minél nagyobb a téglalap, annál nagyobb legyen a 
véletlen eltérés is. Ezekkel a pontokkal a téglalapot négy kisebb részre osztottuk; csináljuk meg
a négy kisebb részre ugyanezt (rekurzívan).

<p>A lenti programban ezt a procedúra háromszor fut le. Három kép van; az egyik 
lesz a végülis kirajzolt kép R, a másik a G, a harmadik pedig a B komponense. 
Létrehozunk egy SDL képet a memóriában az <code>SDL_CreateRGBSurface()</code> 
függvénnyel, 32 bites színtérrel. A sok nulla a függvény paraméterlistájának a 
végén az <code>Rmask</code>, <code>Gmask</code> stb. értékek. Nulla esetén az 
alapértéket állítja be ezekhez az SDL. Mivel 32 bites képet kértünk,
egy <code>Uint32</code>-t tudok írni egyszerre a memóriába: az egy képpont. A tömbbe írandó 
értékek a fent részletezett módon számolódnak ki.

<p>A képpont megcímzése trükkös. A képhez tartozó <code>pixels</code> mező egy <code>void *</code>
típusú mutató, amely a képpontok tömbjének első elemére mutat. A <code>pitch</code> mező 
pedig egy egész szám, amely azt mutatja, hogy hány bájtonként kezdődik egy sor. Ezzel meg lehet
határozni a kép egy sorának címét a memóriában; az eredményt egy <code>Uint32 *</code> típusú 
mutatóba kell tenni, amelynek segítségével a kép adott során belül egy adott pixel egyszerű 
indexeléssel előállítható. Ha 16 bites képem lenne, akkor <code>Uint16</code>-ot, ha 8 bites, 
akkor pedig <code>Uint8</code>-at kellene használni. Ezek egyébként az SDL által definiált 
típusok; <code>Uint32</code> egy 32 bites, előjel nélküli egész szám.

<p>Az első kép a program kimenetét mutatja. A második pedig azt, hogy hogyan nézne
ki a kép, ha generálás közben megállítanánk. Ezen látszik a rekurzió. A színek az
utóbbin úgy vannak beállítva, hogy kék és fehér közötti átmenetek jelenjenek meg;
a program így felhőket rajzol. Ismerős lehet: az InfoC facebook oldalnak ez 
rajzolta a hátterét.

<div class="kozep">
<img class="arnyek" src="advent1-screenshot.png" style="margin-right: 1em;">
<img class="arnyek" src="advent1-felhok.png" style="margin-left: 1em;">
</div>

<pre class="brush: c "  >
#include &lt;SDL.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
 
enum { MERETX = 640, MERETY = 480 }; 
typedef unsigned char Kep[MERETY][MERETX];
 
void plasma(Kep kep, int x1, int y1, int x2, int y2) {
    if (x2-1&gt;x1) {
        kep[y1][(x1+x2)/2] = (kep[y1][x1]+kep[y1][x2])/2;
        kep[y2][(x1+x2)/2] = (kep[y2][x1]+kep[y2][x2])/2;
    }
    if (y2-1&gt;y1) {
        kep[(y1+y2)/2][x1] = (kep[y1][x1]+kep[y2][x1])/2;
        kep[(y1+y2)/2][x2] = (kep[y1][x2]+kep[y2][x2])/2;
    }
    if (x2-1&gt;x1) {
        int c = (kep[y1][x1]+kep[y1][x2]+kep[y2][x1]+kep[y2][x2])/4
                + rand()%((x2-x1)*2)-(x2-x1);
        c = c&gt;255?255:(c&lt;0?0:c);
        kep[(y1+y2)/2][(x1+x2)/2] = c;
        plasma(kep, x1, y1, (x1+x2)/2, (y1+y2)/2);
        plasma(kep, (x1+x2)/2, y1, x2, (y1+y2)/2);
        plasma(kep, x1, (y1+y2)/2, (x1+x2)/2, y2);
        plasma(kep, (x1+x2)/2, (y1+y2)/2, x2, y2);
    }
}
 
int main(int argc, char *argv[]) {
    Kep komponensek[3];
    int x, y;
    SDL_Surface *screen, *bmp;
    SDL_Event ev;
 
    SDL_Init(SDL_INIT_VIDEO);
    screen = SDL_SetVideoMode(MERETX, MERETY, 0, SDL_ANYFORMAT);
    if (!screen) {
        fprintf(stderr, &quot;Nem sikerult megnyitni az ablakot!\n&quot;);
        exit(1);
    }
 
    srand(time(NULL));
    for (x = 0; x &lt; 3; x++) {
        komponensek[x][0][0] = rand()%256;
        komponensek[x][0][MERETX-1] = rand()%256;
        komponensek[x][MERETY-1][0] = rand()%256;
        komponensek[x][MERETY-1][MERETX-1] = rand()%256;
        plasma(komponensek[x], 0, 0, MERETX-1, MERETY-1);
    }
 
    /* kerek egy 32 bit/komponens kepet */
    bmp = SDL_CreateRGBSurface(0, MERETX, MERETY, 32, 0, 0, 0, 0);
 
    /* osszeallitom a kepet az SDL surface-ben */
    for (y = 0; y &lt; MERETY; y++) {
        Uint32 *sor = (Uint32*) ((char*) bmp-&gt;pixels + y*bmp-&gt;pitch);
        for (x = 0; x &lt; MERETX; x++) {
            Uint32 szam;        /* 32 bites a kep, ez lesz egy pixel */
 
            szam = (komponensek[0][y][x] &gt;&gt; bmp-&gt;format-&gt;Rloss &lt;&lt; bmp-&gt;format-&gt;Rshift)
                 | (komponensek[1][y][x] &gt;&gt; bmp-&gt;format-&gt;Gloss &lt;&lt; bmp-&gt;format-&gt;Gshift)
                 | (komponensek[2][y][x] &gt;&gt; bmp-&gt;format-&gt;Bloss &lt;&lt; bmp-&gt;format-&gt;Bshift);
            sor[x] = szam;
        }
    }
    SDL_BlitSurface(bmp, NULL, screen, NULL);
    SDL_FreeSurface(bmp);       /* mar nem kell */
 
    SDL_Flip(screen);
    while (SDL_WaitEvent(&amp;ev) &amp;&amp; (ev.type != SDL_QUIT &amp;&amp; ev.type != SDL_KEYDOWN)) {
        /* csak var */
    }
 
    SDL_Quit();
 
    return 0;
}</pre>
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="index.html@v=1.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="../index.html"><img src="../modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="../index.html">főoldal</a> · <a href="../elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
