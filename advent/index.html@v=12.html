<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Adventi naptár</title>
<meta property="og:title" content="InfoC :: Adventi naptár">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="InfoC :: Adventi naptár">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="InfoC :: Adventi naptár">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="../modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v10.css">
<script src="../modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="../index.html">InfoC</a></div>
<ul>
<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="../index.html">Kezdőlap</a>
<li><a href="../nhf.html">Nagy házi feladat</a>
<li><a href="../elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="../ea01.html">1. hét: bevezetés</a>
<li><a href="../ea02.html">2. hét: algoritmusok</a>
<li><a href="../ea03.html">3. hét: tételek, tömbök</a>
<li><a href="../ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="../ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="../ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../ea09.html">9. hét: láncolt listák</a>
<li><a href="../ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="../ea12.html">12. hét: bináris fák</a>
<li><a href="../ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="../ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="../gy02.html">2. hét: algoritmizálás</a>
<li><a href="../gy03.html">3. hét: egyszerű programok</a>
<li><a href="../gy04.html">4. hét: tételek és tömbök</a>
<li><a href="../gy05.html">5. hét: függvények</a>
<li><a href="../gy06.html">6. hét: származtatott típusok</a>
<li><a href="../gy07.html">7. hét: mutatók használata</a>
<li><a href="../gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="../gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="../gy11.html">11. hét: láncolt listák I.</a>
<li><a href="../gy12.html">12. hét: láncolt listák II.</a>
<li><a href="../gy13.html">13. hét: bináris fák</a>
<li><a href="../gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="../lab01.html">1. hét: operációs rendszer</a>
<li><a href="../lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="../lab03.html">3. hét: egyszerű programok</a>
<li><a href="../lab04.html">4. hét: tömbök</a>
<li><a href="../lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="../lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="../lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="../lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="../lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="../lab11.html">11. hét: láncolt listák</a>
<li><a href="../lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="../lab13.html">13. hét: bináris fák</a>
<li><a href="../lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="../f01.html">1. hét: egyszerű programok</a>
<li><a href="../f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="../f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="../f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="../f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="../f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../f09.html">9. hét: láncolt listák</a>
<li><a href="../f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="../f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="../f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="../jegyzet.html">Jegyzet és puska</a>
<li><a href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="../stilus.html">Kódolási stílus</a>
<li><a href="../tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="../debugmalloc.html">Debugmalloc</a>
<li><a href="../mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="../nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="../nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="../nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="../orak.html">SVG óra galéria</a>
<li><a href="../angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="../turing.html">Mit tud a számítógép?</a>
<li><a href="../bf.html">BF</a>
<li><a href="../bitturmix.html">Bitturmix</a>
<li><a href="../labirintus.html">Labirintusok</a>
<li><a href="../tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../karakterkodolas.html">Karakterkódolások</a>
<li><a href="../strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="../internet.html">Internet</a>
</ul>

<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="../sdl.html">SDL grafika</a>
<li><a href="../sdl_telepito.html">SDL telepítés</a>
<li><a href="../fa.html">Fák rajzolása</a>
<li><a href="../lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="index.html@v=12.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="../mondatelemzo.html">Mondatelemző</a>
<li><a href="../kifejezesek.html">Kifejezések</a>
<li><a href="../derivalas.html">Deriválás</a>
<li><a href="../ast_epit.html">AST: szintaxisfák</a>
<li><a href="../ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="../ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="../advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<div class="float" style="margin-top: 0.25em; margin-bottom: 0;"><a href="../advent.html">&larr; vissza</a></div>
<h1 class="eloadascim">Adventi naptár</h1>
<h2>Változó argumentumszámú függvények</h2>

<p>A fordító számára mindig meg kell adnunk függvényeink prototípusát, mivel ismernie kell a 
paraméterek pontos számát és típusát. Felmerül a kérdés azonban: ha ezeket mindig meg kell adni, 
hogyan csinálja a <code>printf()</code>, hogy akárhány paramétere lehet?

<p>Továbbmenve, különleges függvény-e a <code>printf()</code>, vagy olyan, mint a többi? 
Speciálisan kezeli a fordító, vagy ugyanúgy, mint a többit? Ez azért fontos kérdés, mert ha csak 
a <code>printf()</code> ilyen, akkor mi nem írhatunk így viselkedő függvényt. Azonban ha a <code>
printf()</code> semmilyen szempontból nem különleges, akkor a saját függvényeink is lehetnek 
ilyenek.

<p>Ha megnézzük a <code>printf()</code> dokumentációját, a következő prototípust látjuk:

<pre class="brush: c "  >
int printf(const char *format, ...);</pre>

<p>A függvény első paramétere egy sztring, utána pedig a prototípusban egy pontpontpont
<code>...</code> (ellipsis) szerepel. Ez azt jelenti, hogy ott akármennyi paraméter állhat. Ez egy C 
nyelvi elem, és bármely saját függvénynél is használható.

<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="index.html@v=12.html#1">A változó argumentumszámú függvények hívása</a>
<li><a href="index.html@v=12.html#2">Változó számú és típusú argumentumok feldolgozása</a>
<li><a href="index.html@v=12.html#3">Type promotion</a>
<li><a href="index.html@v=12.html#4">Saját printf</a>
<li><a href="index.html@v=12.html#5"><code>fv()</code>, <code>fv(void)</code>, <code>fv(...)</code></a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>A változó argumentumszámú függvények hívása</h2>
</div>

<p>A dolognak van egy rákfenéje, mégpedig az, hogy a változó argumentumszámú függvényeknél
nincsen típusellenőrzés. Ez azt jelenti, hogy a fordító
semmilyen ellenőrzést nem végez a paramétereket illetően, csak beteszi őket a verembe
szép sorjában, és a függvénynek a feladata kitalálni valamilyen módon, hogy hány
paramétert kapott, és hogy mi lehet azoknak a típusa. Ez is célja a <code>printf()</code>
formátumsztringjének: az abban megadott <code>%d</code>, <code>%s</code> stb. kódokkal
adjuk meg azt, hogy milyen paramétereket kapott, és hogyan kell értelmezni azokat:

<pre class="brush: c "  >
char h[]=&quot;hello&quot;;
char v[]=&quot;vilag&quot;;
printf(&quot;%s %p %c %d&quot;, h, v, 'A', 'A');</pre>

<pre class="screenshot">
hello 0x40075c A 65
</pre>

<p>A fenti függvényhívás előbb kiírja a sztringet (hello), amelyre a <code>h</code>
pointer mutat. Utána kiírja a pointer értékét, vagyis a <code>v</code> memóriacímet.
Mindkettő típusa pointer, csak eltérőképpen értelmezzük! A harmadik kiírt dolog egy
karakter, mégpedig az <code>A</code> betű. A negyedik pedig egy egész szám, az
<code>A</code> karakter kódja. Itt is egyezik a típus: mindkettő egész szám, csak másképp
értelmezzük kiíráskor.

<p>Sajnos a típusellenőrzés hiánya azt is jelenti, hogy automatikus konverziók nem lehetségesek.
Ha deklarálunk egy <code>f(double)</code> függvényt, akkor az meghívható <code>f(2)</code>
módon, hiszen a fordító tudja, hogy a 2-es egész számot konvertálnia kell <code>2.0</code>
értékre, amely <code>double</code> típusú. Nincs azonban ez így a <code>printf()</code>-nél
a változó argumentumszám miatt:

<pre class="brush: cbub "  >
printf(&quot;%f\n&quot;, 2);   // helytelen (nálam 0.000000-t ír ki)

printf(&quot;%f\n&quot;, 2.0); // helyes, 2.000000-t ír ki</pre>



</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>Változó számú és típusú argumentumok feldolgozása</h2>
</div>

<p>Egy ilyen függvény hogyan éri el a paramétereit, ha még megnevezni
sem tudja azokat?

<p>Erre valók az <code>stdarg.h</code>-ban definiált makrók:

<pre class="brush: c "  >
#include &lt;stdarg.h&gt;

/* elindítja a változó számú argumentumok feldolgozását. */
void va_start(va_list ap, utolsó);

/* lekéri a következő paramétert, amelynek típusa „típus” */
típus va_arg(va_list ap, típus);

/* befejezi a feldolgozást */
void va_end(va_list ap);</pre>

<p>Ezeket a következőképpen kell használni:
<ul>
   <li>Definiálni kell egy <code>va_list</code> típusú változót. Ez lesz a paramétere
      a makróknak.
   <li>A feldolgozás előtt meg kell hívni a <code>va_start</code> makrót. Ennek meg kell
      adni az utolsó olyan paramétert, amelynek még van neve, vagyis a <code>...</code> előttit. (Ebből az következik, hogy
      legalább egy névvel rendelkező paraméternek lennie kell – a <code>printf()</code>-nél
      ez a formátumsztring.)
   <li>Az egyes paraméterek értékeit a <code>va_arg</code> makró adja meg, amelynek meg
      kell adnunk mindig a következő paraméter típusát. (A <code>printf()</code> ezt
      a formátumsztringből találja ki.)
   <li>Ha befejeztük, akkor meg kell hívni a <code>va_end</code> makrót.
</ul>

<p>Egy példa függvény, amely kiírja a neki megadott tetszőleges számú
sztringet a képernyőre:

<pre class="brush: cbub "  >
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void sztringek(char const *elso, ...) {
   va_list ap;
   char *kovetkezo;
   
   if (elso!=NULL)
      printf(&quot;Elso: %s\n&quot;, elso);       // ezt még közvetlenül elérjük
   
   va_start(ap, elso);

   kovetkezo=va_arg(ap, char*);         // első a ...-ban
   while (kovetkezo!=NULL) {
      printf(&quot;Tovabbi: %s\n&quot;, kovetkezo);
      kovetkezo=va_arg(ap, char*);      // továbbiak a ...-ban
   }
   
   va_end(ap);
}

int main(void) {
   sztringek(&quot;hello&quot;, &quot;vilag&quot;, NULL);
   
   return 0;
}</pre>

<p>Figyeljük meg: valahonnan a függvénynek tudnia kell, hogy
hol van vége a paraméterlistának. Ezért a paraméterek után teszünk egy
strázsát: egy NULL pointert, amely a sor végét jelzi. Ezt nem szabad
elfelejteni, hiszen utána memóriaszemét van a veremben, és a függvény
különben nem tudná, hol van vége a sorozatnak! (Azért jó itt a NULL pointert, hiszen az
is pointer, mint a sztringek – vagyis típusban kompatibilis azokkal. Ha
egész számokat összegezne a függvény, akkor például 0 vagy -1 lehetne
a strázsa.)

<p>
A háttérben? Fekete mágia. A <code>va_start</code> ráállít egy pointert
az első változóra, a <code>va_arg</code> pedig változtatja ennek a pointernek
az értékét. Az általunk megadott típusból tudja azt, hogy hány bájttal kell
léptetni, és hogy milyen típusúvá kell castolni azt az egyes hívásokkor.
A helyzet azonban még ennél is bonyolultabb…




</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>Type promotion</h2>
</div>

<table class="float">
   <thead>
   <tr><th>Miből<th>Mi lesz
   </thead>
   <tr><td>char <td>int
   <tr><td>short<td>int
   <tr><td>float<td>double
</table>

<p>A változó számú argumentumok esetén ugyanis történik konverzió, mégpedig az
egyes „kicsi” típusok a nekik megfelelő „nagy” típussá konvertálódnak. A konverziók
jobb oldalt láthatók.
Ez azt jelenti, hogy ha változó számú argumentumlistán átadunk egy karakter
típusú változót, akkor azt a függvény <code>int</code>-té konvertálva kapja meg. Természetesen
nem gond, hiszen az <code>int</code> ábrázolási tartománya nagyobb, vagyis
adat nem veszik el. Csak figyelni
kell erre a <code>va_arg()</code> makró használatakor. Egyébként ez a konverzió
előnyös, hiszen ezért képes működni egy ilyen programrész:

<pre class="brush: c "  >
char c='A';
printf(&quot;Karakter: %c, kod: %d&quot;, c, c);</pre>

<p>A fordító ugyanis nem tudja azt, hogy a függvény karaktert vagy <code>int</code>-et
vár, hiszen a típusok a <code>...</code> miatt ismeretlenek.
Ezért inkább a karaktert is <code>int</code>-té konvertálja. (Ezzel kapcsolatban
a <a href="index.html@v=12.html#labjegyzet">lábjegyzetet</a> lásd lent.)



</div>
</section>
<section id="4">
<div class="slide" id="slide_4">
<div class="slideheader">
<h2><span class="oldalszam">4</span>Saját printf</h2>
</div>

<p>A fentiek alapján elkészíthetjük a <code>printf()</code> egy saját, leegyszerűsített
változatát. A lenti függvény ismeri a sztring, a karakter és az egész típust. A működése
egyszerű: sorban írja ki a kapott formátumsztring karaktereit, és ha egy <code>%</code>
jelbe botlik, akkor a formátumsztring következő karakterét megvizsgálva látja az ahelyett kiírandó
paraméter típusát.

<pre class="brush: cbub "  >
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void egesz_kiir(int mi) {
   if (mi/10&gt;0)
      egesz_kiir(mi/10);
   putchar(mi%10+'0');
}

void sajat_printf(const char *formatum, ...) {
   va_list ap;
   char *sztringptr;
   int i;

   va_start(ap, formatum);
   for (i=0; formatum[i]!=0; i++) {
      if (formatum[i]=='%') {   /* ha %, akkor feldolgozás */
         i++;
         switch (formatum[i]) {
            case 's':
               sztringptr=va_arg(ap, char*); // következő: egy char*
               while (*sztringptr!=0)
                  putchar(*sztringptr++);
               break;
            case 'c':
               putchar(va_arg(ap, int));     // char, de intként kapjuk!
               break;
            case 'd':
               egesz_kiir(va_arg(ap, int));  // int, egész számot írunk ki
               break;
            case '%':
               putchar('%');
               break;
         }
      }
      else
         putchar(formatum[i]); /* ha nem %, simán kiírjuk */
   }
   va_end(ap);
}

int main(void) {
   sajat_printf(&quot;[%s, %s%c %d fok van.]\n&quot;, &quot;Hello&quot;, &quot;Taz&quot;, '!', 15);
   return 0;
}</pre>





</div>
</section>
<section id="5">
<div class="slide" id="slide_5">
<div class="slideheader">
<h2><span class="oldalszam">5</span><code>fv()</code>, <code>fv(void)</code>, <code>fv(...)</code></h2>
</div>

<p>A fentiek miatt, és tradicionális okokból is C-ben a
<code>fv()</code> és az <code>fv(void)</code> függvény fejléc teljesen
mást jelent:

<dl>
    <dt><code>fv(void)</code></dt>
    <dd>Egy olyan függvény, amelynek nincs paramétere, és nem is kaphat.

    <dt><code>fv(int x, ...)</code></dt>
    <dd>Változó paraméterszámú függvény. A <code>...</code> előtt legalább
    egy neves paraméter kell legyen, hogy a feldolgozást a fent bemutatott módon
    el lehessen végezni.

    <dt><code>fv()</code></dt>
    <dd>Egy olyan függvény deklarációja, amely bármennyi és bármilyen típusú paramétert
        kaphat. Mivel a paraméterek nincsenek megnevezve, ezért nem lehet
        elérni őket. Ennek nagy szerepe a C szabványosítás előtti változatában
        volt, amikor a függvényeket így kellett definiálni:
        <pre class="brush: c "  >
int osszeg(a, b)
int a;
int b;
{
    return a+b;
}</pre>
        Ez működik a mostani fordítókkal is, de ellenjavalt.
</dl>






<div class="megjegyzes" id="labjegyzet">
<h3>Lábjegyzet</h3>
<p>Két megjegyzés a „fordító nem tudja azt”-tal kapcsolatban.
<p>Az egyik, hogy a GCC a <code>printf()</code>
stílusú függvényeknél összehasonlítja a formátumsztringet és a kapott
paramétereket. Ha ezek nem stimmelnek, akkor <em>figyelmeztetést</em> küld:
<pre class="brush: c "  >
printf(&quot;Hello, %s&quot;, 5);</pre>
<pre class="screenshot">
proba.c:50:4: warning: format ‘%s’ expects type ‘char *’, but argument 2 has type ‘int’
</pre>
<p>Ez igen hasznos dolog. Sajnos nem minden fordító tesz így. Viszont ez csak figyelmeztetés;
a C nyelvtani szabályai szerint a fenti sor helyesnek számít. (Szintaktikailag helyes,
szemantikailag helytelen.)
<p>A másik, hogy ugyancsak a GCC figyelmeztetést küld akkor is, ha leírjuk a <code>va_arg(ap, char)</code>
sort: mivel a karakter típusú argumentum <code>int</code>-té konvertálódik, ezért ez biztosan
csak hibás lehet.
<pre class="screenshot">
proba.c:33:32: warning: ‘char’ is promoted to ‘int’ when passed through ‘...’
proba.c:33:32: note: (so you should pass ‘int’ not ‘char’ to ‘va_arg’)
proba.c:33:32: note: if this code is reached, the program will abort
</pre>
</div>
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="index.html@v=12.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="../index.html"><img src="../modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="../index.html">főoldal</a> · <a href="../elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
