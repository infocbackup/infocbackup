<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Adventi naptár</title>
<meta property="og:title" content="InfoC :: Adventi naptár">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="InfoC :: Adventi naptár">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="InfoC :: Adventi naptár">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="../modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v10.css">
<script src="../modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="../index.html">InfoC</a></div>
<ul>
<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="../index.html">Kezdőlap</a>
<li><a href="../nhf.html">Nagy házi feladat</a>
<li><a href="../elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="../ea01.html">1. hét: bevezetés</a>
<li><a href="../ea02.html">2. hét: algoritmusok</a>
<li><a href="../ea03.html">3. hét: tételek, tömbök</a>
<li><a href="../ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="../ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="../ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../ea09.html">9. hét: láncolt listák</a>
<li><a href="../ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="../ea12.html">12. hét: bináris fák</a>
<li><a href="../ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="../ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="../gy02.html">2. hét: algoritmizálás</a>
<li><a href="../gy03.html">3. hét: egyszerű programok</a>
<li><a href="../gy04.html">4. hét: tételek és tömbök</a>
<li><a href="../gy05.html">5. hét: függvények</a>
<li><a href="../gy06.html">6. hét: származtatott típusok</a>
<li><a href="../gy07.html">7. hét: mutatók használata</a>
<li><a href="../gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="../gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="../gy11.html">11. hét: láncolt listák I.</a>
<li><a href="../gy12.html">12. hét: láncolt listák II.</a>
<li><a href="../gy13.html">13. hét: bináris fák</a>
<li><a href="../gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="../lab01.html">1. hét: operációs rendszer</a>
<li><a href="../lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="../lab03.html">3. hét: egyszerű programok</a>
<li><a href="../lab04.html">4. hét: tömbök</a>
<li><a href="../lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="../lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="../lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="../lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="../lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="../lab11.html">11. hét: láncolt listák</a>
<li><a href="../lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="../lab13.html">13. hét: bináris fák</a>
<li><a href="../lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="../f01.html">1. hét: egyszerű programok</a>
<li><a href="../f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="../f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="../f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="../f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="../f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../f09.html">9. hét: láncolt listák</a>
<li><a href="../f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="../f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="../f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="../jegyzet.html">Jegyzet és puska</a>
<li><a href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="../stilus.html">Kódolási stílus</a>
<li><a href="../tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="../debugmalloc.html">Debugmalloc</a>
<li><a href="../mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="../nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="../nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="../nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="../orak.html">SVG óra galéria</a>
<li><a href="../angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="../turing.html">Mit tud a számítógép?</a>
<li><a href="../bf.html">BF</a>
<li><a href="../bitturmix.html">Bitturmix</a>
<li><a href="../labirintus.html">Labirintusok</a>
<li><a href="../tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../karakterkodolas.html">Karakterkódolások</a>
<li><a href="../strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="../internet.html">Internet</a>
</ul>

<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="../sdl.html">SDL grafika</a>
<li><a href="../sdl_telepito.html">SDL telepítés</a>
<li><a href="../fa.html">Fák rajzolása</a>
<li><a href="../lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="index.html@v=14.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="../mondatelemzo.html">Mondatelemző</a>
<li><a href="../kifejezesek.html">Kifejezések</a>
<li><a href="../derivalas.html">Deriválás</a>
<li><a href="../ast_epit.html">AST: szintaxisfák</a>
<li><a href="../ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="../ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="../advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<div class="float" style="margin-top: 0.25em; margin-bottom: 0;"><a href="../advent.html">&larr; vissza</a></div>
<h1 class="eloadascim">Adventi naptár</h1>
<h2>Reflektivitás</h2>

<p>
Van egy programunk, amely különféle típusú objektumok adatait tárolja. Ezeknek
az objektumoknak az adatait ki kell írni fájlokba, és vissza kell olvasni őket
onnan. Néha meg kell jeleníteni egy objektum adatait egy párbeszédablakban,
hogy a felhasználó átírhassa azokat stb.

<p>
Legyen erre egy egyszerű
példa egy téglalap:

<pre class="brush: c "  >
struct Teglalap {
    int px, py;             /* pozicio a kepernyon */
    int szeles, magas;      /* meret */
};</pre>

<p>
És a fájlba írt változat, ahogyan ott egy téglalap kinéz:

<pre class="papir">
PozicioX=5
PozicioY=10
MeretX=15
MeretY=20
</pre>

<p>
A következő problémákkal szembesülünk. Ha a programot továbbfejlesztjük, a
téglalapnak esetleg új tulajdonsága jelenik meg, pl. az új verzió a színét
is eltárolja. A kódot egy csomó helyen módosítanunk kell:

<ul>
    <li>A <code>teglalap.h</code> fájlban, ahol a struktúra definiálva van.
    <li>A <code>teglalap_save()</code> függvényben, amelyik egy téglalap adatait
        kiírja egy fájlba.
    <li>A <code>teglalap_load()</code> függvényben, amelyik beolvassa azokat.
    <li>A <code>teglalap_edit()</code> függvényben két helyen is; egyrészt ahol
        létrehozzunk a téglalap tulajdonságai párbeszédablakban a beviteli mezőket,
        másrészt pedig ahol visszaolvassuk azokat, és egy adott struktúrába
        elmentjük.
    <li>… és így tovább.
</ul>

<p>
A másik probléma az, hogy esetleg többféle objektumot szeretnénk hasonló
módon kezelni. A kör objektumokat is hasonló módon mentjük fájlba, jelenítünk
meg hozzájuk ablakot. A <code>kor_save()</code> függvény szinte ugyanúgy néz
ki, mint a <code>teglalap_save()</code> függvény, csak mások a tulajdonságok
nevei. A hasonlóság pedig azt sejtteti, hogy valahogyan általánosítani lehetne.
Vagy éppen kellene.

<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="index.html@v=14.html#1">Reflektivitás</a>
<li><a href="index.html@v=14.html#2">A végeredmény</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>Reflektivitás</h2>
</div>

<p>Ami itt hiányzik nekünk a C-ből, az a 
reflektivitás. Arra lenne szükségünk itt, hogy valahogyan fel tudjuk sorolni 
egy struktúra adattagjait – például úgy, hogy sztringként tudjuk megadni azt,
hogy melyikre szeretnénk hivatkozni. Meg hogy egy <code>for()</code> ciklussal 
végig tudjunk menni rajtuk.  Ha a struktúrában egy tömb lenne, akkor
ez működne… De a különálló adattagokra ilyet nem lehet. 

<p>
 Azt viszont meg lehet csinálni, hogy felsoroljuk az adattagok neveit és melléjük pointereket
egy adott példány adattagjaira. Ez könnyen általánosítható bármilyen típusú tagra,
úgyhogy maradjunk az egészeknél:

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

typedef struct Teglalap {
    int px, py;         /* pozicio a kepernyon */
    int szeles, magas;  /* meret */
} Teglalap;

void teglalap_save(Teglalap *t) {
    int i;
    struct {
        char const *nev;
        int *adattag;
    } t_adatai[] = {
        { &quot;PozicioX&quot;, &amp;t-&gt;px },
        { &quot;PozicioY&quot;, &amp;t-&gt;py },
        { &quot;MeretX&quot;, &amp;t-&gt;szeles },
        { &quot;MeretY&quot;, &amp;t-&gt;magas },
        { NULL }
    };

    for (i = 0; t_adatai[i].nev != NULL; ++i)
        printf(&quot;%s=%d\n&quot;, t_adatai[i].nev, *t_adatai[i].adattag);
}

int main(void) {
    Teglalap t = {5, 10, 15, 20};
    
    teglalap_save(&amp;t);
}</pre>

<p>Itt a <code>for()</code> ciklus elég kényelmes már, és jól használható az adattagok 
táblázatos formája is. A probléma csak az, hogy az <code>int*</code> pointerek egy adott téglalap
példányhoz kötődnek. Emiatt kellett a függvényen belül definiálni a tömböt; hogy kezdeti 
értékként a pointerek megkapják az egyes intekre mutató értékeket, a konkrét
<code>*t</code> téglalap adattagjaira mutatva. Tehát a struktúra inicializálását ugyanígy szerepeltetni 
kell a többi helyen is, vagyis ha módosul a téglalap struktúra, akkor még mindig sok helyen kell 
javítgatni a programot.

<p>Ha több téglalap példányunk van, akkor bár az <code>int*</code> pointerek eltérőek, viszont 
minden téglalap memóriaképe megegyezik. Egy téglalap memóriaterületének elejétől számítva egy 
bizonyos adattag mindig ugyanannyi bájtnyira van. Ha az adattagokat leíró struktúrában ezt 
tárolnánk a cím helyett, akkor azt <em>bármelyik téglalapra</em> használhatnánk. Az offszetet úgy
kapjuk, hogy kivonjuk az adott adattag memóriacíméből a téglalap elejének memóriacímét; persze 
mindkét pointert <code>char*</code>-gá konvertáljuk, hogy az eredményt bájtokban kapjuk:

<pre class="brush: c "  >
printf(&quot;%d\n&quot;, (int)((char*)&amp;t.px-(char*)&amp;t));
printf(&quot;%d\n&quot;, (int)((char*)&amp;t.py-(char*)&amp;t));</pre>

<p>
Ezt visszafelé is meg lehet csinálni. Ha egy <code>char*</code> típusú mutatóhoz &ndash;
amelyik egy téglalap memóriaképének az elejére mutat &ndash; hozzáadjuk az így létrehozott
offszeteket, akkor a szóban forgó adattagra kapunk egy <code>char*</code> típusú
pointert, amit aztán a megfelelő típusúra cast-olhatunk:

<pre class="brush: cbub "  >
int pxo = (int)((char*)&amp;t.px-(char*)&amp;t);  // ofszet
int pyo = (int)((char*)&amp;t.py-(char*)&amp;t);

printf(&quot;%d&quot;, *(int*)((char*)&amp;t + pxo)); // ofszetbol pointer
printf(&quot;%d&quot;, *(int*)((char*)&amp;t + pyo));</pre>

<p>
Ezek az offszetek az adott téglalap példányoktól függetlenek; így már akkor is
meghatározhatóak, amikor még nem tudjuk, melyik téglalappal kell majd dolgoznia
egy függvénynek. Ez egyben azt is jelenti, hogy a téglalapokat leíró tömböt
(amely a neveket és az offszeteket tartalmazza) csak egyszer kell definiálnunk,
nem pedig minden függvényben.

</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>A végeredmény</h2>
</div>
<p>
Még egy apró trükk. Az offszetek meghatározásához
még arra sincsen szükség, hogy akár egyetlen egy téglalap is létezzen. A
NULL pointert ugyanis castolhatjuk <code>Teglalap*</code> típusúvá. Ennek ugyan
egy adott elemére nem hivatkozhatunk <code>((Teglalap*)0)->px</code>, de egy adott
elem memóriacímére igen: <code>&(((Teglalap*)0)->px)</code>. Ebből kivonva a NULL
pointert kapjuk az offszetet. Így született a lenti <code>OFFSETOF</code> makró.

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

#define OFFSETOF(STRUKT,MEMBER) ((char*)(&amp;((STRUKT *)0)-&gt;MEMBER)-(char*)0)
#define MEMBER(MEMBERTYPE,STRUKTP,OFFSET) (*(MEMBERTYPE *)((char*)STRUKTP+OFFSET))

typedef struct Teglalap {
    int px, py;
    int szeles, magas;
} Teglalap;

struct {
    char const *nev;
    int offset;
} teglalap_leiro[] = {
    { &quot;PozicioX&quot;, OFFSETOF(Teglalap, px) },
    { &quot;PozicioY&quot;, OFFSETOF(Teglalap, py) },
    { &quot;MeretX&quot;, OFFSETOF(Teglalap, szeles) },
    { &quot;MeretY&quot;, OFFSETOF(Teglalap, magas) },
    { NULL }
};

int main(void) {
    Teglalap t = {5, 10, 15, 20};
    int i;
    
    for (i = 0; teglalap_leiro[i].nev != NULL; ++i)
        printf(&quot;%s=%d\n&quot;, teglalap_leiro[i].nev,
                          MEMBER(int, &amp;t, teglalap_leiro[i].offset));
    
    return 0;
}</pre>

<p>Némely C fordítók megengedik azt, hogy <code>void*</code> mutatókat vonjunk ki egymásból. 
Ilyenkor az eredményt ugyanúgy bájt egységekben kapjuk, mint <code>char*</code> esetén. Ez 
azonban nem szabványos, ezért kellenek a <code>char*</code>-ok.
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="index.html@v=14.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="../index.html"><img src="../modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="../index.html">főoldal</a> · <a href="../elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
