<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Adventi naptár</title>
<meta property="og:title" content="InfoC :: Adventi naptár">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="InfoC :: Adventi naptár">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="InfoC :: Adventi naptár">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="../modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v10.css">
<script src="../modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="../index.html">InfoC</a></div>
<ul>
<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="../index.html">Kezdőlap</a>
<li><a href="../nhf.html">Nagy házi feladat</a>
<li><a href="../elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="../ea01.html">1. hét: bevezetés</a>
<li><a href="../ea02.html">2. hét: algoritmusok</a>
<li><a href="../ea03.html">3. hét: tételek, tömbök</a>
<li><a href="../ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="../ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="../ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../ea09.html">9. hét: láncolt listák</a>
<li><a href="../ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="../ea12.html">12. hét: bináris fák</a>
<li><a href="../ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="../ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="../gy02.html">2. hét: algoritmizálás</a>
<li><a href="../gy03.html">3. hét: egyszerű programok</a>
<li><a href="../gy04.html">4. hét: tételek és tömbök</a>
<li><a href="../gy05.html">5. hét: függvények</a>
<li><a href="../gy06.html">6. hét: származtatott típusok</a>
<li><a href="../gy07.html">7. hét: mutatók használata</a>
<li><a href="../gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="../gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="../gy11.html">11. hét: láncolt listák I.</a>
<li><a href="../gy12.html">12. hét: láncolt listák II.</a>
<li><a href="../gy13.html">13. hét: bináris fák</a>
<li><a href="../gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="../lab01.html">1. hét: operációs rendszer</a>
<li><a href="../lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="../lab03.html">3. hét: egyszerű programok</a>
<li><a href="../lab04.html">4. hét: tömbök</a>
<li><a href="../lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="../lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="../lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="../lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="../lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="../lab11.html">11. hét: láncolt listák</a>
<li><a href="../lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="../lab13.html">13. hét: bináris fák</a>
<li><a href="../lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="../f01.html">1. hét: egyszerű programok</a>
<li><a href="../f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="../f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="../f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="../f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="../f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../f09.html">9. hét: láncolt listák</a>
<li><a href="../f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="../f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="../f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="../jegyzet.html">Jegyzet és puska</a>
<li><a href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="../stilus.html">Kódolási stílus</a>
<li><a href="../tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="../debugmalloc.html">Debugmalloc</a>
<li><a href="../mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="../nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="../nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="../nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="../orak.html">SVG óra galéria</a>
<li><a href="../angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="../turing.html">Mit tud a számítógép?</a>
<li><a href="../bf.html">BF</a>
<li><a href="../bitturmix.html">Bitturmix</a>
<li><a href="../labirintus.html">Labirintusok</a>
<li><a href="../tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../karakterkodolas.html">Karakterkódolások</a>
<li><a href="../strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="../internet.html">Internet</a>
</ul>

<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="../sdl.html">SDL grafika</a>
<li><a href="../sdl_telepito.html">SDL telepítés</a>
<li><a href="../fa.html">Fák rajzolása</a>
<li><a href="../lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="index.html@v=16.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="../mondatelemzo.html">Mondatelemző</a>
<li><a href="../kifejezesek.html">Kifejezések</a>
<li><a href="../derivalas.html">Deriválás</a>
<li><a href="../ast_epit.html">AST: szintaxisfák</a>
<li><a href="../ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="../ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="../advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<div class="float" style="margin-top: 0.25em; margin-bottom: 0;"><a href="../advent.html">&larr; vissza</a></div>
<h1 class="eloadascim">Adventi naptár</h1>
<h2>Fizikai motor – biliárd</h2>

<img class="float" src="advent16-biliard.png">

<p>Írjunk programot, amely biliárdgolyók mozgását szimulálja! Legyen a pályán 15 színes golyó, 
és egy 16-odik fehér, amelyet az egérrel meg lehet lökni. A lökés erejét és irányát egy kattintás
után az egér elmozdítása határozza meg; a lökés az egérgomb elengedésekor történjen.




<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="index.html@v=16.html#1">A felhasználói felület</a>
<li><a href="index.html@v=16.html#2">A fizikai motor</a>
<li><a href="index.html@v=16.html#3">A golyókra ható erők</a>
<li><a href="index.html@v=16.html#4">A program</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>A felhasználói felület</h2>
</div>

<p>
A program grafikai része az SDL-lel és az SDL_gfx-szel végtelenül egyszerű. Van ezekben
ugyanis egy <code>filledCircleRGBA()</code> nevű függvény, amely egy kiszínezett
kört rajzol. Ez jó lesz golyónak a felülnézetben mutatott asztalhoz.

<p>Az egér koordinátáit és az egérgombokat le tudjuk kérdezni az <code>SDL_MOUSEMOTION</code>, 
illetve <code>SDL_MOUSEBUTTONDOWN</code> és <code>UP</code> események adatain keresztül. Az egérkattintást
egy apró állapotgéppel kell kezelni, amelynek két állapota lehet: nincs „megfogva” a fehér
golyó, vagy meg van fogva. Ha a kattintás a fehér golyón történik, akkor megfogjuk, amúgy
pedig nem történik semmi. Ha a gomb elengedése úgy történt, hogy előtte történt megfogás
is, akkor pedig a fehér golyó sebességet kap:

<img src="advent16-allapot.svg" style="width: 18em;" class="kozep">




</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>A fizikai motor</h2>
</div>

<p>
Az előző napi játékokban a mozgás nem épült fizikai törvényekre; egyszerűen
úgy lett meghatározva az elemek (fák stb.) mozgása a képernyőn, hogy az nagyjából
úgy nézzen ki, ahogyan azt a való világból megszoktuk. Izgalmasabb és valószerűbb
játékokat tudunk úgy csinálni, ha a valódi fizikai törvényeket használva számoljuk
ki a játék szereplőinek mozgását. Ennek előnye egyébként az is, hogy általában néhány
egyszerű fizikai törvényt kell a programban megvalósítanunk, és azokból a megszokott,
természetes mozgások automatikusan kiadódnak.

<p>
Minden golyónak van egy helyzete a képernyőn és egy sebessége. A helyzetük
megváltozása az időben a sebességüktől függ. A sebességük megváltozása pedig
a gyorsulásoktól. Gyorsulás a rájuk ható erő hatására keletkezhet: például ha egy
golyó nekinyomódik a falnak, akkor a fal kifejt egy rá merőleges erőt, amely
hatására a golyó visszafordul.

<p>A golyók adatai a lentiek. (A golyókra ható erők változói is a struktúrában
vannak. Ez tervezési szempontból nem helyes, hiszen ez nem a golyók tulajdonsága,
hanem a körülményekből adódik, de így egyszerűbb a kód.)

<pre class="brush: c "  >
typedef struct Golyo {
    double x, y;        /* helyzet */
    double vx, vy;      /* sebesség */
    double fx, fy;      /* erő */
    int c;              /* szín */
} Golyo;</pre>

<p>Ha ismerjük a golyóra ható <b>F</b> erőt, abból a gyorsulás számítható Newton II.
törvénye, az <b>F</b>=m<b>a</b> alapján. A sebességet elvileg a gyorsulás integrálásával,
a helyzetet pedig a sebesség integrálásával tudjuk meghatározni. Ez azonban nem ilyen
egyszerű – ha egy kicsit is elmozdul egy golyó, akkor megváltoznak rögtön
a rá ható erők. Az integrált emiatt csak közelítőleg tudjuk kiszámolni. Ha feltesszük,
hogy egy rövid <code>delta_t</code> időtartamon belül az erők állandók maradnak,
akkor az integrálokat szorzással közelíthetjük (ez Euler módszere):

<pre class="brush: c "  >
Golyo g;

g.x += g.vx*delta_t;
g.y += g.vy*delta_t;

g.vx += (g.fx/m)*delta_t;  /* ax*delta_t */
g.vy += (g.fy/m)*delta_t;  /* ay*delta_t */</pre>

<p>Minél kisebbre választjuk a <code>delta_t</code> értéket, annál pontosabb 
lesz a számítás. Az integrál értékére Euler módszere egy viszonylag rossz becslést
ad. Első körben azonban ez jó lesz. Már csak az erőket kell meghatároznunk.

</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>A golyókra ható erők</h2>
</div>

<p>A golyókra a következő erők hatnak:
<ul>
    <li>Ha a golyó falnak ütközik, akkor a fal eltaszítja magától.
    <li>Ha két golyó egymásnak ütközik, akkor azok is taszítják egymást.
    <li>Ha egy golyó gurul, akkor súrlódási erő hat rá. Ez az az erő, amitől
        végül a golyók megállnak.
</ul>

<h3>A súrlódási erő</h3>

<img src="advent16-surlodas.svg" style="width: 12em;" class="float">

<p>A súrlódás egy gördülési ellenállás. Ennek nagysága attól függ, hogy milyen
erősen nyomódik a golyó az asztalhoz. Az pedig attól, hogy mekkora a súlya:
F<sub>s</sub>&nbsp;=&nbsp;µ·F<sub>t</sub>&nbsp;=&nbsp;µ·mg.
Az iránya pedig mindig a sebességgel ellentétes. A hozzá tartozó vízszintes (x) és
függőleges (y) komponenseket ezért úgy tudjuk meghatározni, ha a sebességvektort
normalizáljuk (vagyis elosztjuk a saját hosszával), mivel akkor kapunk egy olyan
vektort, amely iránya megegyezik a sebességvektorral, a hosszúsága pedig pontosan
egy. Ezt az egységvektort kell komponensenként megszorozni a kapott súrlódási erővel,
és persze negatív irányban tekinteni. A zárójelben lévő vx/v és vy/v kifejezések
adják az egységvektor komponenseit:

<pre class="brush: c "  >
v=sqrt(vx*vx+vy*vy);
fx-=mu*g*m*(vx/v);
fy-=mu*g*m*(vy/v);</pre>

<h3>A golyók ütközése</h3>

<img src="advent16-utkozes.svg" style="width: 12em;" class="float">

<p>Amíg két golyó távol van egymástól, addig nem hatnak egymásra. Azonban ha találkoznak,
akkor az összeütközéskor erők lépnek fel. Ilyenkor benyomódnak egy kicsit, még ha
nagyon kemények is. Az összepréselődés hatására egy rugalmas erő lép fel.
Ezt modellezhetjük úgy, hogy a két golyó közé egy nagyon erős rugót képzelünk.

<p>A rugó erejét Hooke törvényéből, az F=-Dl képletből számíthatjuk ki, ahol l a rugó összenyomódása. A
két golyó érintkezésekor, amikor a középpontjuk távolsága
r<sub>1</sub>+r<sub>2</sub>, ez éppen nulla; ha ennél
közelebb kerülnek egymáshoz, akkor kezd el nőni. Az erő irányát a két golyó középpontját
összekötő egyenes határozza meg. Itt a számítást az előzőhöz hasonlóan végezhetjük:
a két középpont távolságát, mint vektort normalizáljuk. Ebből kapunk egy egységvektort,
amely éppen a megfelelő irányú. Ezt kell megszorozni az erővel:

<pre class="brush: c "  >
/* golyók távolsága */
dx=x1-x2;
dy=y1-y2;
tav=sqrt(dx*dx+dy*dy);

/* rugóerő */
if (tav&lt;2*golyo_r) {
    l=2*golyo_r-tav;
    f=golyo_d*l;
    fx+=dx/tav*f; /* egységvektor*f */
    fy+=dy/tav*f;
}</pre>

<h3>Golyó és fal ütközése</h3>

<img src="advent16-fal.svg" style="width: 12em;" class="float">

<p>Ez hasonlóan képzelhető el, mint két golyó ütközése. Minél jobban belenyomódik
egy golyó a falba (vagyis minél közelebb van a középpontja a falhoz a sugarához
képest), annál nagyobb erő hat rá. Ezt mind a négy falra külön ki kell számítani.
A négy fal négy különböző irányú erőt adhat.

<p>Ebben az esetben nincsen szükség arra, hogy normalizáljuk a vektort, hiszen
pl. a bal és a jobb oldalni falnál
függőleges, y irányú erő nem lép fel. Csak a vízszintes, x irányú erővel
kell foglalkozni, amely az x irányú benyomódásból adódik.
A bal oldali falat tekintve:

<pre class="brush: c "  >
if (x&lt;golyo_r)
    fx+=golyo_d * (golyo_r-x);</pre>



</div>
</section>
<section id="4">
<div class="slide" id="slide_4">
<div class="slideheader">
<h2><span class="oldalszam">4</span>A program</h2>
</div>

<p>A program letölthető innen: <a href="advent16-biliard.c">advent16-biliard.c</a>.
Ebben az egyes konstansokat (rugók ereje, nehézségi gyorsulás, golyók tömege) próbálgatással
állítottam be, hogy viszonylag jól nézzen ki az eredmény. 

<p>A programnak két gyengesége van. Egyik az, hogy nem számolja a golyók perdületét. Azaz
a golyók mindenhova forgás nélkül mozognak. Ez azt is jelenti, hogy nem lehet megcsavarni
őket.

<p>A másik probléma drámaibb ennél. Az integrál közelítésére alkalmazott Euler-féle módszer 
ugyanis nem túl pontos, sőt az ismert módszerek közül a legkevésbé pontos. Ha nem szeretnénk, 
hogy a golyók a képernyőn egymásba olvadjanak (és ez egyébként kihasson a szimuláció pontosságára
is), akkor kellően nagyra kell állítani a képzeletbeli rugók erejét meghatározó D rugóállandót
(a kódban <code>golyo_d</code>). Ilyenkor azonban nagy erők adódnak, amelyek a helytől erősen 
függenek, és nem jogos az a közelítés, hogy a <code>delta_t</code> időintervallumon belül az
erők, így a gyorsulás állandó. Ha egymás felé tart két golyó, még akár az is előfordulhat, hogy a
<code>delta_t</code> időn belül visszafordulnak az ütközés hatására.

<p>Emiatt ha túl nagy erővel lökjük meg a fehér golyót, akkor a szimuláció elszállhat (egyre 
gyorsul az összes golyó, és végül eltűnnek a képernyőről). A probléma orvoslására csökkenthetjük 
a <code>delta_t</code> időintervallumot, de jobb ötlet lenne egy másik integrálközelítő módszer 
használata. Általában a Runge-Kutta módszert szokták alkalmazni. Erről bővebben
itt lehet olvasni (példa kóddal): <a href="http://gafferongames.com/game-physics/integration-basics/">Integration Basics</a>.
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="index.html@v=16.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="../index.html"><img src="../modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="../index.html">főoldal</a> · <a href="../elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
