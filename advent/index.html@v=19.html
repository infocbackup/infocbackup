<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Adventi naptár</title>
<meta property="og:title" content="InfoC :: Adventi naptár">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="InfoC :: Adventi naptár">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="InfoC :: Adventi naptár">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="../modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v10.css">
<script src="../modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="../index.html">InfoC</a></div>
<ul>
<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="../index.html">Kezdőlap</a>
<li><a href="../nhf.html">Nagy házi feladat</a>
<li><a href="../elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="../ea01.html">1. hét: bevezetés</a>
<li><a href="../ea02.html">2. hét: algoritmusok</a>
<li><a href="../ea03.html">3. hét: tételek, tömbök</a>
<li><a href="../ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="../ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="../ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../ea09.html">9. hét: láncolt listák</a>
<li><a href="../ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="../ea12.html">12. hét: bináris fák</a>
<li><a href="../ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="../ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="../gy02.html">2. hét: algoritmizálás</a>
<li><a href="../gy03.html">3. hét: egyszerű programok</a>
<li><a href="../gy04.html">4. hét: tételek és tömbök</a>
<li><a href="../gy05.html">5. hét: függvények</a>
<li><a href="../gy06.html">6. hét: származtatott típusok</a>
<li><a href="../gy07.html">7. hét: mutatók használata</a>
<li><a href="../gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="../gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="../gy11.html">11. hét: láncolt listák I.</a>
<li><a href="../gy12.html">12. hét: láncolt listák II.</a>
<li><a href="../gy13.html">13. hét: bináris fák</a>
<li><a href="../gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="../lab01.html">1. hét: operációs rendszer</a>
<li><a href="../lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="../lab03.html">3. hét: egyszerű programok</a>
<li><a href="../lab04.html">4. hét: tömbök</a>
<li><a href="../lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="../lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="../lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="../lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="../lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="../lab11.html">11. hét: láncolt listák</a>
<li><a href="../lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="../lab13.html">13. hét: bináris fák</a>
<li><a href="../lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="../f01.html">1. hét: egyszerű programok</a>
<li><a href="../f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="../f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="../f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="../f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="../f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../f09.html">9. hét: láncolt listák</a>
<li><a href="../f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="../f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="../f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="../jegyzet.html">Jegyzet és puska</a>
<li><a href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="../stilus.html">Kódolási stílus</a>
<li><a href="../tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="../debugmalloc.html">Debugmalloc</a>
<li><a href="../mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="../nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="../nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="../nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="../orak.html">SVG óra galéria</a>
<li><a href="../angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="../turing.html">Mit tud a számítógép?</a>
<li><a href="../bf.html">BF</a>
<li><a href="../bitturmix.html">Bitturmix</a>
<li><a href="../labirintus.html">Labirintusok</a>
<li><a href="../tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../karakterkodolas.html">Karakterkódolások</a>
<li><a href="../strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="../internet.html">Internet</a>
</ul>

<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="../sdl.html">SDL grafika</a>
<li><a href="../sdl_telepito.html">SDL telepítés</a>
<li><a href="../fa.html">Fák rajzolása</a>
<li><a href="../lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="index.html@v=19.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="../mondatelemzo.html">Mondatelemző</a>
<li><a href="../kifejezesek.html">Kifejezések</a>
<li><a href="../derivalas.html">Deriválás</a>
<li><a href="../ast_epit.html">AST: szintaxisfák</a>
<li><a href="../ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="../ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="../advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<div class="float" style="margin-top: 0.25em; margin-bottom: 0;"><a href="../advent.html">&larr; vissza</a></div>
<h1 class="eloadascim">Adventi naptár</h1>
<h2>Fraktál tájképek és 3D rajzolás</h2>

<img src="advent19-hegy.jpg" class="kozep arnyek">

<p>Tetszik ez a hegy? Remélhetőleg igen, mert ilyeneket fog rajzolni a mai program. Ehhez két dolgot kell csinálnia:
<ul>
    <li>egy domborzati térképet kell generálnia, és
    <li>kirajzolni a térkép alapján megalkotott görbe felületet.
</ul>



<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="index.html@v=19.html#1">A fraktál tájképek</a>
<li><a href="index.html@v=19.html#2">A hegy kirajzolása</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>A fraktál tájképek</h2>
</div>

<p>A teknőcgrafika kapcsán láttuk, hogy némely fraktálok úgy alakíthatók ki, hogy egy alakzatot minden
lépésben bonyolítunk egy kicsit. Lehet egy ötletünk ezzel kapcsolatban: vigyünk be egy kis 
véletlenszerűséget ebbe a lépésbe! Az alábbi rajzon egy egyszerű szakasz látható, amelyet
ilyen módon bonyolítunk. Minden egyes lépésben fogjuk a szakaszt vagy szakaszokat, és azoknak középpontját
eltoljuk felfelé vagy lefelé véletlenszerűen, kettétörve ezzel azokat. A véletlenszerű eltolás
mértékét pedig aszerint csökkentjük, hogy mekkora szakaszt felezünk. Az elején még nagyokat
ugrunk, aztán egyre kisebbeket. Látható, hogy így egy hegy alakul ki:

<img src="advent19-hegyfraktal.svg" class="kozep" style="width: 40em;">

<img src="advent19-plazma.jpg" class="float arnyek">

<p>Nem kell mást tennünk, mint azt, hogy ezt általánosítanunk két dimenzióra, és már kész is a domborzati 
térkép. Egyik adventi bejegyzésben már történt hasonló dolog: a „plazma fraktálnak” csúfolt algoritmus 
éppen ezt csinálta. Annyi hiányossággal, hogy nem túl szépen tette ezt: az ábrán vízszintes és 
függőleges vonalak ismerhetőek fel, látszik rajta, hogy a generáló algoritmus vízszintesen és 
függőlegesen haladva átlagolja és tolja el a színeket. (A színek jelentik itt a szakasz y 
koordinátáját, az átlagolás pedig a szakasz kettéosztását: a szakasz két széle végpontjának y 
koordinátáit átlagolva a közepének y koordinátáját kapjuk.)

<p>Egy ügyes trükkel azonban lehet ezen segíteni. Ezt a trükköt a gyémánt–négyzet algoritmus
(diamond-square algorithm) valósítja meg. Működését nagyon könnyű megérteni az alábbi
rajzok alapján.

<p>Az eredeti, hibás algoritmus úgy működött, hogy minden négyzet (négy szomszédos kék pötty) által
közrezárt középső, zölddel jelölt pont színét a négy pont színének átlagából számolta ki, azt egy kis
véletlenszámmal módosítva. Az egyes kék pontok közötti pirossal jelölt pontok színét pedig
egyszerűen azokat átlagolva. Ezért alakultak ki a vízszintes-függőleges mintázatok, mert a pirossal
jelölt pontok színét csak a vízszintes-függőleges szomszédaik alapján számolta az algoritmus.

<div class="columns">
<div>
    <img src="advent19-square.svg" class="kozep" style="max-width: 18em;">
    <div class="kozep">a négyzet (eredeti)</div>
</div>
<div>
    <img src="advent19-diamondsquare.svg" class="kozep" style="max-width: 18em;">
    <div class="kozep">a négyzet és a gyémánt (javított)</div>
</div>
</div>

<p>A javított változat ezzel szemben így gondolkozik: számoljuk ki a 
zölddel jelölt pontok színét az előbbi módon, azonban ezek után a 
pirossal jelölt pontok színét pedig határozzuk meg úgy, hogy azok 
függjenek a most generált zöld pontoktól is! A zöld pontok kiszámolását 
nevezik a „négyzet lépésnek”, mivel a zöld pontok színét meghatározó 
kék pontok négyzet alakban helyezkednek el. A piros pontok 
kiszámolása pedig a „gyémánt lépés”, mert minden piros pontot 
meghatározó kék pontok (felette, alatta) és zöld pontok (tőle balra, 
jobbra) gyémánt alakban helyezkednek el. Mintha az egész ábrát 
elforgatnánk 45 fokkal a gyémánt lépés idejére, és úgy átlagolnánk a 
négyzet alakban elhelyezkedő pontokat.
Alább látható egy fraktál, amelyet az így javított algoritmus 
generált. Látható, hogy ebben már nincsenek meg az előbbiben 
halványan még felfedezhető vízszintes és függőleges csíkok.

<p>Na és hogy lesz ebből hegy? Egyszerűen! A generált számokat 
magasságértékeknek és színeknek is használjuk. A legkisebb, -1 körüli
számok az alacsony magasságot jelzik, és kék színt kapnak (az lesz a
hegyi tó). Utána egy hirtelen átmenettel a zöld jön, aztán a barna, 
és végül a fehér. A legmagasabb, +1 körüli helyeken lesz a fehér a
hó színe.

<div class="columns">
    <div>
    <img src="advent19-plazmaoke.jpg" class="kozep arnyek" style="max-width: 80%">
    </div>
    <div>
    <img src="advent19-hegyoke.jpg" class="kozep arnyek" style="max-width: 80%">
    </div>
</div>


<p>A szélső pontok problémásak még az algoritmus szempontjából. A bal
szélső piros pontnak (lásd az előbbi ábrát) például nincsen bal oldali zöld szomszédja, 
amely meghatározná a színét. Nagyban leegyszerűsíthetjük a 
programunkat, ha a peremek külön esetként kezelése helyett a kép 
másik oldalán lévő pontokat tekintjük szomszédoknak. (Ezt biztosan sokan
csináltátok, akik életjátékot írtatok a nagyháziban.) Például ha a kép
256 képpont széles, akkor a 255-ös pont jobb oldali szomszédjának a 
255+1 = 256 &rarr; 0-s pontot vesszük. Ha a kép mérete kettő valamely
hatványa, ezt egy egyszerű bitenkénti és művelet megoldja mindkét 
irányban, pozitív és negatív „túlindexelés” esetén is. Egy
256×256-os térkép esetén:

<pre class="brush: c "  >
enum { MERET = 1&lt;&lt;8 };                  /* legyen 2 hatvanya! */
typedef double Magassag[MERET][MERET];</pre>

<p>A térkép egy adott pontján a magasságot beállító, és a magasságot lekérdező függvény:

<pre class="brush: c "  >
/* beallitja az adott koordinatan a magassagot.
 * x es y ket oldalt &quot;tulpordul&quot; */
void beallit(Magassag k, int x, int y, double szin) {
    if (szin &lt; -1) szin = -1;
    if (szin &gt; +1) szin = +1;
    k[y &amp; (MERET - 1)][x &amp; (MERET - 1)] = szin;
}

/* kiolvassa a magassagterkeprol az adott koordinatat.
 * x es y koordinata a ket oldalt &quot;tulpordul&quot; */
double magassag(Magassag k, int x, int y) {
    return k[y &amp; (MERET - 1)][x &amp; (MERET - 1)];
}</pre>

<p>Ez figyelembe veszi a magasságot megadó szám korlátait is:
-1 lesz a legmélyebb völgy, +1 a legmagasabb hegy, és
valós számokat használunk. A két szélen körbeforduló számítás miatt a
generált fraktál csempézhető is: több darabját egymás mellé rakva a
széleken folytonos átmeneteket kapunk.

<p>Egy négyzet lépés így végezhető el:

<pre class="brush: c "  >
/* negyzet alaku atlagolas. az x, y a cel koordinata, a
 * meret azt mondja meg, hogy mekkora negyzetbol vegye az atlagot */
void negyzet(Magassag k, int x, int y, int meret, double maxelteres) {
    int fel = meret / 2;
    double a = magassag(k, x - fel, y - fel);
    double b = magassag(k, x + fel, y - fel);
    double c = magassag(k, x - fel, y + fel);
    double d = magassag(k, x + fel, y + fel);
 
    beallit(k, x, y, (a + b + c + d)/4.0 + frand()*maxelteres);
}</pre>

<p>Ennek megadjuk a kiszámolandó pont koordinátáit (x, y), és annak a négyzetnek a méretét (meret), amelyen belül
az átlagolást el kell végeznie. A maxeltérés paraméter adja meg a legnagyobb véletlenszerű
eltolást, amit csinál. (Az <code>frand()</code> függvényünk -1 és +1 közötti véletlenszámot generál.)
Látszik, hogy ez már nem foglalkozik a kép széleivel: feltételezi, hogy a <code>magassag()</code>
és a <code>beallit()</code> függvénye helyesen kezelik azt. A gyémánt lépés a fentihez hasonlóan működik.

<p>A térkép generálása pedig úgy működik, hogy egyre kisebb, négyzet alakú területeken
végezzük el előbb a négyzet lépést, utána pedig a gyémánt lépést. A területek méretét a <code>lepes</code>
változó adja meg, amelyet először a kép teljes méretétől indítunk, aztán pedig minden iterációban
felezzük, amíg el nem jutunk az egy képpont méretű lépésig – mert addigra készen is vagyunk:

<pre class="brush: c "  >
/* Letrehoz egy uj, veletlenszeru terkepet */
void terkep_general(Magassag k) {
    int x, y;
    int lepes;
    double maxelteres;
    
    beallit(k, 0, 0, 0);  /* kiindulopont - legyen mindig kozepmagassag */

    /* mindig megfelezve a darabokat, ujabb pontokat generalunk */
    for (lepes = MERET, maxelteres = 1; lepes &gt; 1; lepes /= 2, maxelteres /= 2) {
        int fellepes = lepes / 2;
        /* negyzetek belseje */
        for (y = fellepes; y &lt; MERET + fellepes; y += lepes)
            for (x = fellepes; x &lt; MERET + fellepes; x += lepes)
                negyzet(k, x, y, lepes, maxelteres);
        /* gyemantok belseje */
        for (y = 0; y &lt; MERET; y += lepes)
            for (x = 0; x &lt; MERET; x += lepes) {
                gyemant(k, x + fellepes, y, lepes, maxelteres);
                gyemant(k, x, y + fellepes, lepes, maxelteres);
            }
    }
}</pre>

<p>Érdekesség, hogy a térkép generálása nem négy meghatározott pontból, hanem egyetlen egy 
pontból indul. Az első lépése a 256×256-os képen az lesz, hogy elhelyezzen egy véletlenszerű 
pontot a (0;0) koordinátán, és utána elvégezze az első „négyzet lépést”. Gondolhatnánk, hogy 
nincsen négy pont, amit ehhez átlagolni lehetne, de van: a (0;0), a (0;256), a (256;0) és a
(256;256) pontok. Ne feledjük, a képen minden irányban körbesétálhatunk (jobb oldalt ki, bal oldalt
be stb), tehát ezek a pontok léteznek, és átlagolhatóak: tulajdonképpen a (0;0) pontot vesszük 
négyszer, és azt átlagoljuk. Ezután már valójában is létezik több pont, amit átlagolni lehet.

<p>Az első mai letölthető program a térképet rajzolja ki:
<a href="advent19-terkep.c">advent19-terkep.c</a>. A szóköz gomb minden megnyomására egy új
fraktált generál. A színátmeneteket előállító függvény a Mandelbrot-fraktálos programból származik.
A kirajzolás előtt végez a képen egy minimum- és maximumkeresést, hogy utána a legkisebb és a legnagyobb
számot „kihúzza” a -1 és +1 értékekhez – így látszik a teljes színpaletta.
Érdemes játszani egy kicsit az algoritmus paramétereivel (a maxeltérés kezdeti értékével és osztójával) a
<code>terkep_general()</code> függvényben,  és a színekkel a <code>szineket_kiszamol()</code>
függvényben. Nem csak hegyeket lehet ezzel a programmal rajzolni, hanem például felhőket is.











</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>A hegy kirajzolása</h2>
</div>

<p>Térjünk át a háromdimenziós részre – hiszen adott egy magasságérkép, most már csak ki kellene
rajzolni a görbe felületet, amely a hegyet adja ki.

<div class="columns">
<div>
    <img src="advent19-negyszogeksima.svg" style="width: 16em;" class="kozep">
</div>
<div>
    <img src="advent19-negyszogek.svg" style="width: 16em;" class="kozep">
</div>
</div>

<p>Ahhoz, hogy ez szép legyen, a tegnapi drótvázról át kell térnünk kitöltött sokszögekre.
Ehhez egy egyszerű négyzetrácsból indulhatunk ki. Fogjunk meg tehát egy csomó négyzetet, amelyek
az <code>y=0</code> síkon fekszenek (bal oldali ábra), és toljuk el ezek pontjait függőlegesen
a magasságtérkép szerint (jobb oldali ábra). Bár így már nem négyzetek lesznek, de nem baj,
a hegyet megkapjuk. Ha még színeket is rendelünk az egyes négyszögekhez, már meg is kaptuk azt
a sokszöghalmazt, amelyet ki kell rajzolnunk. Ha van N×N pontunk, (N-1)×(N-1) négyszöget
kell kezelnünk.

<img src="advent19-hegy32.jpg" class="kozep arnyek">

<p>Csakhogy a kirajzolás nem olyan egyszerű, mint a drótváznál. Ugyanis nem dobálhatjuk csak fel 
a négyszögeket a képernyőre tetszés szerinti sorrendben – egyes négyszögek részben vagy teljesen 
elfedhetnek másik példányokat. A fenti drótváz rajzon például az utolsó előtti sor balról második 
négyszöge egyáltalán nem látszik. A repülős játéknál már találkoztunk ezzel a problémával. Ott a 
rossz sorrendű kirajzolás esetén úgy nézett ki, mintha a repülő a fenyőfa alatt ment volna el.

<p>A szép megoldás erre a problémára z-pufferelés (z-buffer) nevű eljárás lenne. Az abból az egyszerű 
felismerésből indul ki, hogy a keletkező két dimenziós képen minden egyes képpont színét pontosan
egy térbeli test határozza meg – mégpedig az, amelyik a legközelebb van abban az irányban. Tehát
a sokszögek kirajzolásakor nem kellene mást tennünk, mint minden egyes térbeli sokszögnek megfelelő
síkbeli sokszög kirajzolásakor kiszámolni azt is, hogy az egyes kiszínezett képpontok milyen
távol vannak a megfigyelőtől, és azt feljegyezni a képpont adata mellé. (Tehát a kép minden pixeléhez
tartozik még egy z érték.) Ha közelebbi képpontot
kell rajzolni, akkor a rajzolást meg kell tenni, és feljegyezni az új távolságot a képponthoz;
ha távolabbit, akkor pedig semmi teendő nincsen.

<p>Az SDL_gfx könyvtárral ezt azonban nem tudjuk megoldani, mert az két dimenzióban számol csak.
Helyettesíthetjük viszont egy újabb trükkel: rendezzük kirajzolás előtt távolság szerint
csökkenő sorrendbe a sokszögeket! Ha a kirajzolandó négyszögek kicsik és nem metszik egymást, 
így is szép ábrát fogunk kapni. Márpedig a négyszögeink kicsik és nem metszik egymást. (Mindenki 
átgondolhatja maga, hogy a két feltétel közül melyik miért fontos.)

<p>Az adatszerkezet hasonló a drótvázas programéhoz. A <code>Pont</code> struktúra tárolja egy
pont térbeli adatait (eredeti és forgatott koordinátáit, képernyőre leképezett koordinátáit),
a <code>Negyszog</code> pedig négy pontra hivatkozik:

<pre class="brush: c "  >
typedef struct Pont {
    double x, y, z;     /* eredeti 3d koordináta */
    double xf, yf, zf;  /* forgatott 3d koordináta */
    int xk, yk;         /* képernyőn koordináta */
} Pont;

typedef struct Negyszog {
    Pont *sarkok[4];
    Uint32 szin;
} Negyszog;</pre>

<p>A kirajzolásnál előbb elforgatjuk irányba az összes pontot, utána rendezzük a négyszögeket
távolság szerint, végül pedig elvégezzük a rajzolást:

<pre class="brush: c "  >
void kirajzol(Pont pontok[], Negyszog negyszogek[], double fx, double fy) {
    int i;

    boxRGBA(screen, 0, 0, screen-&gt;w, screen-&gt;h, 0, 0, 0, 255);

    /* forgatott koordináták számolása */
    for (i = 0; i &lt; MERET*MERET; ++i) {
        Pont p1 = pontok[i];
        Pont p2 = { p1.x*cos(fy)-p1.z*sin(fy), p1.y, p1.x*sin(fy)+p1.z*cos(fy) };
        Pont p3 = { p2.x, p2.y*cos(fx)-p2.z*sin(fx), p2.y*sin(fx)+p2.z*cos(fx) };
        pontok[i].xf = p3.x;
        pontok[i].yf = p3.y;
        pontok[i].zf = p3.z;
        pontok[i].xk = screen-&gt;w/2 + 600 * pontok[i].xf / (pontok[i].zf+600);
        pontok[i].yk = screen-&gt;h/2 - 600 * pontok[i].yf / (pontok[i].zf+600);
    }
    /* rendezés és kirajzolás */
    qsort(negyszogek, (MERET-1)*(MERET-1), sizeof(negyszogek[0]), negyzetrendez);
    for (i=0; i&lt;(MERET-1)*(MERET-1); ++i)
        negyzet_rajzol(negyszogek[i]);

    SDL_Flip(screen);
}</pre>

<p>Az összes pont forgatásával a négyszögek „automatikusan” forognak, hiszen a négyszögek
maguk nem tárolnak koordinátákat, hanem csak hivatkoznak a pontokra. Így most is megúszunk
egy csomó számítást, mivel egy pont négy négyszöghöz is tartozik. A felesleges számításokat
pedig jobb kerülni, mert itt már tényleg olyan dolgot csinálunk, amit nem a gép központi
processzorával kellene csináltatni, hanem a grafikus kártyával. Nem véletlen a <code>qsort()</code>
választása. A szélsőértékkereséses vagy a buborékrendezés erre már alkalmatlan. (Ezt is kipróbálhatja
mindenki: a gyorsrendezést a programban egy szélsőértékkereséses rendezésre cserélve
használhatatlanul lassúvá válik az egész.) Ez nagyon fontos, mert egy 256×256-os térkép azt jelenti,
hogy kb. 65000 négyszögünk van. Ha O(n<sup>2</sup>/2) időben futó rendezést használunk, az
kb. 2 milliárd összehasonlítást jelent! Ha O(n×logn) időben futót, az csak 1 milliót. (Ezt
is érdemes kipróbálni! Az összehasonlító függvénybe kell tenni egy sort, amely egy globális
változót megnövel eggyel. A <code>qsort()</code> hívás előtt lenullázva azt a változót, ellenőrizhető,
hogy hányszor hívódott az összehasonlító függvény.)

<p>Az adatszerkezetet a <code>hegy_general()</code> építi föl:

<pre class="brush: c "  >
/* uj hegyet general. ehhez keszit egy uj terkepet, es abbol kiindulva
 * meghatarozza a magassagokat */
void hegy_general(Pont *pontok, Negyszog *negyszogek, SDL_Color pal[]) {
    Magassag *k;
    int x, y;
    
    /* itt most ilyen furcsan foglalodik a 2d tomb, egyszerre. */
    /* csak azert kell igy, mert ha tul nagy, nem fer a verembe! */
    k = (Magassag *) malloc(sizeof(Magassag));

    terkep_general(*k);

    for (y = 0; y &lt; MERET; ++y)
        for (x = 0; x &lt; MERET; ++x) {
            int i = y*MERET + x;
            pontok[i].x = 500 * (x / (double)MERET - 0.5);
            pontok[i].y = 128 * ((*k)[y][x]) - 32;
            pontok[i].z = 500 * (y / (double)MERET - 0.5);
        }
    for (y = 0; y &lt; MERET-1; ++y)
        for (x = 0; x &lt; MERET-1; ++x) {
            int i = y*(MERET-1) + x;
            int c = (magassag(*k, x, y) + frand()/32)*127+128;
            if (c &lt; 0) c = 0;
            if (c &gt; 255) c = 255;
            negyszogek[i].sarkok[0] = &amp;pontok[y*MERET+x];
            negyszogek[i].sarkok[1] = &amp;pontok[y*MERET+x+1];
            negyszogek[i].sarkok[2] = &amp;pontok[(y+1)*MERET+x+1];
            negyszogek[i].sarkok[3] = &amp;pontok[(y+1)*MERET+x];
            negyszogek[i].szin = pal[c].r&lt;&lt;24 | pal[c].g&lt;&lt;16 | pal[c].b&lt;&lt;8 | 0xFF;
        }
}</pre>

<p>Ez a pontok <code>x</code> (vízszintes) és <code>z</code> (távolság) koordinátáit a rácspontok
szerint határozza meg, <code>y</code> (függőleges) koordinátáját pedig a kapott hegy magasságai
szerint. A négyszögek csúcsait pedig a szomszédos pontokra állítja be (<code>x</code> és <code>x+1</code>,
illetve <code>y</code> és <code>y+1</code>), figyelve arra a sorfolytonosra lapított kétdimenziós
tömbnél, hogy míg a pontok tömbje <code>MERET</code> széles, a négyzeteké csak <code>MERET-1</code>
szélességű. A négyszög színét is a magasság határozza meg – egy kis véletlenszámot még hozzáad,
egyszerűen csak azért, mert így szebb lesz a rajz. (A tavaknál ez kicsit bekavar – szorgalmi
feladat kijavítani.)

<p>A kész program letölthető innen: <a href="advent19-hegy.c">advent19-hegy.c</a>. A hegyet
forgatni a nyilakkal lehet, új domborzati térképet generálni pedig a szóközzel. Aki meg szeretné
izzasztani a gépét, kipróbálhatja, hogy néz ki egy 256 pont (<code>MERET = 1&lt;&lt;8</code>) által meghatározott hegy,
vagy egy 512 (<code>MERET = 1&lt;&lt;9</code>) által meghatározott.

<p>A program módosított változata, az <a href="advent19-trip.c">advent19-trip.c</a> 
varázsszőnyeget rajzol ki. Aztán hamarosan majd a levegő is fog hullámozni – de arra még egy 
kicsit rá kell pihenni. Holnap játék!
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="index.html@v=19.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="../index.html"><img src="../modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="../index.html">főoldal</a> · <a href="../elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
