<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Adventi naptár</title>
<meta property="og:title" content="InfoC :: Adventi naptár">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="InfoC :: Adventi naptár">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="InfoC :: Adventi naptár">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="../modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v10.css">
<script src="../modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="../index.html">InfoC</a></div>
<ul>
<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="../index.html">Kezdőlap</a>
<li><a href="../nhf.html">Nagy házi feladat</a>
<li><a href="../elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="../ea01.html">1. hét: bevezetés</a>
<li><a href="../ea02.html">2. hét: algoritmusok</a>
<li><a href="../ea03.html">3. hét: tételek, tömbök</a>
<li><a href="../ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="../ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="../ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../ea09.html">9. hét: láncolt listák</a>
<li><a href="../ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="../ea12.html">12. hét: bináris fák</a>
<li><a href="../ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="../ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="../gy02.html">2. hét: algoritmizálás</a>
<li><a href="../gy03.html">3. hét: egyszerű programok</a>
<li><a href="../gy04.html">4. hét: tételek és tömbök</a>
<li><a href="../gy05.html">5. hét: függvények</a>
<li><a href="../gy06.html">6. hét: származtatott típusok</a>
<li><a href="../gy07.html">7. hét: mutatók használata</a>
<li><a href="../gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="../gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="../gy11.html">11. hét: láncolt listák I.</a>
<li><a href="../gy12.html">12. hét: láncolt listák II.</a>
<li><a href="../gy13.html">13. hét: bináris fák</a>
<li><a href="../gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="../lab01.html">1. hét: operációs rendszer</a>
<li><a href="../lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="../lab03.html">3. hét: egyszerű programok</a>
<li><a href="../lab04.html">4. hét: tömbök</a>
<li><a href="../lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="../lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="../lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="../lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="../lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="../lab11.html">11. hét: láncolt listák</a>
<li><a href="../lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="../lab13.html">13. hét: bináris fák</a>
<li><a href="../lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="../f01.html">1. hét: egyszerű programok</a>
<li><a href="../f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="../f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="../f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="../f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="../f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../f09.html">9. hét: láncolt listák</a>
<li><a href="../f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="../f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="../f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="../jegyzet.html">Jegyzet és puska</a>
<li><a href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="../stilus.html">Kódolási stílus</a>
<li><a href="../tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="../debugmalloc.html">Debugmalloc</a>
<li><a href="../mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="../nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="../nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="../nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="../orak.html">SVG óra galéria</a>
<li><a href="../angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="../turing.html">Mit tud a számítógép?</a>
<li><a href="../bf.html">BF</a>
<li><a href="../bitturmix.html">Bitturmix</a>
<li><a href="../labirintus.html">Labirintusok</a>
<li><a href="../tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../karakterkodolas.html">Karakterkódolások</a>
<li><a href="../strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="../internet.html">Internet</a>
</ul>

<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="../sdl.html">SDL grafika</a>
<li><a href="../sdl_telepito.html">SDL telepítés</a>
<li><a href="../fa.html">Fák rajzolása</a>
<li><a href="../lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="index.html@v=20.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="../mondatelemzo.html">Mondatelemző</a>
<li><a href="../kifejezesek.html">Kifejezések</a>
<li><a href="../derivalas.html">Deriválás</a>
<li><a href="../ast_epit.html">AST: szintaxisfák</a>
<li><a href="../ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="../ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="../advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<div class="float" style="margin-top: 0.25em; margin-bottom: 0;"><a href="../advent.html">&larr; vissza</a></div>
<h1 class="eloadascim">Adventi naptár</h1>
<h2>Síelés</h2>

<img class="float arnyek" src="advent20-si.png">

<p>
Síeljünk! Itt egy program, ami három dimenzióban rajzolja ki a sípályát. A pályán, amelynek
széleit egy halvány szürke vonal jelzi, bóják és fák vannak. Természetesen 
lejt is. A síelő ezen halad lefelé; egy fának nekimenve pontlevonást kap, bóját
eltalálva pontot. A játékban kanyarodni a balra és jobbra nyilakkal lehet; hóekézni
pedig a lefelé nyíllal.

<p>
A játék érdekessége, hogy programozási szempontból alig különbözik a múltkor bemutatott
repülős játéktól – ugyanazok a problémák kerülnek elő itt is (változó számú objektumok,
egymás átfedése stb.), mint annál.





<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="index.html@v=20.html#1">A játék működése</a>
<li><a href="index.html@v=20.html#2">Emlékeztető a három dimenzióról</a>
<li><a href="index.html@v=20.html#3">A kirajzolás trükkjei</a>
<li><a href="index.html@v=20.html#4">A program</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>A játék működése</h2>
</div>

<p>A játékban hősünk <em>elvileg</em> egy lejtős pályán száguld lefelé a fák és bóják között a 
völgy felé. Az „elvileg” itt nem töltelékszó, mert ez a programban nem feltétlenül kell így 
történjen: végülis nem muszáj a programban a lejtős pályát számolni, éppen elegendő az is, ha az 
eredmény <em>úgy néz ki, mintha</em> lejtene a pálya. Sőt hősünknek nem muszáj a fák és bóják 
felé csúsznia sem: az is jó, ha a fák és a bóják jönnek felé. A látvány a monitoron ugyanolyan 
lesz! Induljunk ki ebből a gondolatból, mert mint kiderül, a dolgunk sokkal egyszerűbb lesz, ha a
játékos a tér <em>origójában</em> van.

<img src="advent20-sielooldalrol.svg" style="width: 28em;" class="kozep">

<p>Tehát a program dolga a következő. Minden időlépésben a pálya összes elemének <code>z</code>
koordinátáját csökkenti, azaz mindent a játékos felé mozgat. Ha valamelyik pályaelem a játékos
mögé kerül, akkor azt már
el lehet dobni. Hátrafordulni úgysem fog, és hegynek felfelé csúszni sem. Így egyre fogynak az
akadályok a pályán – vagyis fogynának, ha a program nem generálna véletlenszerűen újakat jó messze
a játékostól. A <code>main()</code> függvény ide vonatkozó része minden hosszegységenkénti
csúszás után (ami a programban tíz méter) generál néhány új pályaelemet.


<p>Mivel az új elemek messze vannak, és a közelebbi fák eltakarják azokat, ez nem észrevehető.
(Ha az <code>ELEMEK</code> konstans értékét túl alacsonyra állítjuk, akkor viszont nagyon is.) 
Apropó, láthatóság! Ahogyan a repülős programban meg kellett oldani, hogy a repülők felül legyenek,
és a tájképesnél is figyelni kellett a négyszögek sorrendjére, itt is foglalkozni kell ezzel a 
problémával. A közeli tárgyaknak el kell fedniük a távoliakat!

<img src="advent20-sielofentrol.svg" style="width: 22em;" class="float">

<p>Egy kis trükkel ez itt egyszerűen megoldható: mivel az egyes pályaelemek távolságviszonya,
<code>z</code> koordináta szerinti sorrendje nem változik, nem kell soha sorbarendezni őket. Ha 
fogunk egy várakozási sort, és annak a végére kerülnek az új fák, bóják, a sor elején pedig azok 
vannak, amelyek már a legközelebb vannak a játékoshoz, éppen olyan sorrendben lesznek benne az 
elemek (hátulról előrefelé), ahogyan ki kell rajzolni azokat. A program láncolt listája ehhez 
képest szándékosan pont fordítva van, mert akkor a láncolás sorrendje megegyezik a kirajzolás
sorrendjével. Így a lista <em>elején</em> a legtávolabbi elemek vannak, ezért az újakat oda
kell beszúrni; a kirajzoláshoz pedig előrefelé kell haladni a listában. Az elejére beszúrást meg
úgyis szeretjük, az a legegyszerűbb.

<p>A <code>main()</code> függvény <code>v</code> változója tárolja a játékos sebességét és a 
csúszásának irányát (<code>szog</code>) is. Az utóbbinál a 90 fok jelenti az egyenesen előrét, 
azaz a völgy irányát. Ezekből számolódik ki az, hogy éppen hol van a pályán – de csak az <code>x
</code> koordináta, <code>xpos</code>, mivel az <code>y</code> mindig nulla. A játék hangulatát 
és látványosságát javítandó, a <code>doles</code> változó azt a szöget tárolja, ahány fokkal a 
játékos bedől a kanyarban. A kirajzoláskor ennyivel elforgatja a teljes nézetet. Ezen változók
kezelése az eseményhurokban történik. A dőlés 10 fokra, a mozgási irány eltérése a völgynek lefelétől
pedig 15 fokra van maximálva:

<pre class="brush: c "  >
doles *= 0.7;
if (key[SDLK_LEFT]) {        /* balra kanyarodas - nyomva tartassal */
    szog-=3;
    if (szog&lt;75)             /* limit */
        szog=75;
    if (doles&gt;-10)           /* bedoles a kanyarban (z tengely szerinti forg.) */
        doles-=1;
}</pre>

<p>A <code>doles*=0.7</code> értékadás hatására a gomb elengedése után rövid időn belül visszatér
egyenesbe a nézet. A mozgás lelkét az alábbi a programrész adja:

<pre class="brush: c "  >
lefele += -v*sin(szog*3.14/180);
/* ha ennyit ment lefele, akkor uj HOSSZEGYSEGnyi meretet general a palyahoz */
if (lefele &lt; -HOSSZEGYSEG) {
    uj_palyaresz(&amp;lista, (ELORE-1)*HOSSZEGYSEG);
    lefele += HOSSZEGYSEG;
}
jelenet_mozgat(&amp;lista, 0, 0, -v*sin(szog*3.14/180));
jelenet_feldolgoz(hatter, &amp;lista, xpos, (szog-90)*3.14/180, doles*3.14/180, &amp;pont);</pre>

<p>Ez az előbb említett módon számolja, hogy mennyit csúszott lefelé a játékos, és szükség
esetén új pályaelemeket hoz létre: <code>uj_palyaresz()</code>. Aztán mozgatja a játékos felé
a fákat, bójákat: <code>jelenet_mozgat()</code>, és végül kirajzol mindent:
<code>jelenet_feldolgoz()</code>. A feldolgozás része az is, hogy a játékos mögé került elemek
törlődnek. Ezt azért volt kényelmes így megoldani, mert a forgatás által is kerülhetnek negatív
<code>z</code> koordinátára pályaelemek, a forgatás pedig a kirajzolás közben történik csak meg.





</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>Emlékeztető a három dimenzióról</h2>
</div>

<p>Minden egyes tárgy, amelyik a képernyőn megjelenik, először még három dimenzióban van,
<code>x</code>, <code>y</code>, és <code>z</code> koordinátákkal is rendelkezik. Az <code>x</code> tengely a vízszintes, az
<code>y</code> a függőleges (de felfelé nő, nem lefelé), a <code>z</code> tengely pedig a mélységet jelenti, 
vagyis az átdöfi a monitort. A nagyobb <code>z</code> koordinátájú tárgyak távolabb vannak. Ezeket a 
három dimenziós koordinátákat kell leképezni a két dimenziós monitorra.
Minél messzebb van egy tárgy, annál kisebbnek kell látszódjon. A drótvázas testek kirajzolása 
kapcsán már szerepelt az, hogyan képezhetőek le a koordináták:

<img src="advent20-persp.svg" style="width: 42em;" class="kozep">

<p>Láttuk, hogy a leképezés képlete a két háromszög hasonlóságából vezethető le, és azt is, hogy a leképezett
tárgyak alakja függ a megfigyelő vetítési síktől (itt: y tengely) vett távolságától. A síelős programban
ez tovább egyszerűsödik, ugyanis ebben a játékos nem kívülről szemléli a teret, hanem benne lesz
abban. Ahogy az előbb már szerepelt: konkrétan ő lesz az origában, tehát <code>d=0</code>.
Ettől a perspektívát leíró <code>y'=d&middot;y/(d+z)</code>
képlet persze megbolondulna, úgyhogy tekintsünk inkább <code>d=1</code>-et. Írjunk bele még egy ex-has
dolgot a képletbe. Döntsük el már most, hogy a programban tárolt koordináták méterben lesznek megadva. Például
ha egy fenyőfa négy méter magas, legyen annak koordinátája <code>y=4</code>. Végülis mindegy, hogy milyen
arányokat választunk, ezért megtehetjük, hogy egy nekünk kényelmeset adunk meg. Hogy a képernyőn megjelenő
fenyőfa ne legyen négy pixeles, nagyítsuk fel a kapott képet. Vagyis térjünk át a játékbeli koordinátákról
(világkoordinátákról) képernyőkoordinátákra ezekkel a képletekkel:

<pre class="brush: c "  >
xk =  f.x/(f.z+1)*500 + kep-&gt;w/2;
yk = -f.y/(f.z+1)*500 + kep-&gt;h/2;</pre>


<p>A játékos origóba helyezése miatt a számítások nagyon leegyszerűsödnek, különösen a három
forgatás, amellyel a program számol. Ezek a következők. Először is, az világkoordináták szerint sík pályát meg
kell dönteni előrefelé, azaz
meg kell forgatni az <code>x</code> tengely körül (pitch). Emiatt olyan, mintha lejtene az egész.
Meg kell forgatni az <code>y</code> tengely körül is (yaw), mégpedig azért, mert ez adja a játékos
csúszásirányát. Végül pedig, kell egy forgatást végezni a <code>z</code> tengely körül (roll), mert
ebből lesz a kanyarban bedőlés. Mindezt azután, hogy a kirajzolás közben a tárgyak koordinátáit
elmozdítottuk <code>xpos</code>-zal, és még függőlegesen lefelé -1,7 méterrel. Miért? Mert az
a játékos szemmagassága:

<pre class="brush: c "  >
f = pont3d_eltol(negyszog[i], xpos, -1.7, 0); /* sielo x pozicioja es szemmagassaga */
f = pont3d_forgat_x(f, 13*3.14/180);          /* lejto dolese */
f = pont3d_forgat_y(f, irany);                /* fordulas (merre nez) */
f = pont3d_forgat_z(f, doles);                /* kanyarban doles */</pre>

<p>Ha a <code>-1.7</code> helyett <code>-10</code>-et írunk, azt fogjuk látni, amit a repülős játékban
a pilóták láttak.





</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>A kirajzolás trükkjei</h2>
</div>

<p>
A perspektíva képletével a gond ott kezdődik, ha olyan pont koordinátáit helyettesítjük be, amelyek a néző
mögött vannak (vagyis <code>z&lt;0</code>). Ilyen esetekre a képlet hamis eredményt ad: a negatív előjel miatt
fejjel lefelé fordítja a képet – azt a képet, amit elvileg a játékos nem is lát.
Egy félig előtte, félig mögötte lévő szakaszt nem lehet kirajzolni
egy egyszerű kétdimenziós, monitoron lévő szakaszként: annak egyik pontja helyesen számolódik, a másodikra
viszont helytelen az eredmény. A programban ezért csalni fogunk: az ilyen szakaszokat,
vagyis az ilyen sokszögeket egyszerűen eldobjuk. Előbb-utóbb minden tereptárgy mellett elhalad a síelő,
ezért az összes tárgy erre a sorsra jut.

<p>A kirajzolt sokszögek egyébként a programban mind négyszögek. Minden tárgyhoz két négyszög tartozik, amelyek
eltérő színűek lehetnek:

<pre class="brush: c "  >
typedef struct Targy {
    enum { fa, boja, palyaszele } tipus;
    int nekiment;               /* 1, ha mar megkapta erte a pontot */
    Pont3D p0;                  /* referenciapont */
    Pont3D n1[4], n2[4];        /* ket negyszog - rajzhoz */
    Uint32 c1, c2;              /* ket szin */

    struct Targy *kov;          /* lancolt listahoz */
} Targy;</pre>

<p>A fenyőfa háromszöge, és a bója zászlója egyszerűen úgy van megcsinálva, hogy két-két pontjuk 
nagyon közel van egymáshoz. A tárgyakat létrehozó függvények a <code>fa_hozzaad()</code> és
<code>boja_hozzaad()</code>. Ezeknek egy <code>p0</code> pontot lehet megadni, amelyhez képest az új 
tárgyat elhelyezik. Sok a csalás megint. :)  A fenyőfa például teljesen lapos, csak mindig szinte
szemből látjuk. A megadott koordináták szerint függőlegesen, pontosan felfelé nő, az <code>y</code>
tengely irányába. Ezzel nem is lenne gond, ha nem forgatnánk el az egész pályát az <code>x
</code> tengely körül egy kicsit a kirajzoláskor. Látszik is valamennyire a játék közben, hogy 
ettől ferdék valamennyire. Persze a fenyőfa létrehozásánál lehetne kompenzálni, ha a csúcsához a 
<code>p0</code>-nál valamilyen közelebbi pontot választanánk, de nem lényeges. A függvényekben 
megadott koordinátákat kockás lapra lerajzolva egyébként szépen kiadódnának a rajzok. Például a 
fa:

<pre class="brush: c "  >
Targy *fa_hozzaad(Pont3D p0) {
    Targy *uj=(Targy *) malloc(sizeof(Targy));
    uj-&gt;tipus=fa;
    uj-&gt;nekiment=0;
    uj-&gt;p0=p0;
    uj-&gt;n1[0]=pont3d_eltol(p0, -0.1, 0, 0);
    uj-&gt;n1[1]=pont3d_eltol(p0, -0.1, 0.3, 0);
    uj-&gt;n1[2]=pont3d_eltol(p0,  0.1, 0.3, 0);
    uj-&gt;n1[3]=pont3d_eltol(p0,  0.1, 0, 0);
    uj-&gt;c1=0x402020FF; /* barna */
    uj-&gt;n2[0]=pont3d_eltol(p0, -0.8, 0.3, 0);
    uj-&gt;n2[1]=pont3d_eltol(p0, -0.1, 4.3, 0);
    uj-&gt;n2[2]=pont3d_eltol(p0,  0.1, 4.3, 0);
    uj-&gt;n2[3]=pont3d_eltol(p0,  0.8, 0.3, 0);
    uj-&gt;c2=0x008000FF; /* zold */
    return uj;
}</pre>

<p>
A sokszögeket az SDL <code>fillPolygonColor()</code> függvénye rajzolja ki. Ennek bárhány csúcsból álló
sokszöget meg lehet adni, és kifesti a belsejét is, nem csak a körvonalait rajzolja meg. A forgatások
és a szemmagasság miatti eltolási transzformáció után ellenőrizzük, hogy a forgatott pont <code>z</code> koordinátája
nem lett-e túl kicsi vagy negatív; ha az lett, akkor a <code>negyszog_kepernyore()</code> függvény
nem rajzolja ki a poligont, hanem <code>1</code>-gyel tér vissza. Ezzel jelzi a hívó <code>jelenet_feldolgoz()</code>
függvénynek, hogy az adott tárgyat a listából el kell távolítani. Mivel a tárgyak közelednek a néző felé,
ha egyszer kicsi a <code>z</code> koordinátájuk, akkor már később csak még kisebb lesz.
Az utóbbi függvény végzi egyébként az ütközések ellenőrzését is, amihez a pályaelemek <code>p0</code>
adattagját használja.


</div>
</section>
<section id="4">
<div class="slide" id="slide_4">
<div class="slideheader">
<h2><span class="oldalszam">4</span>A program</h2>
</div>

<p>A letölthető SDL-es program (<a href="advent20-si.c">advent20-si.c</a>) a szokásos módon fordítható.
A bemutatott trükkökkel együtt 320 kódsorba fért be a dolog.
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="index.html@v=20.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="../index.html"><img src="../modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="../index.html">főoldal</a> · <a href="../elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
