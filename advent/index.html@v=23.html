<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Adventi naptár</title>
<meta property="og:title" content="InfoC :: Adventi naptár">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="InfoC :: Adventi naptár">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="InfoC :: Adventi naptár">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="../modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v10.css">
<script src="../modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="../index.html">InfoC</a></div>
<ul>
<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="../index.html">Kezdőlap</a>
<li><a href="../nhf.html">Nagy házi feladat</a>
<li><a href="../elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="../ea01.html">1. hét: bevezetés</a>
<li><a href="../ea02.html">2. hét: algoritmusok</a>
<li><a href="../ea03.html">3. hét: tételek, tömbök</a>
<li><a href="../ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="../ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="../ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../ea09.html">9. hét: láncolt listák</a>
<li><a href="../ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="../ea12.html">12. hét: bináris fák</a>
<li><a href="../ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="../ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="../gy02.html">2. hét: algoritmizálás</a>
<li><a href="../gy03.html">3. hét: egyszerű programok</a>
<li><a href="../gy04.html">4. hét: tételek és tömbök</a>
<li><a href="../gy05.html">5. hét: függvények</a>
<li><a href="../gy06.html">6. hét: származtatott típusok</a>
<li><a href="../gy07.html">7. hét: mutatók használata</a>
<li><a href="../gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="../gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="../gy11.html">11. hét: láncolt listák I.</a>
<li><a href="../gy12.html">12. hét: láncolt listák II.</a>
<li><a href="../gy13.html">13. hét: bináris fák</a>
<li><a href="../gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="../lab01.html">1. hét: operációs rendszer</a>
<li><a href="../lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="../lab03.html">3. hét: egyszerű programok</a>
<li><a href="../lab04.html">4. hét: tömbök</a>
<li><a href="../lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="../lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="../lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="../lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="../lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="../lab11.html">11. hét: láncolt listák</a>
<li><a href="../lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="../lab13.html">13. hét: bináris fák</a>
<li><a href="../lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="../f01.html">1. hét: egyszerű programok</a>
<li><a href="../f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="../f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="../f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="../f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="../f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../f09.html">9. hét: láncolt listák</a>
<li><a href="../f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="../f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="../f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="../jegyzet.html">Jegyzet és puska</a>
<li><a href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="../stilus.html">Kódolási stílus</a>
<li><a href="../tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="../debugmalloc.html">Debugmalloc</a>
<li><a href="../mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="../nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="../nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="../nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="../orak.html">SVG óra galéria</a>
<li><a href="../angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="../turing.html">Mit tud a számítógép?</a>
<li><a href="../bf.html">BF</a>
<li><a href="../bitturmix.html">Bitturmix</a>
<li><a href="../labirintus.html">Labirintusok</a>
<li><a href="../tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../karakterkodolas.html">Karakterkódolások</a>
<li><a href="../strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="../internet.html">Internet</a>
</ul>

<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="../sdl.html">SDL grafika</a>
<li><a href="../sdl_telepito.html">SDL telepítés</a>
<li><a href="../fa.html">Fák rajzolása</a>
<li><a href="../lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="index.html@v=23.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="../mondatelemzo.html">Mondatelemző</a>
<li><a href="../kifejezesek.html">Kifejezések</a>
<li><a href="../derivalas.html">Deriválás</a>
<li><a href="../ast_epit.html">AST: szintaxisfák</a>
<li><a href="../ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="../ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="../advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<div class="float" style="margin-top: 0.25em; margin-bottom: 0;"><a href="../advent.html">&larr; vissza</a></div>
<h1 class="eloadascim">Adventi naptár</h1>



<h2>A zenegép</h2>

<p>A tegnapi írásban továbbfejlesztettük a hanggenerátort: az írás végére összeállt
program nem csak egy szinuszos jelet állít elő, hanem <em>felharmonikusokat</em> is használ,
és állítható benne a hang időbeli lefutása is. Így már el tudjuk orgonálni vagy klarinétozni
a boci boci tarkát.</p>

<p>Írjunk most egy olyan programot, amely egy zenét játszik le – mégpedig magától.
De természetesen a felhasználó által megadott adatok alapján.</p>

<img src="advent23-screenshot.jpg" class="kozep arnyek">

<p>Keringett egy időben a neten egy program, aminek a neve <em>Tone Matrix</em> volt. Ebben egy 16×16-os 
mátrix volt kirajzolva, amelyen a vízszintes irány volt az idő, a függőleges pedig a 
hangmagasság. A gép adott időközönként egy új oszlopra lépett, és az ott bejelölt hangokat 
szólaltatta meg. Ez fog történni a mi programunkban is – miközben persze a már szokásos módon be 
lehet majd állítani a hangok tulajdonságait.</p>





<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="index.html@v=23.html#1">A hangsor és a hangok</a>
<li><a href="index.html@v=23.html#2">A szintetizátor</a>
<li><a href="index.html@v=23.html#3">A program működése</a>
<li><a href="index.html@v=23.html#4">A forráskód</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>A hangsor és a hangok</h2>
</div>

<img class="float arnyek" src="advent23-zongora.png">

<p>Első kérdés, hogy milyen hangokból építsük fel a zenét. Ha a tizenkét zenei hangot csak össze-vissza
használjuk, abból szinte bizonyosan egy dallamtalan, disszonáns valami keletkezik. Egyik feltétel
tehát, hogy jól válasszunk a tizenkét hang közül. Például ha a zongora összes billentyűje
közül csak a fehéreket használjuk, azaz ezeket a hangokat:</p>

<p class="kozep"><strong>C</strong> D <strong>E</strong> F <strong>G</strong> A H</p>

<p>Akkor az ún. C dúr hangsort kapjuk meg. A hangok megválasztása a zene hangulatára is hatással
van (nem véletlenül hangfestő szó a hangulat!). A C dúrnak vidám hangulata van, ami már-már
indulószerű is tud lenni. Ebben a hangsorban a hangok közötti távolság, félhangokban mérve:
2, 2, 1, 2, 2, 2, 1 – ami azon is látszik, hogy hol van a zongorán fekete billentyű, hol nincs.</p>

<p>Ezzel szemben, ha tizenkettőből máshogy választjuk ki a használt hét hangunkat, például így:</p>

<p class="kozep"><strong>C</strong> D <strong>D#</strong> F <strong>G</strong> G# A#</p>

<p>Azaz a távolságok 2, 1, 2, 2, 1, 2, 2, mást kapunk. Ezeket a hangokat használva érzelmesebb,
sokszor szomorkásabb dallamokat írhatunk. Ez a C moll hangsor (bár nem pont így szokták jelölni
a zenészek).
A hangulatokat akkor érezzük a legjobban, ha egyszerre szólaltatjuk meg a hangsorok kiemelt,
három legfontosabb hangját: C, E, G a dúr esetén, és C, D#, G a moll esetén:</p>

<div class="columns">
    <div>
        <p class="kozep">
<audio controls>
    <source src="advent23-cdur.ogg" type="audio/ogg">
    <source src="advent23-cdur.mp3" type="audio/mpeg">
    <source src="advent23-cdur.wav" type="audio/x-wav">
</audio>
</p>
        <p class="kozep">C, E, G</p>
    </div>
    <div>
        <p class="kozep">
<audio controls>
    <source src="advent23-cmoll.ogg" type="audio/ogg">
    <source src="advent23-cmoll.mp3" type="audio/mpeg">
    <source src="advent23-cmoll.wav" type="audio/x-wav">
</audio>
</p>
        <p class="kozep">C, D#, G</p>
    </div>
</div>

<p>A dúr és a moll hangsorban (skálában) még mindig vannak olyan egymás melletti hangok, amelyek
között csak egy fél hang (kis szekund) a távolság. Ha ezeket együtt szólaltatjuk meg, kellemetlen
lebegést fogunk hallani. Hagyjunk tehát ki néhány ilyet, és maradjunk ezeknél a hangoknál:</p>

<p class="kozep">
<audio controls>
    <source src="advent23-c_penta.ogg" type="audio/ogg">
    <source src="advent23-c_penta.mp3" type="audio/mpeg">
    <source src="advent23-c_penta.wav" type="audio/x-wav">
</audio>
</p>
<p class="kozep">C D F G A</p>

<p>Ez egy <em>pentaton</em> (öt hangból álló) skála, amelyben a hangok közötti távolság: 2, 2, 3, 2, és
3 félhang. Miért jó ez? Mert bármit választunk ezek közül, sosem lesz disszonáns. Nem véletlenül a
legegyszerűbb dalok ezt használják, és a zenében tanítani is ezt szokták először. Ezek lesznek
a programban.</p>




</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>A szintetizátor</h2>
</div>

<p>A <em>szintetizátor</em> a tegnapitól alig különbözik. Kicsit egyszerűbb lett: nem tud
fázismodulációt, és az ADSR burkológörbének is csak a felfutás (attack) és elengedés (release)
fázisa van meg. Erre az egyszerűsítésre azért volt szükség, mert a másik két fázisnak nem nagyon
lett volna itt értelme: a felhasználó ebben a programban a hangok hosszát nem tudja megadni,
csak a megszólalásuk időpontjait specifikálja a mátrixszal. Az állapotgép, amely a hangerőt kezeli,
is ennek megfelelő: az indító jelre a felfutás fázisban feltekeri a hangerőt maximumra, és átvált
elengedésbe, ahol meg visszamegy nullára. Ha esetleg mindez több ideig tartana, mielőtt az új
indító jel jön, akkor annak hatására szintén felfutás fázisba ugrik:</p>

<div class="columns c6040">
    <div>
        <img src="advent23-ar_mod.svg" class="kozep" style="height: 11em;">
    </div>
    <div>
        <img src="advent23-allapotgep.svg" class="kozep" style="height: 11em;">
    </div>
</div>

<p>A hangszínen egy okos trükkel nagyon sokat lehet változtatni. Ha a generált szinusz hullámunkat
egy nemlineáris függvénnyel etetjük meg, akkor az eredeti szinusz jelentősen eltorzul. Az alábbi rajzon
a hiperbolikus tangens, és az ezzel a függvénnyel torzított szinusz látható:</p>

<img src="advent23-torzit.gif" class="kozep">

<p>Az így keletkezett függvények nem írhatók le egyetlen szinusszal, hanem csak sok szinusz 
összegeként (lásd a tegnapi írást), tehát a nemlineáris <em>torzítás</em> felharmonikusok 
garmadáját hozza be. Valahogy így működnek a gitártorzítók is: a gitár hangját keresztülviszik 
egy olyan áramköri elemen, amelynél nem lineáris a feszültség és az áram közötti összefüggés.

<p>Az újdonság még a tegnapi programhoz képest, hogy ennek a hangja sztereó. Minden megszólalt
hanghoz véletlenszerűen sorsol egy hangerőt a bal vagy a jobb oldalt preferálva. Sőt kis visszhangosítás
is van benne. A visszhanghoz egyszerűen eltárolja a régebbi hangot egy tömbben, és az aktuális mintához
hozzákeveri (persze gyengítve). A szintetizálást végző függvényben <code>sb</code> a bal oldali,
<code>sj</code> a jobb oldali minta:</p>

<pre class="brush: c "  >
/* visszhang hozzaadasa */
sb = sb + visszhang[2*visszhanghol] * 0.1;
sj = sj + visszhang[2*visszhanghol+1] * 0.1;
visszhang[2 * visszhanghol] = sj;   /* forditva! */
visszhang[2 * visszhanghol+1] = sb;</pre>

<p>Egy zenei hang szintetizálásának menetét az alábbi ábra foglalja össze. Itt látszik, hol, milyen
sorrendben és mi történik onnantól kezdve, hogy a szinuszok megszületnek.</p>

<img src="advent23-blokk.svg" class="kozep" style="width: 48em;">



</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>A program működése</h2>
</div>

<p>A program felhasználói felülete ugyanarra az eszközkészletre (widget.c) épül, mint a tegnapi.
Kicsit tovább kellett fejleszteni, új widgetekre volt szükség: egy olyan gombra, amellyel
a hangot ki-be lehet kapcsolni, és villanni is tud; továbbá egy szövegbeviteli mezőre, hogy
meg lehessen kérdezni a felhasználótól a betöltendő fájl nevét.</p>

<p>A szövegbeviteli mező nem egy igazi widget, amely reagál az egérkattintásokra, hanem inkább
csak egy függvény: az <code>input_text()</code>-et meghívva a képernyő adott helyén megjelenik
a mező, és egészen addig semmilyen más felhasználói bemenetre nem reagál a program, amíg
a bevitelt záró entert meg nem kapja. A függvény belseje tulajdonképpen az SDL-es írás
<code>input_text()</code> függvényének egy átdolgozott változata, saját eseményvezérelt hurokkal.</p>

<p>Meg kellett oldani, hogy a szöveg bevitele után eltűnjön a szövegbeviteli mező. Ezért lett a 
widget.c modulnak egy <code>minden_widget_ujrarajzol()</code> függvénye. Ez trükkös, mert ez a 
függvény tulajdonképpen nem rajzol újra semmit, hanem csak az események (kattintás, billentyű, 
egérmozgás stb.) várakozási sorába betesz egy <code>MINDENT_UJRARAJZOL</code> típusú eseményt, 
amit aztán az <code>esemenyvezerelt_main()</code> előbb-utóbb fel fog dolgozni:</p>

<pre class="brush: c "  >
enum { MINDENT_UJRARAJZOL = SDL_USEREVENT + 1 };

/* olyan esemenyt tesz be a sorba, amelynek hatasara minden widget ujra lesz rajzolva */
void minden_widget_ujrarajzol(void) {
    SDL_Event ev = { MINDENT_UJRARAJZOL };
    SDL_PushEvent(&amp;ev);
}</pre>

<p>A <code>minden_widget_ujrarajzol()</code> maga nem is látja az egyes widgetek adatait (a 
pointereket, amelyek arra mutatnak), így meg se tudná hívni a rajzoló függvényeket, az 
<code>esemenyvezerelt_main()</code> viszont biztosan látja azokat, így oda delegálható ez a 
feladat. Ehhez a fenti konstanssal egy saját típusú eseményt adunk meg. Az SDL-ben az esemény
típusa egy egyszerű egész szám, és a dokumentáció szerint az <code>SDL_USEREVENT</code> feletti
számok szabadon használhatóak.</p>

<p>Hasonlóan működik ez akkor is, amikor egy fájlból betöltődik a zenedarab. A szintetizátor
tulajdonságainak (időállandók, felharmonikusok stb.) átállítása után újra kell rajzolni a csúszkákat.
Itt a nem túl szép (de legalább egyszerű) megoldás szerepel a programban: ez is meghívja a
<code>minden_widget_ujrarajzol()</code> függvényt. A csúszkák kódja egyébként úgy lett módosítva,
hogy a csúszka maga szándékosan nem is tárolja el az értékét (0 és 1 közötti valós szám), hanem inkább
egy pointert tárol, hogy hol van az a <code>double</code> szám, amellyel össze van kötve. Így
ha a felhasználó kattint rá, akkor bele tudja írni a megváltozott értéket, de ha a programból
változik a szám, akkor is látja az új értéket az újrarajzoláskor:</p>

<pre class="brush: c "  >
Widget *uj_csuszka(int x, int y, int szeles, int magas, double *valtoztatott);</pre>

<p>Ez tipikus probléma egyébként a felhasználói felületeknél. A program lényegét, belsejét
(jelen esetben a szintetizátort és a zenegépet) mindig igyekszünk úgy megírni, hogy az legyen
minél jobban elválasztva a felhasználói felületet adó kódtól. Ez azonban sokszor nagyon nehéz,
mert a felhasználónak a legváltozatosabb helyeken próbálunk meg hozzáférést biztosítani a
program belsejéhez, hiszen épp az az egésznek a lényege, hogy adatokkal (inputtal) láthassa
el a programot, és láthassa a kimenetét (output).</p>

<p>Előkerült ez megoldandó problémaként magánál a mátrixnál is. A zenegép számára a mátrix
egy 16×16-os, logikai (igaz/hamis) értékekből álló tároló, amelynek minden eleme azt mutatja,
az adott időben meg kell-e szólaljon az adott magasságú hang. Választhatjuk azt a megoldást,
hogy a zenegép ezt a mátrixot tárolja:</p>

<pre class="brush: c "  >
typedef struct ZeneGep {
    Szinti *sz;
    double tempo;
    int fazis;
    int hang[FazisMax][16];       /* hang[fazis][magassag] */
} ZeneGep;</pre>

<p>Ekkor azonban gondban leszünk a zene „léptetésekor”. Bár a szintetizátornak jelezni tudjuk,
hogy mely hangoknak kell megszólalnia, a felhasználói felület felé már nem látunk ezeken az
adatokon keresztül: nem tudjuk animálni a gombokat, hogy azok egy felvillanással mutassák
a hang megszólalását, mivel nem látjuk a gombokat jelképező változókat. A programban szereplő,
megint csak egyszerű, de nem túl szép megoldás tehát a következő: tároljuk a zenegépet
jelképező struktúrában a gombok pointereit (azaz a felhasználói felület elemeit :(), mert
akkor mindent meg tudunk oldani:</p>

<pre class="brush: c "  >
typedef struct ZeneGep {
    Szinti *sz;
    double tempo;
    int fazis;
    Widget *gomb[16][16];       /* gomb[fazis][magassag] */
} ZeneGep;</pre>

<p>Lehetne erre szebb és általánosabb megoldást is találni, de az bonyolultabb lenne ennél.</p>

<p>A zene léptetése függvény így elég egyszerűvé válik. A zenegép fázisa egy 0 és 15 közötti
szám, amely az aktuális ütemet tárolja. A léptetésnél az előző ütem gombjainak villanását
ki kell kapcsolni, utána pedig a következőknél bekapcsolni az átszínezést, és persze elindítani
a hangot is:</p>

<pre class="brush: c "  >
/* ez a fuggveny &quot;lepteti&quot; a zenet, es allitja be az uj lejatszando
 * hangokat. az esemenyvezerelt mainbol fog meghivodni, az idozito
 * fuggveny altal betett sdl_userevent hatasara. */
void zene_leptet(SDL_Event *event, void *zgv) {
    ZeneGep *zg = (ZeneGep *) zgv;
    int y;

    /* elozo fazis */
    for (y = 0; y &lt; 16; ++y) {
        zg-&gt;gomb[zg-&gt;fazis][y]-&gt;adat.villanogomb.villan = 0;
        widget_ujrarajzol(zg-&gt;gomb[zg-&gt;fazis][y]);
    }
    /* uj fazis (leptetes) es villantas */
    zg-&gt;fazis = (zg-&gt;fazis + 1) % 16;
    for (y = 0; y &lt; 16; ++y) {
        zg-&gt;gomb[zg-&gt;fazis][y]-&gt;adat.villanogomb.villan = 1;
        widget_ujrarajzol(zg-&gt;gomb[zg-&gt;fazis][y]);
        if (zg-&gt;gomb[zg-&gt;fazis][y]-&gt;adat.villanogomb.allapot)
            zg-&gt;sz-&gt;hangok[y].indit = 1;
    }
}</pre>

<p>Ezt a függvényt kell meghívni adott időközönként egy időzítőből. Egy SDL-es időzítőben
viszont nem szabad kirajzolás függvényeket hívni (mert külön szálban fut, de erről majd
Szoftlab 3-on lesz szó), ezért ott a szokásos módon csak egy eseményt szúrunk be
a várakozási sorba:</p>

<pre class="brush: c "  >
enum { ZENET_LEPTET = SDL_USEREVENT + 2 };

Uint32 idozit(Uint32 ms, void* zgv) {
    ZeneGep *zg = (ZeneGep *) zgv;
    SDL_Event ev = { ZENET_LEPTET };
    SDL_PushEvent(&amp;ev);
    return 600 - zg-&gt;tempo*500;   /* ujabb varakozas (ms) */
}</pre>

<p>Ezáltal persze megint az <code>esemenyvezerelt_main()</code>-ben találjuk magunkat, hiszen
végül minden esemény az ottani eseményvezérelt hurokban köt ki. Most megint összefonódik
a felhasználói felület és a zenegép alkalmazásunk logikája: a felhasználói felületet kezelő
kódban kellene valami olyat elvégezni, ami a zenegéphez tartozik. Ilyennel már találkoztunk,
a tegnapi programban a billentyűk lenyomásakor kellett olyan feladatot elvégezni, ami nem
tartozott a felhasználói felülethez szorosan, hanem inkább a szintetizátor alkalmazáshoz.
Mivel látjuk, hogy ez a feladat gyakran előkerül, adjunk erre most egy általánosabb megoldást.
Ez a következő. A felhasználói felület működését biztosító <code>esemenyvezerelt_main()</code>
függvény számára be tudunk regisztrálni eseményeket, és hozzájuk tartozó függvényeket, az alábbi
függvény hívásával:</p>

<pre class="brush: c "  >
void callback_regisztral(SDL_EventType eventtype,
                         void (*callback_fv)(SDL_Event *, void *),
                         void *callback_fv_param);</pre>

<p>Ennek jelezzük, hogy <code>ZENET_LEPTET</code> típusú esemény keletkezésekor meg kell hívni
a <code>zenet_leptet()</code> függvényt, és átadni neki a zenegépet:</p>

<pre class="brush: c "  >
callback_regisztral(ZENET_LEPTET, zene_leptet, &amp;zg);</pre>

<p>Az események kezelésekor pedig az <code>esemenyvezerelt_main()</code> a saját dolgainak elvégzése
mellett megnézi azt is, regisztráltunk-e be hívandó függvényeket az egyes eseményekhez (billentyű megnyomás,
egér mozdulat stb.) Aztán ha igen, meghívja:</p>

<pre class="brush: c "  >
if (felhasznaloi_callback[i].callback_fv != NULL
    &amp;&amp; felhasznaloi_callback[i].eventtype == ev.type)
    felhasznaloi_callback[i].callback_fv(&amp;ev, felhasznaloi_callback[i].callback_fv_param);</pre>




</div>
</section>
<section id="4">
<div class="slide" id="slide_4">
<div class="slideheader">
<h2><span class="oldalszam">4</span>A forráskód</h2>
</div>

<p>A forráskód pedig: <a href="advent23-infoc_zenegep.zip">advent23-infoc_zenegep.zip</a>.
Linuxosoknak van benne egy Makefile. Akik Code::Blocksolnak, be kell tenniük egy SDL projektbe
(Project / Add files), az alap SDL projekt main.c-je helyett. A zip tartalmazza a forráskódot,
és egy példa fájlt.</p>
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="index.html@v=23.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="../index.html"><img src="../modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="../index.html">főoldal</a> · <a href="../elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
