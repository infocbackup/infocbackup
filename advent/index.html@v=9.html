<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Adventi naptár</title>
<meta property="og:title" content="InfoC :: Adventi naptár">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="InfoC :: Adventi naptár">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="InfoC :: Adventi naptár">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="../modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v10.css">
<script src="../modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="../index.html">InfoC</a></div>
<ul>
<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="../index.html">Kezdőlap</a>
<li><a href="../nhf.html">Nagy házi feladat</a>
<li><a href="../elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="../ea01.html">1. hét: bevezetés</a>
<li><a href="../ea02.html">2. hét: algoritmusok</a>
<li><a href="../ea03.html">3. hét: tételek, tömbök</a>
<li><a href="../ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="../ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="../ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../ea09.html">9. hét: láncolt listák</a>
<li><a href="../ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="../ea12.html">12. hét: bináris fák</a>
<li><a href="../ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="../ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="../gy02.html">2. hét: algoritmizálás</a>
<li><a href="../gy03.html">3. hét: egyszerű programok</a>
<li><a href="../gy04.html">4. hét: tételek és tömbök</a>
<li><a href="../gy05.html">5. hét: függvények</a>
<li><a href="../gy06.html">6. hét: származtatott típusok</a>
<li><a href="../gy07.html">7. hét: mutatók használata</a>
<li><a href="../gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="../gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="../gy11.html">11. hét: láncolt listák I.</a>
<li><a href="../gy12.html">12. hét: láncolt listák II.</a>
<li><a href="../gy13.html">13. hét: bináris fák</a>
<li><a href="../gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="../lab01.html">1. hét: operációs rendszer</a>
<li><a href="../lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="../lab03.html">3. hét: egyszerű programok</a>
<li><a href="../lab04.html">4. hét: tömbök</a>
<li><a href="../lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="../lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="../lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="../lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="../lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="../lab11.html">11. hét: láncolt listák</a>
<li><a href="../lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="../lab13.html">13. hét: bináris fák</a>
<li><a href="../lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="../f01.html">1. hét: egyszerű programok</a>
<li><a href="../f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="../f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="../f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="../f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="../f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="../f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="../f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="../f09.html">9. hét: láncolt listák</a>
<li><a href="../f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="../f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="../f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="../jegyzet.html">Jegyzet és puska</a>
<li><a href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="../stilus.html">Kódolási stílus</a>
<li><a href="../tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="../debugmalloc.html">Debugmalloc</a>
<li><a href="../mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="../nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="../nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="../nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="../orak.html">SVG óra galéria</a>
<li><a href="../angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="../turing.html">Mit tud a számítógép?</a>
<li><a href="../bf.html">BF</a>
<li><a href="../bitturmix.html">Bitturmix</a>
<li><a href="../labirintus.html">Labirintusok</a>
<li><a href="../tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="../karakterkodolas.html">Karakterkódolások</a>
<li><a href="../strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="../internet.html">Internet</a>
</ul>

<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="../sdl.html">SDL grafika</a>
<li><a href="../sdl_telepito.html">SDL telepítés</a>
<li><a href="../fa.html">Fák rajzolása</a>
<li><a href="../lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="index.html@v=9.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="../mondatelemzo.html">Mondatelemző</a>
<li><a href="../kifejezesek.html">Kifejezések</a>
<li><a href="../derivalas.html">Deriválás</a>
<li><a href="../ast_epit.html">AST: szintaxisfák</a>
<li><a href="../ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="../ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="../advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<div class="float" style="margin-top: 0.25em; margin-bottom: 0;"><a href="../advent.html">&larr; vissza</a></div>
<h1 class="eloadascim">Adventi naptár</h1>
<h2>Eszköztárak</h2>

<p>Írjunk SDL programot, amelyik kirajzol gombokat, csúszkákat 
és egy színes téglalapot! A csúszkákból legyen három darab. 
Ezekre kattintva lehessen beállítani a vörös, zöld, és kék 
színkomponenseket (RGB), amelyeknek megfelelő színű lesz a téglalap, 
miután az egyik gombra kattintott a felhasználó. A másik gombbal 
lehessen kilépni a programból.</p>

<blockquote>
<p>Ennek az írásnak nem célja, hogy objektumorientált programozás bevezető legyen.
Pár dolog elő fog azért kerülni, de inkább csak problémafelvetésként.
A megértéshez szükséges az előadáson bemutatott <code>union</code> és függvényre
mutató pointer témakörök ismerete.</p>
</blockquote>




<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="index.html@v=9.html#1">Widgetek</a>
<li><a href="index.html@v=9.html#2">A callbackek</a>
<li><a href="index.html@v=9.html#3">Fogjuk őket össze</a>
<li><a href="index.html@v=9.html#4">Eszköztárak</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>Widgetek</h2>
</div>
<img class="float" src="advent9-ablak.png">

<p>A grafikus felhasználói felületek elemeit angolul <em>widget</em>-nek szokták nevezni. Ezek 
egyrészt <em>különbözőek</em> működésükben: a csúszka aktívan reagál a kattintásra (megváltozik 
a tárolt érték), a színes téglalap nem csinál semmit. Másrészt <em>hasonlítanak is egymásra,</em>
abban, hogy van egy pozíciójuk és egy méretük a képernyőn. Bizonyos szempontból rokonok.

<p>A hasonlóságaik:
<ul>
    <li>Mindegyiknek van helye (x, y) és mérete (szélesség, magasság) a képernyőn.
    <li>Mindegyiknek van egy sötét színű kerete, és egy árnyékolt háttere.
    <li>Mindegyikről meg kell tudnia mondani a programnak, hogy arra kattintott-e a
        felhasználó.
</ul>

<p>A különbségek:
<ul>
    <li>A színes téglalap megjelenít egy színt, de nem reagál a kattintásra.
    <li>A csúszkák reagálnak a kattintásra, és mindegyik ugyanúgy működik.
    <li>A gombokon felirat van, de a feliratok különbözőek. Ugyancsak, a kattintás hatására
        eltérő dolog történik.
    <li>Gombokon kívül is lehetnek feliratok.
</ul>

<p><p>
Az előadáson szerepelt, hogy eltérő típusú adatokat tárolni ugyanazon az adatterületen
<code>union</code> segítségével lehet. Ez nagyon C-s. Valami ilyesmit csinálhatunk:

<pre class="brush: c "  >
/* egy widget, az altalanos es a specialis adatokkal */
typedef struct Widget Widget;
struct Widget {
    int x, y, szeles, magas;            /* pozicio es meret */
 
    enum WidgetTipus {                  /* ilyen típusú lehet */
        gomb, gorditosav, szinesteglalap, felirat
    } tipus;
    union {
        struct GombAdat {
            char felirat[20];           /* a gomb szövege */
        } gomb;
        struct GorditosavAdat {
            double jelenlegi;           /* erteke; 0.0-1.0 */
        } gorditosav;
        struct SzinesTeglalapAdat {
            unsigned char r, g, b;      /* szin */
        } szinesteglalap;
        struct FeliratAdat {
            char szoveg[20];
        } felirat;
    } adat;
};</pre>

<p>
A megadott típus alapján ki tudjuk választani, hogy egy bizonyos <code>Widget</code>
típusú struktúra milyen fajta adatait tárolja; és az alapján tudunk választani a
<code>union</code>-ben lévő adatok közül a megfelelő struktúrát. Ugyancsak, ha
megírjuk a különböző függvényeket, amelyek egy gombot, vagy egy csúszkát
rajzolnak ki a képernyőre, akkor ki tudjuk választani egy widgethez a megfelelőt.
Ehhez azonban minden egyes helyen, ahol rajzolást kell csinálni, egy <code>switch()</code>
kellene; ezt elkerülendő, inkább minden egyes elemben tároljunk el egy pointert is,
amely az elemnek a <em>saját</em> kirajzoló függvényére mutat. Vagyis legyen még
egy ilyen adattag is a struktúrában:

<pre class="brush: c "  >
void (*rajzolo_fv)(Widget *widget);</pre>


<p>Bár különfélék, a <code>union</code> használata miatt a <code>Widget</code> struktúra 
egységes C típus minden fajta elemhez. Ez azért jó, mert berakhatjuk ezeket az elemeket egy 
tömbbe (a tömb ugyebár egyforma típusú elemek tárolója); ha a felhasználó kattint egyet valahova 
(x, y koordináta), akkor a tömbben lévő összes elem mérete és pozíciója alapján el tudjuk 
dönteni, hogy konkrétan melyikre. Mivel ennek eldöntéséhez csak azt kell tudni, hogy melyik 
widget hol van az ablakban, azt nem, hogy mi az, az ezt kezelő programrész egységes lehet. Egy 
egyszerű <code>for()</code> ciklust kapunk! Bár a tömb számunkra eltérő típusú elemeket 
tartalmaz, a ciklus közösen tudja kezelni őket, a közös tulajdonságaik alapján.

<p>Nézzük meg a csúszkát közelebbről! Ha egy ilyenre kattint a felhasználó, akkor be tud állítani 
egy színkomponenst. Ha a bal szélére kattint, akkor minimális lesz, ha a jobb szélére, akkor 
maximális. Ezt egy 0 és 1 közötti <code>double</code> értékkel tárolható. Minden csúszka 
ugyanúgy viselkedik, és mindegyiknek a kattintás koordinátáit is kell tudnia (mert látniuk kell, 
melyik részük fölött volt az egérmutató). Írni kell tehát egy függvényt, amelyik egy csúszkán 
belüli kattintást dolgoz fel. Az <code>x</code> és <code>y</code> relatív koordináták, a csúszka bal 
felső sarkához képest:

<pre class="brush: c "  >
void csuszka_kattintas(Widget *csuszka, int x, int y) {
    csuszka-&gt;adat.csuszka.jelenlegi=(double) (x-1)/(csuszka-&gt;szeles);
    csuszka_rajzol(csuszka);
}</pre>

<p>A kirajzolása pedig így nézhet ki. Először meghívja a <code>widget_alap_rajzol()</code> 
függvényt, amelyik amúgy mindegyik típusra működik; ez rajzolja a keretet az adott widget köré, és a 
színátmenetet háttérnek. Ehhez azért van külön függvény, mert mindegyikre közös. Ha azt 
változtatjuk, így majd az összes widget egységesen vált kinézetet. A csúszka ezután kirajzolja 
a saját belsejét; ami egyszerűen egy színes csík:

<pre class="brush: c "  >
void csuszka_rajzol(Widget *csuszka) {
    widget_alap_rajzol(csuszka);
    boxColor(screen, csuszka-&gt;x, csuszka-&gt;y,
        csuszka-&gt;x+csuszka-&gt;szeles * csuszka-&gt;adat.csuszka.jelenlegi,
        csuszka-&gt;y+csuszka-&gt;magas-1, csuszkaszin);
}</pre>




</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>A callbackek</h2>
</div>

<p>Mi a helyzet a gombokkal? A gombok eltérő dolgot 
csinálnak; az egyikre kattintva a téglalap átszíneződik, a másik pedig bezárja a programot. Az 
viszont közös bennük, hogy a kattintás hatására történik valami, aminek amúgy nincs is köze a 
gomb belső lelkivilágához. Ezt egy függvényre mutató pointerrel lehet jól megoldani; az egyik 
gomb a téglalap átszínezéséhez tartozó függvényt kapja, a másik pedig egy olyan függvényt, 
amelyik befejezi a programot. Ezzel általánosíthatjuk egy gomb működését. Egy programban 
többféle gombot hozhatunk létre, amelyek mind mást csinálnak.

<p>Ami nagyon fontos, hogy így az egyes tevékenységekhez tartozó függvényeket nem kell beírnunk 
a grafikus programrészek (gomb rajzolása, egérkattintások kezelése stb.) közé. A dolgot tovább 
általánosíthatjuk, ha nem csak a gombokhoz rendelünk hozzá ilyen ún. <em>callback</em> függvényt 
(amelyre mutató pointert a grafikus modulnak adunk, és az kattintás esetén <em>visszahívja</em> 
azt), hanem észrevesszük, hogy bármelyik widgethez társítható ilyen. Létrehozhatunk ennek 
segítségével egy speciális, a többitől eltérő működésű csúszkát is, vagy olyan színes 
téglalapot, amely képes valami módon a kattintásokra reagálni. Például az egérgombot nyomva 
tartva rajzolni lehet rá. Ha nincs szükség callbackre, akkor pedig a függvénypointer 
<code>NULL</code> lehet, ezzel jelezzük a grafikus modulnak, hogy az a widget passzív.

<pre class="brush: c "  >
widgetek[0]=uj_gomb(216, 10, 50, 32, &quot;Kilép&quot;);
widgetek[0]-&gt;felhasznaloi_cb=kilep_gomb_cb;      /* programból kilépés */
widgetek[7]=uj_gomb(10, 170, 50, 32, &quot;Mehet&quot;);
widgetek[7]-&gt;felhasznaloi_cb=mehet_gomb_cb;      /* csúszkák alapján szín beállítása */</pre>

<p>Ennél is tovább általánosítható a dolog. Ha az alsó, Mehet feliratú gombra kattintunk, akkor 
a három csúszka aktuális értéke alapján állítódik be a téglalap színe. Az ezt végző függvénynek, 
amelyik a gomb callbackje, ismernie kell a három csúszkát és a téglalapot. Ezeket a callback 
paramétereként kell átvegye:

<pre class="brush: c "  >
typedef struct UIAdat {
    Widget *r, *g, *b, *teglalap;
} UIAdat;</pre>

<p>De ennek tartalmával foglalkozni nem a gomb dolga, hanem a gomb használójáé.
Hogy ne kössünk meg semmit a grafikus modul írásakor, az extra 
paraméter típusa, az előadáson bemutatott adatokhoz hasonlóan <code>void*</code> lehet. Egy 
<code>void*</code> mutatóval bármire rámutathatunk; ha egynél több paraméter kell, akkor azokat 
berakjuk egy struktúrába, és az arra mutató pointert veszi át a callback. A függvény belsejében 
ezt a típus nélküli pointert a saját típusra vissza kell majd alakítani; hasonlóan ahhoz, 
ahogyan egy <code>qsort()</code>-hoz való összehasonlító függvényben is kell. A widgetek 
általános tulajdonságaihoz ezért a lenti mezőket is hozzátesszük. (Az x és y koordináta azért 
szerepel itt is, hátha olyan callbacket akarunk írni, amelyik figyelembe veszi azt is. A gomb 
ebben a programban nem használja a kapott értékeket.)

<p>Észrevéve, hogy tulajdonképp a widget saját működését is ilyen függvényen keresztül
végezhetjük, végülis két függvénypointert teszünk minden widgetbe. Az egyik a
belső működését adja (pl. a csúszka állítható), a másik pedig a felhasználói felületben
a hozzá társított működés:</p>

<pre class="brush: c "  >
/* belso lelkivilag: ha a kattintasra kell valamit csinalni, pl. csuszka erteke */
void (*kattintas_fv)(Widget *widget, int x, int y);

/* kivulrol tarsitott mukodes, a beepitett mukodesen tul */
void (*felhasznaloi_cb)(Widget *widget, int x, int y, void *param);
void *felhasznaloi_cb_param;           /* ezt a parametert megkapja a param valtozoban */</pre>




</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>Fogjuk őket össze</h2>
</div>
<p>
Az előbb már szó esett róla, hogy a widgetek egy tömbbe kerülnek. A tömb a programban
pointereket tartalmaz; az egyes widgeteket dinamikusan lehet foglalni le. Minden típushoz
tartozik egy külön függvény; a függvény végzi a memóriafoglalást, és a paraméterek
alapján a tulajdonságok beállítását. A csúszka példája lent látható.
Az <code>uj_widget()</code> függvény feladata
a memória foglalása, és a méretek beállítása; ezt mindegyik típusnál meg kell
csinálni, ezért külön függvény lett belőle. A többi paramétert egyszerűen be kell másolni. 

<pre class="brush: c "  >
Widget *uj_csuszka(int x, int y, int szeles, int magas, double kezdeti) {
    Widget *uj=uj_widget(x, y, szeles, magas);
    uj-&gt;tipus=csuszka;
    uj-&gt;rajzolo_fv=csuszka_rajzol;        /* ezzel rajzolodik ki */
    uj-&gt;kattintas_fv=csuszka_kattintas;   /* a sajat, belso mukodese */
    uj-&gt;adat.csuszka.jelenlegi=kezdeti;
    return uj;
}</pre>

<p>Az eseményhurok megkapja a felhasználótól érkező kattintásokat. Az SDL a kattintások adatai 
mellé megadja a koordinátát. Így könnyű megkeresni azt a widgetet, amelyiknek a területén 
éppen az egérmutató volt abban a pillanatban. A widget típusától függően ilyenkor elindulhat egy 
beépített függvény (ez a helyzet a csúszkák esetén), és ha van, lefut egy külön megadott 
callback (ez pedig a gombok esetén). Mivel ezek hatására a widgetek esetleg megváltozhattak, az 
újrarajzolás miatt meghívja az <code>SDL_Flip()</code> függvényt.

<p>A <code>main()</code> függvényben létrejönnek az egyes widgetek. Az átszínező gombhoz a 
fentiek alapján egy struktúrába kerülnek be a kezelt widgetekre mutató pointerek. Miután minden 
kész, az <code>esemenyvezerelt_main()</code> függvény indul el; és onnantól kezdve a program 
mindent a felhasználói input alapján csinál. A bejövő eseményeknél meghatározza, hogy melyik 
widgetnek szólnak. A widgetek callbackjai, egészen pontosan az alsó gombé pedig a fent leírt 
feladatot valósítja meg: hogy a beállított színkomponensek alapján a kattintás hatására a 
téglalapnak új színt ad. Ennek lelke az <code>mehet_gomb_cb()</code> függvény; a program többi 
része a felület elemeinek leprogramozása.

<p>A programból kilépő gomb hatására az eseményhuroknak (a <code>while</code> ciklus) be kell 
fejeződnie. Ez úgy is megoldható, hogy a hozzá tartozó callback egy <code>SDL_QUIT</code> típusú 
eseményt rak az SDL esemény várakozási sorának végére. Így pontosan ugyanaz lesz a hatása, mint 
az ablak bezárásának. Persze más megoldást is el lehet képzelni erre.



</div>
</section>
<section id="4">
<div class="slide" id="slide_4">
<div class="slideheader">
<h2><span class="oldalszam">4</span>Eszköztárak</h2>
</div>

<p>A program forráskódja pedig letölthető innen:
<a href="advent9-widget.c">advent9-widget.c</a>. Az SDL-es program fordításához az extrák menüpont alatt segítség.

<p>Senkinek nem ajánlom, hogy maga kezdjen toolkitet, vagyis eszköztárat kódolni. Ez az írás 
azért született, hogy bemutassa, egy ilyen nagyjából hogy működik belülről, illetve néhány 
általános problémára és megoldási lehetőségre rávilágítson. Több platformfüggetlen eszközkészlet 
is létezik. Ha nincs megkötve, érdemes ezek közül választani, hiszen a platformfüggetlenség nagy 
előny bármely program számára. Néhány ismertebb:

<ul>
    <li>GTK+: Linuxból származik, C-ben íródott. Néhány ötletet ehhez a programhoz a GTK+-ból
        vettem. Működik Windowson, Linuxon és Macen is.
    <li>wxWidgets: C++-os. Érdekessége, hogy minden operációs rendszeren a natív widgeteket
        használja – vagyis nem maga rajzolgatja ki azokat. Így minden operációs
        rendszeren a vele írt programok úgy néznek ki, mint a másik ottani programok.
        A Code::Blocks ezzel készült.
    <li>Qt: a KDE alapja, ez is C++-ban íródott.
</ul>

<p>Viszont ez a toolkit még elő fog kerülni az adventi naptárban, egy későbbi napon.
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="index.html@v=9.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="../index.html"><img src="../modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="../index.html">főoldal</a> · <a href="../elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
