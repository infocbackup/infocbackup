<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Debugmalloc</title>
<meta property="og:title" content="InfoC :: Debugmalloc">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="A debugmalloc varázsmalloc(), amely képes kilistázni a felszabadítatlan területeket, és ezzel megkönnyíti a hibakeresést. Bizonyos határok között a túlindexelést is tudja ellenőrizni.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="A debugmalloc varázsmalloc(), amely képes kilistázni a felszabadítatlan területeket, és ezzel megkönnyíti a hibakeresést. Bizonyos határok között a túlindexelést is tudja ellenőrizni.">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="modulz/logo_touch.png">
<link rel="image_src" href="modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="modulz/style/localfonts.css@v10.css">
<script src="modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="index.html">InfoC</a></div>
<ul>
<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="index.html">Kezdőlap</a>
<li><a href="nhf.html">Nagy házi feladat</a>
<li><a href="elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="ea01.html">1. hét: bevezetés</a>
<li><a href="ea02.html">2. hét: algoritmusok</a>
<li><a href="ea03.html">3. hét: tételek, tömbök</a>
<li><a href="ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="ea09.html">9. hét: láncolt listák</a>
<li><a href="ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="ea12.html">12. hét: bináris fák</a>
<li><a href="ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="gy02.html">2. hét: algoritmizálás</a>
<li><a href="gy03.html">3. hét: egyszerű programok</a>
<li><a href="gy04.html">4. hét: tételek és tömbök</a>
<li><a href="gy05.html">5. hét: függvények</a>
<li><a href="gy06.html">6. hét: származtatott típusok</a>
<li><a href="gy07.html">7. hét: mutatók használata</a>
<li><a href="gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="gy11.html">11. hét: láncolt listák I.</a>
<li><a href="gy12.html">12. hét: láncolt listák II.</a>
<li><a href="gy13.html">13. hét: bináris fák</a>
<li><a href="gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="lab01.html">1. hét: operációs rendszer</a>
<li><a href="lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="lab03.html">3. hét: egyszerű programok</a>
<li><a href="lab04.html">4. hét: tömbök</a>
<li><a href="lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="lab11.html">11. hét: láncolt listák</a>
<li><a href="lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="lab13.html">13. hét: bináris fák</a>
<li><a href="lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="f01.html">1. hét: egyszerű programok</a>
<li><a href="f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="f09.html">9. hét: láncolt listák</a>
<li><a href="f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="jegyzet.html">Jegyzet és puska</a>
<li><a href="fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="stilus.html">Kódolási stílus</a>
<li><a href="tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="debugmalloc.html">Debugmalloc</a>
<li><a href="mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="orak.html">SVG óra galéria</a>
<li><a href="angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="turing.html">Mit tud a számítógép?</a>
<li><a href="bf.html">BF</a>
<li><a href="bitturmix.html">Bitturmix</a>
<li><a href="labirintus.html">Labirintusok</a>
<li><a href="tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="karakterkodolas.html">Karakterkódolások</a>
<li><a href="strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="internet.html">Internet</a>
</ul>

<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="sdl.html">SDL grafika</a>
<li><a href="sdl_telepito.html">SDL telepítés</a>
<li><a href="fa.html">Fák rajzolása</a>
<li><a href="lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="debugmalloc.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="mondatelemzo.html">Mondatelemző</a>
<li><a href="kifejezesek.html">Kifejezések</a>
<li><a href="derivalas.html">Deriválás</a>
<li><a href="ast_epit.html">AST: szintaxisfák</a>
<li><a href="ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<h1 class="eloadascim">Debugmalloc</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán · <i class="ido"></i> 2015.02.18 · Frissítve: 2015.02.15</p>
<p class="kivonat">A debugmalloc varázsmalloc(), amely képes kilistázni a felszabadítatlan területeket, és ezzel megkönnyíti a hibakeresést. Bizonyos határok között a túlindexelést is tudja ellenőrizni.</p>
</div>

<p>Ez a függvénykönyvtár egy okos <code>malloc()</code>-<code>free()</code> 
függvénypárost ad a használójának. A nagyházi teszteléséhez hasznos, a 
memóriakezelési hibák megtalálásának könnyítésére.</p>

<p>
A függvénykönyvtár a következő szolgáltatásokat nyújtja:
</p>
<ul>
    <li>Képes arra, hogy a program futásának a végén kilistázza a felszabadítatlan területeket.
        Vagyis meg lehet vele találni a memóriaszivárgásokat.
    <li>Nyilvántartja, hogy az egyes memóriafoglalások hol, melyik forrás fájlban, és
        melyik sorban történtek.
    <li>Képes megtalálni az olyan <code>free()</code> hívásokat, amelyek le nem foglalt
    memóriaterületre, vagy <code>NULL</code> pointerre hivatkoznak.
    <li>Képes érzékelni és jelezni a tömbök túlindexelését (bizonyos keretek közt).
    <li>Segít megtalálni az inicializálatlan változókat.
    <li>A hibaüzeneteket a képernyőre, vagy egy megadott fájlba tudja írni.
</ul>

<p>(A belső megvalósítása használ olyan nyelvi elemeket, amelyek a dinamikus 
tömböket bemutató előadáson még nem szerepeltek. Ezeket azonban nem kell érteni a 
használathoz. A listás és a generikus algoritmusokat bemutató előadásokon 
egyébként azok az elemek is szerepelni fognak.)</p>


<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="debugmalloc.html#1">A függvénykönyvtár használata</a>
<li><a href="debugmalloc.html#2">A függvénykönyvtár szolgáltatásai</a>
<li><a href="debugmalloc.html#3">Tömbök túlindexelése – a kanárik</a>
<li><a href="debugmalloc.html#4">Példaprogram</a>
<li><a href="debugmalloc.html#5">A függvénykönyvtár belső működése</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>A függvénykönyvtár használata</h2>
</div>
<p>
A könyvtár két fájlból áll, ezek a <a href="debugmalloc/debugmalloc.c">debugmalloc.c</a>
forrás fájl és a <a href="debugmalloc/debugmalloc.h">debugmalloc.h</a> header fájl.
Mind a kettőt le kell tölteni, és a megfelelő módon a projekthez hozzáadni.
</p>
<p>A header fájl két makrót ad meg, amelyek a szokásos <code>malloc()</code> és 
<code>free()</code> függvényeket helyettesítik. Ezt a header fájlt az adott 
projekt <em>minden forrás fájljába be kell szerkeszteni</em>, vagyis a saját, 
tesztelt program minden <code>.c</code> fájljának elején szerepelnie kell ennek a 
sornak:</p>
<pre class="brush: c "  >
#include &quot;debugmalloc.h&quot;</pre>

<p>
Fontos, hogy a fenti <code>#include</code> sor <em>minden</em> <code>.c</code> fájlba bekerüljön.
Ellenkező esetben nem fog helyesen működni a tesztelés!
</p>

<p>A másik fájllal nem kell foglalkozni, csak a projektbe fel kell venni. A 
tesztelendő program kódjában ezen kívül semmilyen más módosítást nem kell végezni 
a használathoz! A memóriaterületek dinamikus foglalása a szokásos módon kell 
történjen: a <code>malloc(size_t)</code> hívás foglal, és a
<code>free(void&nbsp;*)</code> hívás szabadít fel egy területet.
A <code>calloc()</code> és <code> realloc()</code> hívások is működnek, de azok, 
mint az közismert, ellenjavaltak.</p>

<div class="sticky">SDL-hez</div>
<p>
A debugmalloc a hibaüzeneteket a szabványos hibakimenetre (stderr) írja.
A <code>debugmalloc_naplofajl("fajlnev.txt");</code> függvényhívással ezek
egy megadott nevű fájlba irányíthatóak át. Windows-on, SDL-es programoknál ezt a
megoldást érdemes választani (mert az SDL átirányítja a szabványos kimenetet),
vagy az <a href="sdl.html">SDL-es oldalon</a> bemutatott
<code>freopen()</code>-es trükköt.
</p>

<p>A debugmalloc nem túl gyors. Ha több ezer vagy tízezer darab lefoglalt memóriaterület
van, akkor eléggé le tudja lassítani a tesztelt program működését. Egy
nagyházi méretű projektnél azonban ennyi <code>malloc()</code>-olt terület lehet,
tervezési hibára utal.</p>


</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>A függvénykönyvtár szolgáltatásai</h2>
</div>
<p>
A <code>malloc()</code> függvény a lefoglalt memóriát nem inicializálatlanul
adja, hanem véletlenszámokkal tölti ki. Ezzel könnyebbé válik az inicializálatlan
változók okozta hibák kiszűrése (legalábbis a dinamikusan foglalt elemek,
tömbök esetében), mert a program működése határozottan nemdeterminisztikussá válik.
</p>
<p>
A lefoglalt területekről bármikor lista kérhető a <code>debugmalloc_dump()</code>
függvényhívással. Az üzenetek alapértelmezés szerint a szabványos hibakimenetre kerülnek,
de fájlba is írhatóak. A nevét például egy
<code>debugmalloc_naplofajl("memlog.txt")</code> hívással lehet megadni.
</p>
<p>
Az újraírt <code>free()</code> függvény ellenőrzi a hibás felszabadításokat, és
ezeknél megszakítja a programot egy <code>abort()</code>
hívással. Így egy nyomkövetőben (debugger) látszik az is, hogy hogyan jutott a végrehajtás
a hibás részhez.
</p>
<p>
A programból kilépéskor, ha maradtak felszabadítatlan
memóriaterületek, azokról lista készül. Egy felszabadítatlan tétel részletezése
így néz ki:
</p>
<pre class="screenshot">
MEMORIATERULET: 0x25bf090, kanari: ok
  foglalva itt: proba.c:27
  meret megadasa: 100*sizeof(char) (100 bajt)
  memoria eleje: 
    0000  48 65 6c 6c 6f 2c 20 76 69 6c 61 67 21 00 02 75   Hello, vilag!..u
    0010  33 ba ca 24 87 35 2d ad 78 cb 69 50 c0 fb 80 8d   3..$.5-.x.iP....
    0020  65 45 ef e4 61 28 39 14 78 a6 1f a0 eb c0 de 46   eE..a(9.x......F
    0030  b7 74 79 07 df c1 6d 62 e0 28 3a 96 fb ab a6 a8   .ty...mb.(:.....
</pre>
<p>
Az első sorban látható a pointer értéke (0x25bf090). A második sorban az, hogy az adott memóriaterület
a <em>proba.c</em> fájl 27. sorában lett lefoglalva. A mérete a <code>100*sizeof(char)</code>
kifejezéssel lett megadva, amely 100 bájtra értékelődött ki a program futása közben.
Ezen kívül pedig látható a lefoglalt memóriaterület eleje. A lefoglalt területre itt
a <em>Hello, vilag!</em> szöveget másoltam – megfigyelhető a lezáró nulla is, és az
utána lévő, generált memóriaszemét. A memória tartalma segíthet beazonosítani, hogy az adott
memóriaterület mi célt szolgált a programban, és így következtetni arra, hogy mikor
és hol kellett volna felszabadítani azt.
</p>

<p>
Végezetül pedig, ha a program hibátlanul működik, akkor csak el kell távolítani a fenti
<code>#include</code> sort a forrás fájlokból, és automatikusan újra a beépített,
szabványos memóriakezelés veszi át a debugmalloc helyét.
</p>


</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>Tömbök túlindexelése – a kanárik</h2>
</div>

<p>
A függvénykönyvtár támogatja a túlindexeléses hibák megtalálását. Ezt úgy éri el, hogy
minden egyes memóriafoglalásnál egy kicsit nagyobb területet kér az operációs rendszertől,
mint amekkora a programban igényelve lett; előtte és utána 128 bájtot hagy rá.
Ezeket a plusz területeket kanárinak hívják.
</p>


<table class="tomb">
<tr>
<td>kanári<br>128 bájt
<td>A malloc() hívásnál megadott<br>méretű memóriaterület
<td>kanári<br>128 bájt
</table>

<p>
A plusz területeket egy megadott karakterrel, a <code>K</code> betűvel 
tölti ki foglaláskor. Ha a lefoglalt terület például egy tömb, és írásnál 
túlindexelés történik, akkor az a <code>K</code> betűket fogja 
felülírni. A felszabadításnál, a <code>free()</code> hívásakor
ellenőrzi, hogy a <code>K</code> betűk megmaradtak-e. Ha nem, kiírja
a memóriatartalom elejét, és a kanárik teljes tartalmát.
Egy sérült kanári így néz ki:
</p>

<pre class="screenshot">
0000  4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b   KKKKKKKKKKKKKKKK
0010  4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b   KKKKKKKKKKKKKKKK
0020  4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b   KKKKKKKKKKKKKKKK
0030  4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b   KKKKKKKKKKKKKKKK
0040  4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b   KKKKKKKKKKKKKKKK
0050  4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b   KKKKKKKKKKKKKKKK
0060  4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b 4b   KKKKKKKKKKKKKKKK
0070  4b 4b 4b 4b 78 56 34 12 4b 4b 4b 4b 4b 4b 4b 4b   KKKKxV4.KKKKKKKK
</pre>

<p class="megjegyzes">
Kanári madarakat még a 20. században is
<a href="http://en.wikipedia.org/wiki/Canary_in_a_coal_mine#Canaries_in_coal_mines">alkalmaztak bányákban</a>,
mivel érzékenyebbek bizonyos mérgező gázokra, mint az
ember. <a href="http://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries">Innen ered</a> a programozásban is ez az elnevezés.
</p>




</div>
</section>
<section id="4">
<div class="slide" id="slide_4">
<div class="slideheader">
<h2><span class="oldalszam">4</span>Példaprogram</h2>
</div>

<pre class="brush: c "  >
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &quot;debugmalloc.h&quot;

int main(void) {
    int *adat;
    char *szoveg;
    
    /* itt minden rendben van. */
    adat = (int *) calloc(8, sizeof(int));
    adat[0] = 0x12345678;
    printf(&quot;\n\nMost egy memoriaterulet van lefoglalva:\n&quot;);
    debugmalloc_dump();
    adat = (int *) realloc(adat, 16*sizeof(int));
    printf(&quot;\n\nMost atmereteztem:\n&quot;);
    debugmalloc_dump();
    free(adat);
    printf(&quot;\n\nMost egy sem:\n&quot;);
    debugmalloc_dump();
    
    /* itt egy tulindexeles */
    adat = (int *) malloc(32*sizeof(int));
    adat[-3]=0x12345678;     /* tulindexeles */
    printf(&quot;\n\nEz uj memoria. Felszabaditom, de tulindexeltem, ezert szol:\n&quot;);
    free(adat);
    
    /* ez pedig egy memoriaszivargas... */
    szoveg = malloc(100*sizeof(char));
    strcpy(szoveg, &quot;Hello, vilag!&quot;);
    /* ... amit a program vegere irt dumppal latunk majd. */
    return 0;
}</pre>

</div>
</section>
<section id="5">
<div class="slide" id="slide_5">
<div class="slideheader">
<h2><span class="oldalszam">5</span>A függvénykönyvtár belső működése</h2>
</div>

<p>
A függvénykönyvtár <code>malloc()</code> hívása végül a beépített, gyári
<code>malloc()</code> függvényt hívja meg. A kanárik hozzáadásán, és
a véletlenszámokkal kitöltésen kívül a lefoglalt területek adatait egy
láncolt listában is rögzíti; így tudja ellenőrizni a felszabadítások
helyességét.
</p>
<p>
A belső, foglalást végző függvény fejléce, és az azt használó makró
a következő:
</p>
<pre class="brush: c "  >
void *debugmalloc_malloc_full(size_t size, char const *fv, char const *cel, char const *file, unsigned line);
#define malloc(X) debugmalloc_malloc_full(X, &quot;malloc&quot;, #X, __FILE__, __LINE__)</pre>
<p>
Ez első paraméterként megkapja <code>X</code>-et, vagyis a lefoglalandó memóriaterület
méretét. Második paramétere az <code>X</code> kifejezés sztringgé alakítva (<code>#X</code>).
Ez teszi lehetővé azt, hogy a kifejezést magát is rögzítse a debugmalloc, ahogyan
az a forráskódban látható (pl. <code>100*sizeof(int)</code>). A harmadik és negyedik
paraméter pedig a fordító beépített makrói, amelyek a forrás fájl nevére és az
adott sor számára helyettesítődnek be végül.
</p>
<p>
Ennek a függvénynek a fejléce inkompatibilis a beépített <code>malloc()</code> hívással.
Ha a tesztelt programban szükség van a prototípus kompatibilitására (például a malloc és
a free típushelyes függvénypointerére), akkor a fejlécfájl beillesztése előtt definiálni kell
a <code>HASZNALOM_A_MALLOC_FREE_POINTERET</code> makrót. Ilyenkor a fenti függvény
utolsó három paramétere alapértelmezett értéket kap mindig, vagyis a forrás fájl
nevének, sorának, és a méretet megadó kifejezésnek a rögzítése, mint szolgáltatás,
nem elérhető.
</p>
<p>
A láncolt lista, amelyet a program épít, az egyszerűség kedvéért mindkét végén strázsás.
Érdekessége, hogy a strázsákat nem dinamikusan foglalja le a program. Ha minden
<code>malloc()</code>-olt memóriaterületet felszabadít a tesztelt program, akkor egyáltalán nem marad
dinamikusan foglalt terület, hiszen a strázsák a globális változók területén vannak.
Vagyis a debugmalloc maga nem csinál memóriaszivárgást :).
Az inicializálatlan listát a program onnan ismeri meg, hogy a fejét megadó
pointer még NULL. Az első híváskor létrehozza azt; és ezen felül az <code>atexit()</code>
függvény hívásával arra kéri a futtató környezet, hogy a programból kilépéskor hívja meg
a felszabadítatlan területek listázását végző függvényt.
</p>
<p>
A könyvtár tartalmaz egy saját véletlenszám-generátort. Erre azért van szükség,
hogy ne a beépített <code>rand()</code> függvényt használja. Mivel a <code>rand()</code>
függvénynek belső állapota van, az megzavarhatná a tesztelt program
működését.
</p>
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="debugmalloc.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="index.html"><img src="modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="index.html">főoldal</a> · <a href="elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
