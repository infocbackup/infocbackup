<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: 3. hét: logika, sorozatok, tömbök</title>
<meta property="og:title" content="InfoC :: 3. hét: logika, sorozatok, tömbök">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="Gyakorlófeladatok a 3. előadás anyagához kapcsolódóan.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="Gyakorlófeladatok a 3. előadás anyagához kapcsolódóan.">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="modulz/logo_touch.png">
<link rel="image_src" href="modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<script>infoc.onloads.push(function(){ h3toid(); });
</script>
<link rel="stylesheet" href="modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="modulz/style/localfonts.css@v10.css">
<style type="text/css">div.kartyak span {
    font-size: 3em;
    background: #fff;
    border: 2px solid #000;
    border-radius: 0.3em;
    padding: 0 0.25em;
    box-shadow: 1px 1px 3px #888;
}
span.mastermind {
   font-weight: bold;
   font-size: 2em;
   letter-spacing: 0.1em;
   line-height: 0;
   text-shadow: 0px 0px 2px black;
}
</style>
<script src="modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="index.html">InfoC</a></div>
<ul>
<li class="al "><a href="f03.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="index.html">Kezdőlap</a>
<li><a href="nhf.html">Nagy házi feladat</a>
<li><a href="elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="f03.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="f03.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="ea01.html">1. hét: bevezetés</a>
<li><a href="ea02.html">2. hét: algoritmusok</a>
<li><a href="ea03.html">3. hét: tételek, tömbök</a>
<li><a href="ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="ea09.html">9. hét: láncolt listák</a>
<li><a href="ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="ea12.html">12. hét: bináris fák</a>
<li><a href="ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="f03.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="gy02.html">2. hét: algoritmizálás</a>
<li><a href="gy03.html">3. hét: egyszerű programok</a>
<li><a href="gy04.html">4. hét: tételek és tömbök</a>
<li><a href="gy05.html">5. hét: függvények</a>
<li><a href="gy06.html">6. hét: származtatott típusok</a>
<li><a href="gy07.html">7. hét: mutatók használata</a>
<li><a href="gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="gy11.html">11. hét: láncolt listák I.</a>
<li><a href="gy12.html">12. hét: láncolt listák II.</a>
<li><a href="gy13.html">13. hét: bináris fák</a>
<li><a href="gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="f03.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="lab01.html">1. hét: operációs rendszer</a>
<li><a href="lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="lab03.html">3. hét: egyszerű programok</a>
<li><a href="lab04.html">4. hét: tömbök</a>
<li><a href="lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="lab11.html">11. hét: láncolt listák</a>
<li><a href="lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="lab13.html">13. hét: bináris fák</a>
<li><a href="lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="f03.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="f01.html">1. hét: egyszerű programok</a>
<li><a href="f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="f09.html">9. hét: láncolt listák</a>
<li><a href="f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="f03.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="jegyzet.html">Jegyzet és puska</a>
<li><a href="fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="stilus.html">Kódolási stílus</a>
<li><a href="tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="debugmalloc.html">Debugmalloc</a>
<li><a href="mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="f03.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="f03.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="orak.html">SVG óra galéria</a>
<li><a href="angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="f03.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="turing.html">Mit tud a számítógép?</a>
<li><a href="bf.html">BF</a>
<li><a href="bitturmix.html">Bitturmix</a>
<li><a href="labirintus.html">Labirintusok</a>
<li><a href="tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="f03.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="karakterkodolas.html">Karakterkódolások</a>
<li><a href="strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="internet.html">Internet</a>
</ul>

<li class="al "><a href="f03.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="sdl.html">SDL grafika</a>
<li><a href="sdl_telepito.html">SDL telepítés</a>
<li><a href="fa.html">Fák rajzolása</a>
<li><a href="lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="f03.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="mondatelemzo.html">Mondatelemző</a>
<li><a href="kifejezesek.html">Kifejezések</a>
<li><a href="derivalas.html">Deriválás</a>
<li><a href="ast_epit.html">AST: szintaxisfák</a>
<li><a href="ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<a id="feladattomb" class="namer"></a>
<h1 class="eloadascim">3. hét: logika, sorozatok, tömbök</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán, Nagy Gergely, Pohl László · <i class="ido"></i> 2015.02.18</p>
<p class="kivonat">Gyakorlófeladatok a 3. előadás anyagához kapcsolódóan.</p>
</div>


<p>Ezen az oldalon rengeteg feladat található a gyakorláshoz. Egy részük megoldással együtt, míg 
a többi anélkül. A gyakorlófeladatok megoldásához elvileg elegendő az az ismeretanyag, amely az előadáson 
szerepelt. Természetesen a megoldás kitalálásához szükség lehet arra a rálátásra és 
tapasztalatra, amit a gyakorlatok és a laborok adnak. A feladatok témakörök szerinti 
csoportosítása viszont ettől függetlenül az előadást követi.</p>

<p>Felhívjuk a figyelmed arra, hogy a megoldások olvasgatása lényegében nulla 
tapasztalatot és gyakorlatot ad, így az eredményes számonkérésekhez nem tud hozzásegíteni! A 
megoldásokat akkor nézd csak meg, ha a saját megoldás elkészítése közben elakadsz.
Lásd <a href="tanacsok.html">itt</a>.</p>



<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="f03.html#1">Boole-algebra</a>
<li><a href="f03.html#2">Logikai kifejezések programokban</a>
<li><a href="f03.html#3">Sorozatok beolvasása</a>
<li><a href="f03.html#4">Programozási tételek</a>
<li><a href="f03.html#5">Tömbök</a>
<li><a href="f03.html#6">Véletlenszámok, játékok</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>Boole-algebra</h2>
</div>

<h3>Szendvicsek</h3>
<p>Egy büfében az alábbi szabályokat használják a jó szendvicsek készítéséhez:</p>
<ol>
    <li>Egy szendvicsben legyen legalább egy fajta hús,
    <li>Egy szendvicsben legyen marha vagy sonka, de együtt ne,
    <li>Ha a szendvicsben van pulykahús, akkor legyen benne sajt is.
</ol>

<p>Írj C logikai kifejezést, amely a jó szendvicseknél értékelődik ki igaz 
értékre, amúgy pedig hamisra! A változók: <code>sajt</code>, ha van benne sajt, 
<code>pulyka</code>, ha van benne pulyka, <code>marha</code> és <code>sonka</code>.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Az egyes szabályok megfelelői:</p>
<ol>
    <li><code>marha || sonka || pulyka</code>,
    <li><code>(marha &amp;&amp; !sonka) || (!marha &amp;&amp; sonka)</code>,
        ami egyébként <code>marha &oplus; sonka</code> XOR kapcsolatnak felel meg,
    <li><code>!pulyka || sajt</code>,
        mert ha nincs benne <code>pulyka</code>, akkor mindegy, van-e sajt,
        viszont ha van benne <code>pulyka</code> (tehát <code>!pulyka</code> hamis), akkor muszáj lennie
        benne sajtnak.
</ol>
<p>Tehát a végleges szabály:<br>
<code>(marha || sonka || pulyka) &amp;&amp; ((marha &amp;&amp; !sonka) || (!marha &amp;&amp; sonka)) &amp;&amp; (!pulyka || sajt)</code></p>
</div>
</div>

<h3>Almás pite</h3>
<p>Egy almás pite receptben az alábbi útmutatásokat találjuk:</p>
<ol>
    <li>Ne használjunk egyszerre szegfűborsot és szerecsendiót,
    <li>akkor és csak akkor használjunk szerecsendiót, ha a pitébe tettünk fahéjat.
</ol>
<p>Írj fel egy C logikai kifejezést a <code>szegfubors</code>, <code>szerecsendio</code>
és <code>fahej</code> változókkal, amely akkor értékelődik ki igazra, ha a recept
utasításait a készítő betartotta!</p>
<p>Töltsd ki egy igazságtáblát is, amely külön mutatja, hogy az első, illetve a második
útmutatás teljesül-e egy adott fűszerkombinációra! Ellenőrizd a tábla alapján a kifejezéseid!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Az egyes szabályok:</p>
<ol>
    <li><code>!(szegfubors &amp;&amp; szerecsendio)</code>,
        ez épp akkor lesz hamis, ha mindkét változó igaz (ha egyszerre használnánk őket),
    <li><code>(szerecsendio &amp;&amp; fahej) || (!szerecsendio &amp;&amp; !fahej)</code>,
        mert az is jó, ha mindkettő van, és az is, ha egyik sem: „akkor és csak akkor”.
</ol>
<p>A végleges szabály:<br>
<code>!(szegfubors &amp;&amp; szerecsendio) && ((szerecsendio &amp;&amp; fahej) || (!szerecsendio &amp;&amp; !fahej))</code>
</p>
</div>
</div>

<h3>Pizzák</h3>
<img src="f03/pizza.svg" class="float" style="width: 12em;">
<p>Alex, Beth és Chris szeretnének egy óriáspizzát rendelni, méghozzá olyat, amelyből mind a hárman
szívesen esznek. Ezeket a kijelentéseket tehetjük:</p>
<ul>
    <li>Alex az olivabogyós pizzát csak akkor eszi meg, ha pepperoni is van rajta,
    <li>Beth viszont a pepperonis pizzát csak sonka nélkül eszi meg,
    <li>Chris pedig csak olyan pizzát hajlandó enni, amin pontosan kétféle feltét van.
</ul>

<p>Használd a következő változókat: <code>p</code> IGAZ értékű, ha a pizzán van
pepperoni, <code>s</code> akkor IGAZ, ha van rajta sonka és <code>o</code> akkor IGAZ, ha van rajta
olivabogyó! Írj egy C logikai kifejezést, amely akkor és csak akkor igaz, ha a pizza mindhármuk
számára megfelelő! Rajzold fel az igazságtáblát, amely külön mutatja mindhármuk preferenciáit,
és egy oszlopban azt is, hogy az adott pizza megfelelő-e! Meg tudnak egyezni? Lehet egyszerűsíteni
a felírt képletet?</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Alex: <code>(!o &amp;&amp; !p) || (o &amp;&amp; p)</code>,<br>
Beth: <code>p &amp;&amp; !s</code>,<br>
Chris: <code>(p &amp;&amp; s &amp;&amp; !o) || (p &amp;&amp; !s &amp;&amp; o) || (!p &amp;&amp; s &amp;&amp; o)</code>.<br>
Kombinálva: <code>((!o &amp;&amp; !p) || (o &amp;&amp; p)) &amp;&amp; (p &amp;&amp; !s) &amp;&amp;
((p &amp;&amp; s &amp;&amp; !o) || (p &amp;&amp; !s &amp;&amp; o) || (!p &amp;&amp; s &amp;&amp; o))</code>.<br>
Egyszerűsítve (az igazságtábla alapján is ellenőrizhető): <code>p &amp;&amp; !s &amp;&amp; o</code>.</p>
<table>
    <thead>
        <tr><th>p<th>s<th>o<th>Alex<th>Beth<th>Chris<th>mindenki
    </thead>
    <tr><th>0<th>0<th>0<td>1<td>0<td>0<td>0
    <tr><th>0<th>0<th>1<td>0<td>0<td>0<td>0
    <tr><th>0<th>1<th>0<td>1<td>0<td>0<td>0
    <tr><th>0<th>1<th>1<td>0<td>0<td>1<td>0
    <tr><th>1<th>0<th>0<td>0<td>1<td>0<td>0
    <tr><th>1<th>0<th>1<td>1<td>1<td>1<td>1
    <tr><th>1<th>1<th>0<td>0<td>0<td>1<td>0
    <tr><th>1<th>1<th>1<td>1<td>0<td>0<td>0
</table>
</div>
</div>


<h3>Büfé</h3>
<p>Egy büfé négy törzsvásárlója az alábbi fajta szendvicseket szereti:</p>
<ul>
    <li>Az 1. vásárló olyan szendvicset szeret, amiben bacon magában van.
    <li>A 2. vásárló szerint a paradicsomos szendvics csak akkor jó, ha van benne salátalevél is.
    <li>A 3. vásárló nem szereti, ha bacon és salátalevél is van egyszerre a szendvicsben.
    <li>A 4. vásárló csak az olyan szendvicset (v)eszi meg, amiben se paradicsom, se salátalevél nincsen.
</ul>

<p>Írj fel mind a négy vásárlóhoz egy-egy logikai kifejezést, amelyek akkor és 
csak akkor igazak, ha egy adott típusú szendvics megfelelő nekik!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>A preferenciák logikai kifejezéssel:</p>
<ul>
    <li>1. vásárló: <code>bacon &amp;&amp; !salata &amp;&amp; !paradicsom</code>,
        mert nem elég csak azt mondani, hogy legyen benne <code>bacon</code>,
         azt is kell mondani, hogy a másik két összetevő nincs.
        
    <li>2. vásárló: <code>!paradicsom || salata</code>,
        mert ha van <code>paradicsom</code>, a kifejezés első fele hamis lesz, ilyenkor a második
        fele: <code>salata</code> muszáj igaz legyen, hogy az egész igaz tudjon lenni;
        ha pedig nincs <code>paradicsom</code>, az első fele mindenképp igaz, tehát lehet benne
        <code>salata</code>, de az se baj, ha nincs.
    <li>3. vásárló: <code>!(bacon &amp;&amp; salata)</code>,
        mert ha mindkettő van, a belső részkifejezés igaz lesz, és pont azt nem szereti, tehát tagadjuk.
    <li>4. vásárló: <code>!paradicsom &amp;&amp; !salata</code>, mert egyik sem teljesülhet.
</ul>
</div>
</div>


<h3>Wason feladatai</h3>
<div class="kartyak float">
    <span>○</span>
    <span>6</span>
    <span>□</span>
    <span>3</span>
</div>
<p><em>1. feladat. </em>Tegyük fel, hogy vannak kártyáink, amelyeknek egyik oldalán egy alakzat van, másikon pedig egy szám.
Adott egy szabály:</p>
<p class="bentebb">Ha egy kártyának négyzet van az egyik oldalán, páratlan szám kell legyen a másik oldalán.</p>
<p>Ezek állítólag érvényesek az oldalt látható kártyákra. Melyeket kell 
megfordítani ahhoz, hogy ellenőrizzük a szabályt? Ha a <code>negyzet</code> változó és a <code>paros</code>
változó igaz/hamis értékeket tárolnak, amelyek azt mutatják, egy adott kártyán négyzet, illetve páros
szám van-e, akkor mi az a logikai kifejezés, amely igazra értékelődik ki, ha egy kártya megfelel
a szabálynak?</p>


<p><em>2. feladat. </em>Egy országban legalább 18 évesnek kell lennie valakinek ahhoz,
hogy valaki sört ihasson. Egy rendőr az alábbiakat tudja egy bár négy különböző vendégéről:</p>
<ul>
    <li>Sört iszik.
    <li>Kólát iszik.
    <li>25 éves.
    <li>16 éves.
</ul>
<p>Melyikükről kell több információt szereznie, hogy tudja, betartja-e a törvényt?</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p><em>1. feladat.</em> Meg kell fordítani a négyzetest, mert ha nem páratlan számot találunk a másik oldalán, akkor az
megsérti a szabályt. Meg kell fordítani a hatost is, mert ha négyzet van a másik oldalán, a páros
számával sérti a szabályt. A logikai kifejezés pedig <code>!negyzet || paros</code>.</p>
<p><em>2. feladat.</em> A sört ivóról és a 16 évesről.</p>
<ul>
    <li>A sört ivóról tudnia kell, elmúlt-e 18.
    <li>Aki kólát iszik, bárhány éves lehet, nem szegi meg a tilalmat.
    <li>Aki 25 éves, bármit ihat.
    <li>Aki 16 éves, nem ihat sört – róla tudnia kell, mit iszik.
</ul>
<p>A két feladat matematikailag tökéletesen egyforma. Egyformák lettek a megoldásaid is?</p>
</div>
</div>




</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>Logikai kifejezések programokban</h2>
</div>

<h3>Osztható-e</h3>
<p>Készíts programot, mely a felhasználótól bekért két számról megállapítja, hogy oszthatók-e egymással!</p>

<h3>Háromszög</h3>
<p>Készíts programot, amely a felhasználó által megadott a, b és c háromszög oldalhosszúságok ismeretében
a.) eldönti, hogy létezik-e a háromszög,
b.) meghatározza, hogy ha létezik a háromszög, az derékszögű, hegyesszögű vagy tompaszögű.
(A Pitagorasz-tétel alapján ez eldönthető.)</p>

<h3>Kisebb, nagyobb, egyenlő</h3>
<p>Készíts programot, mely három változó (a,b,c) értékét a felhasználótól megkérdezi, majd a 
számok közötti relációt kiírja a képernyőre. Természetesen előfordulhat egyenlőség is. 
Lehetséges példák eredményre: "b&lt;c&lt;a", "c&lt;a=b", "a=b=c", stb.</p>

<h3>Karakter típusa</h3>
<p>Készíts programot, mely beolvas egy karaktert, és megállapítja róla, hogy az nagybetű, 
kisbetű, szám vagy egyéb karakter!</p>

<h3>A Caesar-féle kódolás</h3>
<p>Készíts egy programot, amelyik egy beírt szöveget titkosít. A titkosítás egyszerű: minden 
betű helyett az ábécében következőt használjuk, z helyett pedig a-t.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    char c;

    /* egyesevel a karakterek */
    while (scanf(&quot;%c&quot;, &amp;c)==1) {
        /* ez a ketto specialis, mert &quot;tulpordul&quot; */
        if (c=='z') {
            c = 'a';
        }
        else if (c=='Z') {
            c = 'A';
        }
        else {
            /* tovabbi kodolando betuk: a..z és A..Z. C-ben:
               HA (if) a) a és z kozott van VAGY (||) b) A es Z kozott van */
            if ((c&gt;='a' &amp;&amp; c&lt;'z') || (c&gt;='A' &amp;&amp; c&lt;'Z'))
                c = c+1;
            /* tobbi valtozatlanul marad. */
        }
        printf(&quot;%c&quot;, c);
    }
    
    return 0;
}</pre>
</div>
</div>


<h3>Euler feladata</h3>
<p>Egy gazda sertést, kecskét és juhot vásárolt,
összesen 100 állatot, pontosan 600 aranyért. A sertés darabja 21
arany, a kecskéé 8 arany, a juhoké 3 arany. Hány darabot vett
mindegyik állatból? Oldd meg nyers erővel (azaz a lehetséges
esetek végigpróbálásával) a feladatot!</p>


<h3>Oszthatóság</h3>
<p>Készíts programot, mely meghatározza és kiírja az összes hárommal és öttel egyaránt osztható, 
1000-nél kisebb természetes számot.</p>

<h3>Fizzbuzz</h3>
<div class="sticky">állásinterjú</div>
<p>Írj programot, amely a fizz-buzz játékot játssza! Ez a számokat növekvő sorrendben írja ki; de minden
3-mal osztható helyére azt, hogy „fizz”, az 5-tel oszthatók helyére pedig azt, hogy „buzz”. Ha
mindkét feltétel teljesül, akkor a kiírandó szöveg „fizzbuzz”.</p>
<p>Hogy lehetne megírni ezt a programot röviden, ha a 7-eseknél „banana”, és 11-eseknél „bumm” van a
fentihez hasonló módon?</p>

<h3>Visszafelé</h3>
<p>Készíts programot, mely a felhasználótól beolvasott természetes számot visszafele írja ki. 
Például 651-re a válasz: 156.</p>

<h3>Az ötjegyű számok osztója</h3>
<p>Készíts programot, mely meghatározza az összes olyan legfeljebb 
ötjegyű természetes számot, amelynek első két jegyéből alkotott szám osztója 
az eredeti számnak!</p>


<h3>Gyors hatványozás</h3>
<p>A hatványozás az egyszerű ciklusnál gyorsabban is elvégezhető, mivel az <code>x<sup>8</sup>=x<sup>4</sup>·x<sup>4</sup></code>, <code>x<sup>4</sup>=x<sup>2</sup>·x<sup>2</sup></code> és
<code>x<sup>2</sup>=x·x</code> stb. miatt például a nyolcadikra hatványozáshoz mindössze három szorzásra van szükség.
A következő megfigyelést tehetjük:
<ul>
    <li><code>x<sup>n</sup>=(x<sup>2</sup>)<sup>n/2</sup></code>, ha <code>n</code> páros, és
    <li><code>x<sup>n</sup>=x·x<sup>n-1</sup></code>, ha <code>n</code> páratlan.
</ul>
<p>Írj ciklust, amely a fentiek alapján végzi el a hatványozást!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Tipp</a></h4>
<div class="megjelenik csik">
<p>Az nem baj, ha az alapot tároló változó értéke elveszik.
Ha a kitevő páros, éppen azt kell négyzetre emelni.</p>
</div>
</div>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int i;

    for (i=0; i&lt;16; ++i) {
        double alap = 2;
        double hatvany;
        int kitevo = i;

        hatvany=1;
        while (kitevo &gt; 0) {
            if (kitevo % 2 == 1) {
                hatvany=hatvany * alap;
                kitevo--;
            } else {
                alap = alap * alap;
                kitevo/=2;
            }
        }

        printf(&quot;%g\n&quot;, hatvany);
    }

    return 0;
}</pre>
</div>
</div>

<h3>Legnagyobb közös osztó</h3>
<pre class="float boxdrawing" style="line-height: 1.1">
300│2
150│2
 75│3
 25│5
  5│5
  1│
</pre>

<p>Emlékezz vissza a gyakorlat feladatára, a prímtényezős felbontásra.
Egy adott osztóval addig osztunk, amíg csak lehet; utána a következő osztót próbáljuk.
Mindezt pedig addig folytatjuk, amíg 1-ig el nem érünk, mert az már nem osztható semmivel.</p>

<p>Tervezz programot két pozitív egész <em>legnagyobb közös 
osztójának</em> (LNKO) meghatározására! Gondold végig, hogyan lehet 
a sima prímtényezős felbontásból kiindulni. (Egy tényező akkor 
szerepel a közös osztó felbontásában, ha mindkettő számnak 
tényezője.) A tervezéshez pszeudokódot, folyamatábrát vagy 
struktogramot használj! Valósítsd meg a programot C nyelven!

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int szam1, szam2;
    int lnko, oszto;

    printf(&quot;Egyik szam? &quot;);
    scanf(&quot;%d&quot;, &amp;szam1);
    printf(&quot;Masik szam? &quot;);
    scanf(&quot;%d&quot;, &amp;szam2);

    lnko=1;     /* ez mindennek osztoja :) */
    oszto=2;    /* legkisebb szam, amivel osztunk */
    while (szam1&gt;1 &amp;&amp; szam2&gt;1) {
        /* amig mindkettonek osztoja */
        while (szam1%oszto==0 &amp;&amp; szam2%oszto==0) {
            /* addig ez tenyezo, felszorozzuk */
            lnko=lnko*oszto;
            szam1=szam1/oszto;
            szam2=szam2/oszto;
        }
        /* ha kijottunk a fenti ciklusbol, valamelyiknek
           nem osztoja mar. mindegy, melyiknek; a masikat
           osztogassuk le. a ket ciklus kozul az egyik
           olyan lesz, amibe egyszer sem megy be! */
        while (szam1%oszto==0)
            szam1=szam1/oszto;
        while (szam2%oszto==0)
            szam2=szam2/oszto;

        oszto=oszto+1;
    }

    printf(&quot;LNKO: %d\n&quot;, lnko);

    return 0;
}</pre>
</div>
</div>

<h3>Legkisebb közös többszörös</h3>

<p>Írd át úgy a fenti programot, hogy a <em>legkisebb közös többszörösét</em> (LKKT) számolja ki a két megadott számnak!
Gondold meg: mikor tényezője a közös többszörösnek egy prímszám?</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int a, b;
    int oszto, lkkt;

    /* a ket szamot kerjuk a felhasznalotol */
    printf(&quot;a=&quot;); scanf(&quot;%d&quot;, &amp;a);
    printf(&quot;b=&quot;); scanf(&quot;%d&quot;, &amp;b);

    oszto=2;
    lkkt=1;
    /* amig valamelyik meg nem egy */
    while (a&gt;1 || b&gt;1) {
        /* ha mindkettonek osztoja, felszorozzuk */
        while (a%oszto==0 &amp;&amp; b%oszto==0) {
            lkkt=lkkt*oszto;
            a=a/oszto;
            b=b/oszto;
        }
        /* ha valamelyiknek osztoja, akkor is felszorozzuk */
        while (a%oszto==0) {
            lkkt=lkkt*oszto;
            a=a/oszto;
        }
        while (b%oszto==0) {
            lkkt=lkkt*oszto;
            b=b/oszto;
        }
        oszto=oszto+1;
    }

    printf(&quot;lkkt=%d\n&quot;, lkkt);

    return 0;
}</pre>
</div>
</div>


<h3>Törtek összege</h3>
<p>Készíts programot, amely kiszámolja a/b+c/d (két tört összegét), majd 
az eredményt törzsalakú törté alakítja (amely már nem egyszerűsíthető 
tovább)!</p>

<h3>Láda</h3>
<pre class="screenshot float sorsurit1">
+---+
|\  |
| \ |
|  \|
+---+
</pre>

<p>Írj programot, amely +, |, -, és \ karakterekből egy <em>ládát </em> rajzol! Figyelj a 
visszaper karakter kirajzolására: azt <code>"\\"</code> formában kell megadni. Hogyan lehetne 
ezt megírni két egymásba ágyazott ciklussal és sok elágazással?</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
   int meret;
   int x, y;

   /* Méret beolvasása */
   printf(&quot;Mekkora legyen? &quot;);
   scanf(&quot;%d&quot;, &amp;meret);

   printf(&quot;lada atloval, csak 2 ciklus\n&quot;);
   for (y=1; y&lt;=meret; y+=1) {
      for (x=1; x&lt;=meret; x+=1)
         /* Feltétel a 4 sarokpontra */
         if ((x==1 &amp;&amp; (y==1 || y==meret)) || (x==meret &amp;&amp; (y==1 || y==meret)))
            printf(&quot;+&quot;);
         else
            /* Feltétel a vízszintes oldalakra */
            if (y==1 || y==meret)
               printf(&quot;-&quot;);
            else
               /* Feltétel a függőleges oldalakra */
               if (x==1 || x==meret)
                  printf(&quot;|&quot;);
               else
                  /* Feltétel az átlóra */
                  if (x==y)
                     printf(&quot;\\&quot;); /* A backslash spec. jelentése miatt duplán kell írni */
                  else
                     printf(&quot; &quot;);
      printf(&quot;\n&quot;);
   }

   return 0;
}</pre>
</div>
</div>

<h3>Lépés a sakktáblán I.</h3>
<p>Használd a sakktáblán a szokásos jelölést; <code>1…8</code> a sorok, <code>a…h</code> az oszlopok jele. Adott
két mező, pl. <code>b7</code> és <code>d6</code>; kérd ezeket a felhasználótól! Mondd meg ezután, ez a <em>lépés
szabályos-e</em> egy király, vezér, futó, bástya vagy huszár számára! (Tegyük fel, hogy nem
áll más figura az útjukban.)

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Tipp</a></h4>
<div class="megjelenik csik">
<p>Amikor karaktert kell beolvasni, a feladattól függően érdemes a <code>scanf()</code>-et 
<code>scanf("%c", &amp;betu)</code> helyett <code>scanf(" %c", &amp;betu)</code> formában használni, 
azaz tenni egy szóközt a <code>%c</code> elé. Ennek hatására a <code>scanf()</code> eldobja a 
kapott szóköz és újsor (enter) karaktereket, és megvárja az első nem szóközt. Erre azért van 
szükség, mert karakterek beolvasásánál alapértelmezés szerint megkapjuk a felhasználó által 
leütött entereket is.</p>
</div>
</div>
    
<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
    /* a két mező koordinátája */
    char o1, s1, o2, s2;

    /* megkérdezzük a felhasználót. */
    /* a scanf-nél a szóközök elnyelik a whitespace karaktereket. */
    printf(&quot;Írd be az első mezőt, pl. d6!\n? &quot;);
    scanf(&quot; %c %c&quot;, &amp;o1, &amp;s1);
    printf(&quot;Írd be a második mezőt, pl. f8!\n? &quot;);
    scanf(&quot; %c %c&quot;, &amp;o2, &amp;s2);

    /* a betűkre karakterként (számként) tekintek.
     * mivel ábécé sorban vannak, a számjegyek pedig növekvő
     * sorrendben, ezért kisebb/nagyobb összehasonlítást
     * végezhetek, és kivonhatom őket egymásból. */
    if (o1&lt;'a' || o1&gt;'h' || s1&lt;'0' || s1&gt;'8'
        || o2&lt;'a' || o2&gt;'h' || s2&lt;'0' || s2&gt;'8') {
        printf(&quot;Hibás sor- vagy oszlopmegadás!\n&quot;);
    } else {
        /* kivételes eset mindegyik figuránál, ha nem
         * lépett sehova (o1==o2 és s1==s2), hiszen az
         * nem is lépés. itt azért szerepel mindegyik
         * kifejezésben, hogy önmagukban is egészt
         * alkossanak. */
        /* a király egyet léphet valamelyik irányba. ez
         * azt jelenti, hogy a sor- és az oszlopugrás
         * távolságának abszolút értéke maximum egy. */
        if (abs(o1-o2)&lt;=1 &amp;&amp; abs(s1-s2)&lt;=1 &amp;&amp; !(o1==o2 &amp;&amp; s1==s2)) {
           printf(&quot;Ez szabályos a király számára.\n&quot;);
        }
        /* a bástyánál az oszlop- vagy a sor változatlan.
         * de mindkettő nem lehet ugyanaz. */
        if ((o1==o2 || s1==s2) &amp;&amp; !(o1==o2 &amp;&amp; s1==s2)) {
            printf(&quot;Egy bástya léphet így.\n&quot;);
        }
        /* a futónál mindkét irányba ugyanannyit kell
         * mozdulni, úgy jön ki az átlós lépés. */
        if (abs(o1-o2)==abs(s1-s2) &amp;&amp; !(o1==o2 &amp;&amp; s1==s2)) {
            printf(&quot;Egy futó számára ez helyes lépés lehet.\n&quot;);
        }
        /* a királynő mint a bástya és a futó együtt. */
        if (((o1==o2 || s1==s2) || abs(o1-o2)==abs(s1-s2))
            &amp;&amp; !(o1==o2 &amp;&amp; s1==s2)) {
            printf(&quot;A vezér léphet ilyet.\n&quot;);
        }
        /* a huszár nehéznek tűnik, de nem az. az L alak
         * azt jelenti, hogy a vízszintes elmozdulás 1,
         * a függőleges 2, vagy fordítva. */
        if ((abs(o1-o2)==2 &amp;&amp; abs(s1-s2)==1)
            || (abs(o1-o2)==1 &amp;&amp; abs(s1-s2)==2)) {
            printf(&quot;Huszár számára szabályos.\n&quot;);
        }
    }

    return 0;
}</pre>
</div>
</div>

<h3>Lépés a sakktáblán II.</h3>
<p>A feladat mint az előző, de most csak egy mezőt ad a felhasználó (pl. <code>d6</code>).
Listázd ki a programból, melyekre tud lépni szabályosan arról egy király, egy vezér stb.</p>



<h3>Páratlan számok</h3>
<div class="sticky">Kis ZH volt</div>
<p>Egy program bekér a felhasználótól két pozitív egész számot, és kiírja a két szám közötti 
összes páratlan számot. A program akkor is helyesen működik, ha a felhasználó előbb a felső, 
aztán az alsó határt adja meg (és fordítva is).</p>
<p>Add meg az algoritmus pszeudokódját, és készítsd el a programot C nyelven! A program 
kötelezően a pszeudokódot valósítsa meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<pre>
Első és második szám bekérése
Ha első > második
    alsó = második, felső = első
Egyébként
    alsó = első, felső = második
A ciklusváltozó legyen alsó
Amíg a ciklusváltozó kisebb vagy egyenlő a felsővel
    Ha a ciklusváltozó páratlan
       Írd ki a ciklusváltozót
    Növeld a ciklusváltozót eggyel
</pre>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int elso, masodik, also, felso, i;

    printf(&quot;Elso = &quot;);       scanf(&quot;%d&quot;,&amp;elso);
    printf(&quot;Masodik = &quot;);    scanf(&quot;%d&quot;,&amp;masodik);

    if (elso &gt; masodik) { also = masodik; felso = elso; }
    else { also = elso; felso = masodik; }

    for (i = also; i &lt;= felso; i = i + 1)
        if (i % 2 == 1) printf(&quot;%d &quot;,i);

    return 0;
}</pre>

</div>
</div>



<h3>Annyi csillag, ahány&hellip;</h3>
<div class="sticky">Kis ZH volt</div>
<p>Egy program bekér a felhasználótól két pozitív egész számot, és kiszámítja a két szám közötti 
összes 5-tel osztható páros szám összegét, majd ennyi * karaktert ír a képernyőre. A 
program akkor is helyesen működik, ha a felhasználó előbb a felső, aztán az alsó határt 
adja meg (és fordítva is).</p>
<p>Add meg az algoritmus pszeudokódját, és készítsd el a programot C nyelven! A 
program kötelezően a pszeudokódot valósítsa meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<pre>
Első és második szám bekérése
Ha első > második
    alsó = második, felső = első
Egyébként
    alsó = első, felső = második
Összeg = 0, ciklusváltozó = alsó
Amíg ciklusváltozó kisebb, mint felső
    Ha ciklusváltozó osztható 10-zel
        Összeget növeld ciklusváltozóval
    növeld ciklusváltozót eggyel
Ciklusváltozó = 0
Amíg ciklusváltozó &lt; összeg
    írj ki egy csillagot
    ciklusváltozót növeld eggyel
</pre>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int elso, masodik, also, felso, sum, i;

    printf(&quot;Elso = &quot;);       scanf(&quot;%d&quot;,&amp;elso);
    printf(&quot;Masodik = &quot;);    scanf(&quot;%d&quot;,&amp;masodik);

    if (elso &gt; masodik) { also = masodik; felso = elso; }
    else { also = elso; felso = masodik; }

    sum = 0;
    for (i = also; i &lt;= felso; i = i + 1)
        if (i % 10 == 0)  sum += i;

    for (i = 0; i&lt;sum; i = i + 1) printf(&quot;*&quot;);

    return 0;
}</pre>

</div>
</div>


<h3>Hárommal oszthatók, de öttel nem</h3>
<div class="sticky">Kis ZH volt</div>
<p>Egy program bekér a felhasználótól két pozitív egész számot, és megszámolja, hogy a két szám 
között hány 3-mal osztható, de 5-tel nem osztható szám áll, végül kiírja a darabszámot. A 
program akkor is helyesen működik, ha a felhasználó előbb a felső, aztán az alsó határt adja meg 
(és fordítva is).</p>
<p>Add meg az algoritmus pszeudokódját, és készítsd el a programot C nyelven! A 
program kötelezően a pszeudokódot valósítsa meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<pre>
Első és második szám bekérése
Ha első > második
    alsó = második, felső = első
Egyébként
    alsó = első, felső = második
Darabszám = 0, ciklusváltozó = alsó
Amíg ciklusváltozó kisebb, mint felső
    Ha alsó osztható hárommal, de nem osztható öttel
        Darabszám növelése eggyel
    Alsó növelése eggyel
</pre>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int elso, masodik, also, felso, darab,i;

    printf(&quot;Elso = &quot;);       scanf(&quot;%d&quot;,&amp;elso);
    printf(&quot;Masodik = &quot;);    scanf(&quot;%d&quot;,&amp;masodik);

    if (elso &gt; masodik) { also = masodik; felso = elso; }
    else { also = elso; felso = masodik; }

    darab = 0;
    for (i = also; i &lt;= felso; i = i + 1)
        if (i%3 == 0 &amp;&amp; i%5 != 0)
            darab = darab + 1;

    printf(&quot;%d &quot;, darab);

    return 0;
}</pre>

</div>
</div>








</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>Sorozatok beolvasása</h2>
</div>

<h3>Számok összege és szorzata</h3>
<p>Írj programot, amely a felhasználótól számokat kér, egészen addig, amíg 0-t nem kap! Írja ki 
ezeknek a számoknak az a) összegét, b) szorzatát.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Ha használtál <code>if()</code>-et, rosszul csinálod – van egyszerűbb megoldás is!</p>
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int szam, szorzat;

    szorzat = 1;
    /* első */
    printf(&quot;Szam vagy 0? &quot;);
    scanf(&quot;%d&quot;, &amp;szam);
    while (szam!=0) {
        szorzat = szorzat*szam;
        /* többi */
        printf(&quot;Szam vagy 0? &quot;);
        scanf(&quot;%d&quot;, &amp;szam);
    }

    printf(&quot;Szorzatuk: %d\n&quot;, szorzat);

    return 0;
}
</pre>
</div>
</div>



<h3>Kerítés</h3>
<img src="f03/kerites.svg" class="float" style="width: 12em;">
<p>Egy gazda szeretné körbekeríteni a telkét drótkerítéssel.
Írj programot, amely kiszámítja, hogy mennyi kerítésre lesz szüksége! A
program kérje egymás után a kerítésoszlopok koordinátáit (x, y
koordinátapárok), számítsa ki az aktuális és az előző oszlop távolságát, és
összegezze a távolságokat! Az összegzést addig folytassa, amíg a megadott
koordináták nem egyeznek az elsőként megadott koordinátapárral, vagyis míg
vissza nem ér a kezdőoszlophoz!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Ha használtál tömböt, feleslegesen sok memóriát foglalsz. Nem kell tömb a programhoz. Ha 
használtál <code>if()</code>-et, akkor pedig rosszul szervezted a ciklust. Az sem kell!</p>
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(void) {
    double kx,ky; /* Kezdőpont koordinátái */
    double x1,y1,x2,y2; /* További pontok koordinátái */
    double ossz; /* Kerítés hossza */

    /* Kezdőpont beolvasása */
    printf(&quot;Kezdopont x=&quot;); scanf(&quot;%lf&quot;,&amp;kx);
    printf(&quot;Kezdopont y=&quot;); scanf(&quot;%lf&quot;,&amp;ky);

    /* A legelső pont is ez lesz */
    x1=kx;
    y1=ky;

    /* További pontok beolvasása */
    printf(&quot;Tovabbi pontok:\n&quot;);
    printf(&quot;x=&quot;); scanf(&quot;%lf&quot;,&amp;x2);
    printf(&quot;y=&quot;); scanf(&quot;%lf&quot;,&amp;y2);

    /* Összeg lenullázása */
    ossz=0;

    /* Addig megyünk amíg a beolvasott pont nem ugyanaz mint az eredeti */
    while (x2!=kx || y2!=ky){
        /* Minden hozzáadjuk a kerítéshez az új szakaszt */
        ossz = ossz + sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
        /* Az előző pont helyére az új pont kerül */
        x1=x2; y1=y2;
        /* Az új pont helyére újat olvasunk */
        printf(&quot;x=&quot;); scanf(&quot;%lf&quot;,&amp;x2);
        printf(&quot;y=&quot;); scanf(&quot;%lf&quot;,&amp;y2);
    }
    /* A végén még hozzá kell adni az utolsó darabot */
    ossz = ossz + sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));

    /* Összeg kiírása */
    printf(&quot;Osszeg: %f\n&quot;,ossz);

    return 0;
}</pre>
</div>
</div>


<h3>Legkisebb, legnagyobb I.</h3>
<p>Készíts programot, mely bekér a felhasználótól egy természetes számot (n). Ezután a 
felhasználótól n darab egész szám megadását kéri, majd kiírja a képernyőre az n megadott szám 
közül a legkisebbet és a legnagyobbat, továbbá a számok átlagát.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Tipp</a></h4>
<div class="megjelenik csik">
<p>Vegyük észre, hogy ehhez nem kell tömb! Továbbá azt is észre kell venni, hogy az első számot 
némileg speciálisnak kell tekinteni. Fel kell tételezni, hogy az is marad a legkisebb; majd 
később legfeljebb találunk még kisebbet. De az ilyen <code>int&nbsp;min=100000000</code>-szerű 
megoldás elvi hibás!</p>
</div>
</div>

<h3>Legkisebb, legnagyobb II.</h3>
<p>Készíts programot, amely bekér egész számokat mindaddig, amíg nem 
ad meg 0-t a felhasználó. A program határozza meg és írja ki a 
beadott egész számok közül a legkisebbet és a legnagyobbat, továbbá 
a számok átlagát! (A 0-t ne számítsd bele a beadott számokba, ez 
csak a bevitel végét jelzi. Vigyázz, ez nem ugyanaz a feladat, mint az előző!)</p>

<h3>Tabulátorok</h3>
<p>Írj olyan programot, amely a bemeneten talált tab karakterek mindegyikét annyi ponttal helyettesíti,
amennyi a következő tabulátor pozícióig hátravan! A tabulátor pozíciók legyenek 8 karakterenként.
Például, bemenet (ahol a \t-vel jelzett helyeken a felhasználó a tabulátor billentyűt nyomja meg):
<pre>
\t\tHello,
világ\t!
</pre>
<p>Kimenet:</p>
<pre>
<em>1234567|1234567|1234567</em>
................Hello,
világ...!
</pre>

<h3>Repülés</h3>
<p>Egy repülőgéppel repülünk, és 100 m-ként megmérjük a felszín tengerszint feletti magasságát 
méterben. Készíts programot, mely a billentyűzetről beérkező adatok eltárolása nélkül megállapítja, hogy
<br>
a.) jártunk-e a tenger felett?
<br>
b.) átrepültünk-e sziget felett? Ha igen, hány sziget felett?
<br>
Az első és utolsó mérést szárazföldön végeztük. (Az adatbeolvasás végét a -1 adat bevitele jelezze!)</p>



</div>
</section>
<section id="4">
<div class="slide" id="slide_4">
<div class="slideheader">
<h2><span class="oldalszam">4</span>Programozási tételek</h2>
</div>

<h3>Négyzetszám</h3>
<p>Készíts programot, amely egy pozitív egész számról négyzetgyökvonás nélkül eldönti, hogy négyzetszám-e!</p>

<h3>Osztók száma</h3>
<p>Írj programot, ami kiírja egy pozitív, egész szám osztóinak a számát!</p>

<h3>Intervallum prímszámai</h3>
<p>Készíts programot, mely a felhasználó által megadott [n,m] 
zárt intervallumban növekvő sorrendben kiírja az összes prímszámot!</p>
<p>Végezz ellenőrzést, hogy a megadott két szám helyes-e: egyik szám 
sem lehet kisebb 2-nél. Ha a felhasználó m-re kisebb számot ad meg, 
mint n-re, akkor a két számot automatikusan cserélje meg!</p>

<h3>Nem prímek</h3>

<div class="sticky">Kis ZH volt</div>

<p>Írj C programot, amely kér a felhasználótól egy pozitív egész számot, és utána 
kiírja az összes, ennél a számnál kisebb olyan pozitív egész számot, amely <em>nem</em> prím!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int n, i;

    printf(&quot;Max=&quot;);
    scanf(&quot;%d&quot;,&amp;n);

    printf(&quot;1\n&quot;);
    for (i=2; i&lt;n; i++) {
        int prim = 1, j;
        for (j=2; j&lt;i; j++)
            if (i%j == 0)
                prim = 0;
        if (!prim)
            printf(&quot;%d\n&quot;,i);
    }

    return 0;
}</pre>
</div>
</div>





<h3>Adott számnál kisebb tökéletes számok</h3>

<div class="sticky">Kis ZH volt</div>

<p>Írj C programot, amely kér a felhasználótól egy pozitív egész számot, és kiírja az 
összes, a megadott értéknél kisebb tökéletes számot! Tökéletes az a szám, amely megegyezik 
osztóinak összegével, pl.: 28=1+2+4+7+14.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int n,i;

    printf(&quot;Max=&quot;);
    scanf(&quot;%d&quot;,&amp;n);

    printf(&quot;1\n&quot;);
    for (i=2; i&lt;n; i++) {
        int sum=0, j;
        for (j=1; j&lt;i; j++)
            if (i%j == 0)
                sum += j;
        if (sum==i)
            printf(&quot;%d\n&quot;,i);
    }

    return 0;
}</pre>
</div>
</div>

<h3>Párosak, páratlanok</h3>
<p>Készíts programot, mely bekér N darab természetes számot (először N-et 
kérje be). Az adatok beírása után a program írja ki a beírt páros és páratlan 
számok darabszámát, és a páratlan számok összegét!</p>

<h3>Számjegyek összege</h3>
<p>Készíts programot, mely egy természetes szám számjegyeinek összegét képes meghatározni.</p>

<h3>Pontosan három osztó</h3>
<p>Írj programot, amely kiírja a képernyőre az első öt olyan számot, amelynek pontosan három osztója van!</p>

<h3>Prímszámok</h3>
<p>Kérj a felhasználótól egy <code>n</code> számot. Írd ki az összes olyan <code>(i;j)</code> párt,
amelyre <code>1&lt;i&lt;j&le;n</code>, és igaz az, hogy <code>i+j</code> prím. Pl. <code>n=6</code> esetén <code>2+3=5</code>, <code>3+4=7</code> stb.</p>

<h3>Osztható mind a tízzel</h3>
<p>Melyik a legkisebb olyan szám, amelynek osztója az 1…10 számok mindegyike? (2520.) Határozd ezt meg programból!
Melyik programozási tételt kell ehhez használni?</p>

<h3>3 és 5 többszörösei</h3>
<p>A 3 és 5 számok 10-nél kisebb többszörösei 3, 5, 6 és 9. Ezek összege 23. Mennyi az 1000 alatti
ilyen számok összege? Ehhez melyik tétel szükséges?</p>
   
<h3>Egy kör belső pontjai</h3>
<p>Adott a síkon középpontjának (x,y) koordinátáival és sugarával egy kör. 
Készíts programot, mely megadja a körbe eső egész koordinátájú pontok 
számát!</p>

<h3>Az összeg a maximum nélkül</h3>
<div class="sticky">Kis ZH volt</div>
<p>Egy program megkérdezi a felhasználótól, hogy hány darab szám összegét kívánja kiszámolni, 
majd bekér ennyi darab egész számot. Utána kiírja a számok összegét úgy, hogy az 
összegben ne legyen benne a felhasználó által megadott legnagyobb szám. (Az összeg 
így éppen a maximummal kevesebb.) Pl. ha a felhasználó 4 számot ad: -1, 10, 5, 7, 
akkor a kiírt összeg 11 lesz, mert -1+5+7=11.</p>

<p>Add meg az algoritmus pszeudokódját, és készítsd el a programot C nyelven! A 
program kötelezően a pszeudokódot valósítsa meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<pre>
Darabszám bekérése
Összeg = 0
Ciklusváltozó = 0
Amíg ciklusváltozó kisebb, mint a darabszám
    Kérd be a következő számot
    Ha a ciklusváltozó 0, a maximum legyen egyenlő a számmal
    Egyébkén
        Ha a szám nagyobb a maximumnál
            A maximum legyen egyenlő a számmal
    Az összeghez add hozzá a számot
Írd ki az összeg és a maximum különbségét
</pre>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int db, sum, max, akt, i;

    printf(&quot;Hany db szamot adsz ossze? &quot;);
    scanf(&quot;%d&quot;, &amp;db);

    sum = 0;

    for (i = 0; i &lt; db; i = i + 1) {
        printf(&quot;A kovetkezo szam: &quot;);
        scanf(&quot;%d&quot;,&amp;akt);

        if (i == 0)  max = akt;
        else if (akt &gt; max)  max = akt;

        sum += akt;
    }

    /* a trükk: a teljes összegből levonjuk a legnagyobbat. */
    /* így pont olyan lesz, mintha az kimaradt volna az összegből. */
    printf(&quot;Osszeg: %d\n&quot;, sum - max);

    return 0;
}</pre>

</div>
</div>




<h3>Adott számnál kisebb legnagyobb prím</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj C programot, amely bekér a felhasználótól egy egész számot, 
és kiírja a számnál kisebb számok közül a legnagyobb prímet, ha van 
ilyen!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>A talált prímeket felesleges eltárolni – egy tömb használata
súlyos hiba lenne. Visszafelé kell haladni a kereséssel, és
az első találat éppen a keresett prím.</p>
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void){
    int szam;
    scanf(&quot;%d&quot;,&amp;szam);
    if (szam&gt;2) {
        int prim = 0, proba;
        for (proba = szam-1; proba&gt;1 &amp;&amp; !prim; proba -= 1){
            int i;
            prim = 1;
            for (i=2; i&lt;proba &amp;&amp; prim; i++)
                if (proba % i == 0)
                    prim = 0;
        }
        printf(&quot;%d\n&quot;, proba + 1);
    }
    return 0;
}</pre>
</div>
</div>



<h3>A beírtak közül legnagyobb prím</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj C programot, amely egész számokat kér be a felhasználótól
mindaddig, amíg a felhasználó pozitív számokat ad meg! Ezt követően
írja ki a beolvasott számok közül a legnagyobb prímet (a beolvasott
számok között lehet a legnagyobb prímnél nagyobb összetett szám is,
tehát nem elég a maximumot vizsgálni, a prímséget is kell)!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Súlyos hiba lenne itt a beírt számokat eltárolni. A szélsőérték
kereséséhez felesleges – mindig csak a legutóbbi (legnagyobb) értékre
kell emlékeznie a programnak!</p>
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void){
    int szam, max = 0;
    while (scanf(&quot;%d&quot;, &amp;szam)==1 &amp;&amp; szam&gt;0){
        if (szam &gt; max){
            int i, prim;
            for (i = 2, prim = 1; i &lt; szam; i++)
                if (szam % i == 0) prim = 0;
            if (prim) max = szam;
        }
    }
    if (max&gt;0) printf(&quot;Max= %d\n&quot;,max);
    return 0;
}</pre>
</div>
</div>

<h3>Minden prímedik betű</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj C programot, amely karaktereket olvas a szabványos 
bemenetről! A karaktersorozat végét pont (’.’) jelzi. A program írja 
ki azokat a karaktereket, amelyek sorszáma a szövegben egy prímszám 
(tehát a szöveg 2, 3, 5, 7, 11 stb. sorszámú karaktereit)! Pl. be: 
„:Ebfeldiszeileg nyilul szorom egy mancsot ez? ma nem.”, ki: 
„Ebedelni mentem”.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Itt is súlyos hiba lenne a szöveget eltárolni. Ahogy jött egy karakter,
el lehet dönteni, ki kell-e írni. A kiírás után nem is kell rá emlékezni.</p>
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    char ch;
    int sorszam = 1;
    while (scanf(&quot;%c&quot;, &amp;ch)==1 &amp;&amp; ch!='.') {
        int i;
        for (i = 2; sorszam%i!=0 &amp;&amp; i&lt;sorszam; i++) /*üres*/;
        if (sorszam==i)
            printf(&quot;%c&quot;, ch);
        sorszam++;
    }
    return 0;
}</pre>
</div>
</div>

<h3>Osztók összege vajon prím-e?</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj C programot, amely bekér a felhasználótól egy pozitív egész 
számot (nem kell ellenőrizni, feltételezzük, hogy a felhasználó 
valóban pozitív egészt adott meg)! A program számítsa ki a szám 
osztóinak összegét, és írja ki, hogy ez prím-e! Pl. be: 9 ki: 
Osszeg: 13, prím (1+3+9).</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>A megtalált osztókat felesleges eltárolni, csak az összegre
vagyunk kíváncsiak. Ezért tömböt használni hiba lenne.</p>
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void){
    int szam, osszeg, i;
    scanf(&quot;%d&quot;,&amp;szam);

    /* Osztók sszege */
    for (osszeg = 0, i = 1; i &lt;= szam; i++)
        if (szam % i == 0) osszeg += i;

    /* Prím-e */
    for (i = 2; i &lt; osszeg &amp;&amp; osszeg % i != 0; i++) /* üres */ ;

    if (i == osszeg) printf(&quot;Osszeg: %d, prim\n&quot;, osszeg);
    else printf(&quot;Osszeg: %d, nem prim\n&quot;, osszeg);

    return 0;
}</pre>
</div>
</div>









</div>
</section>
<section id="5">
<div class="slide" id="slide_5">
<a id="tombok" class="namer"></a>
<div class="slideheader">
<h2><span class="oldalszam">5</span>Tömbök</h2>
</div>

<h3>Tömb kiírása – szépen</h3>
<p>Írj programrészt, amely kiírja egy tömb elemeit a képernyőre, vesszővel elválasztva. A kiírás legyen
szép: ne legyen se az elején, se a végén felesleges vessző. A kód is legyen szép: mindez megoldható egyetlen
ciklussal, nem kell hozzá <code>if()</code> feltétel!</p>

<pre class="screenshot">
A tömb: 25, 69, 54, 8, 77, 6, 29, 10, 3, 98.
</pre>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int tomb[10] = { 25, 69, 54, 8, 77, 6, 29, 10, 3, 98 };
    int i;

    /* Kiírás */
    printf(&quot;A tömb:&quot;);
    /* első elem */
    printf(&quot; %d&quot;, tomb[0]);
    /* többi elem */
    for (i=1; i&lt;10; ++i)
        printf(&quot;, %d&quot;, tomb[i]);
    printf(&quot;.\n&quot;);

    return 0;
}</pre>
</div>
</div>



<h3>Szigmon</h3>

<p>Készíts egy olyan C programot, amely létrehoz és a programba beépített kezdeti értékekkel
feltölt egy <code>int</code> típusú elemeket tartalmazó tömböt!
Írja ki, hogy a tömb elemei szigorúan monoton növekvőek, csökkenőek, vagy egyik sem!</p>

<p>Teszteld a programot, hogy mind a három eredményt előállítsd vele! Próbáld ki úgy is,
hogy a csökkenő vagy növekvő monotonitást a tömb első kettő vagy utolsó kettő elemével
rontod el, hogy lásd, a számsor széleit is helyesen kezeled-e!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Tipp</a></h4>
<div class="megjelenik csik">
<p>Melyik programozási tételt kell alkalmazni ennek megoldásához? Másképp feltéve
a kérdést, mit kell találni a tömbben ahhoz, hogy tudjuk, nem szigmon növekvő?</p>
</div>
</div>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    /* Változók */
    int tomb[10] = {1,3,6,9,13,16,19,21,45,56};
    int nov, csokk, i;

    /* Tegyük fel hogy szig.mon.növ. és csökk. */
    nov=csokk=1;
    /* Ellenőrzés */
    for (i=0; i&lt;10-1; i++){
        if (!(tomb[i]&lt;tomb[i+1]))
            nov=0; /* Nem teljesül a szig.mon.csökk. */
        if (!(tomb[i]&gt;tomb[i+1]))
            csokk=0; /* Nem teljesül a szig.mon.növ. */
    }

    /* Eredmény */
    if (nov==1)
        printf(&quot;szigmon novekvo&quot;);
    else
        if (csokk==1)
            printf(&quot;szigmon csokkeno&quot;);
        else
            printf(&quot;nem szigmon&quot;);

    return 0;
}</pre>
</div>
</div>








<h3>Léptetés</h3>
<p>Készíts programot, amely egy v[10] tömb elemeit 3 hellyel 
ciklikusan balra lépteti! A feladat megoldható segédtömb nélkül is!</p>

<h3>Kisebbek vagy nagyobbak?</h3>
<p>Adott egy m egészekből álló tömb, véletlen értékekkel feltöltve.
Készíts programot, mely a felhasználótól bekért p egész számról 
meghatározza, hogy a tömbben p-nél nagyobb, vagy p-nél kisebb számokból 
van-e több!</p>

<h3>Elemek száma</h3>
<p>Adott egy rendezetlen tömb. Készíts programot, mellyel a felhasználó 
kiválaszhatja a tömb egy elemét és meghatározza a nála kisebb és nagyobb 
elemek számát!</p>

<h3>Éppen a szorzata</h3>
<p>Adott egy egész számokat tartalmazó tömb (m). Készíts programot, mely 
a felhasználótól bekér egy egész számot (z), majd eldönti, hogy van-e két 
olyan elem a halmazban, amelyek szorzata éppen z!</p>

<h3>Ülőhelyek</h3>
<p>Egy 195 fős előadóba előadást szerveznek. A székek 13 sorban, összesen 
15 oszlopban (téglalap) helyezkednek el. A székek számozása a (színpaddal 
szembeni) bal alsó sarokból kezdődik, jobbra növekszik, és a legfelső sorban 
vannak a legnagyobb számú székek.
<p>A jegyirodában egy 195 elemű egész 
tömbben tárolják a már kiadott foglalásokat. A foglalt helyeket a megfelelő 
székszámhoz írt 1-es jelöli, 0 a szabad hely. Készíts programot, mely az 
újonnan érkező vendégek számára a kívánt számú, egymás melletti ülőhelyet 
kikalkulálja! Vigyázz a sorok szélére!</p>

<h3>Autópálya I.</h3>
<div class="sticky">Kis ZH volt</div>
<p>Az M7-es autópályán traffipaxot szerelnek fel, amely a Balaton felé igyekvők
gyorshajtásait rögzíti. A mérés több nap adatait is tartalmazza; egy
autó adatait „óra perc sebesség” formában.
Pl. 12&nbsp;45&nbsp;198 azt jelenti, 12:45-kor 198&nbsp;km/h-val száguldott valaki.
Az adatsor végét 0&nbsp;0&nbsp;0 zárja.</p>
<p>Készíts a C programod egy táblázatot arról, hogy melyik órában mennyivel
ment a leggyorsabb autó! Ha egy adott órában nem volt gyorshajtás, az
maradjon ki! A kimenet ilyen legyen:</p>

<pre class="screenshot">
14:00-14:59 -&gt; 145 km/h
16:00-16:59 -&gt; 167 km/h
</pre>

<p>(Tipp: a sebességek mind pozitív számok.)</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
   int seb_max[24]={0};
   int ora, perc, seb;
   int i, maxindex;

   scanf(&quot;%d %d %d&quot;, &amp;ora, &amp;perc, &amp;seb);
   while (seb!=0) {
      if (seb&gt;seb_max[ora])
         seb_max[ora]=seb;
      scanf(&quot;%d %d %d&quot;, &amp;ora, &amp;perc, &amp;seb);
   }

   for (i=0; i&lt;24; i+=1)
      if (seb_max[i]&gt;0)
         printf(&quot;%2d:00-%02d:59 -&gt; %d km/h\n&quot;, i, i, seb_max[i]);

   return 0;
}</pre>

</div>
</div>



<h3>Autópálya II.</h3>

<div class="sticky">Kis ZH volt</div>

<p>Az M7 autópályán traffipax méri az autók sebességét. Minden mérésről három adatot ad: „óra 
perc sebesség”, szóközzel elválasztva. Pl. „9&nbsp;39&nbsp;125” jelentése az, hogy 9:39-kor egy 
autó 125&nbsp;km/h-val ment. A 140&nbsp;km/h feletti sebességért 30&nbsp;000&nbsp;Ft a bírság, a 
180&nbsp;km/h felettiért 100&nbsp;000&nbsp;Ft. Az adatsor több nap adatait tartalmazza, és a 
végét 0&nbsp;0&nbsp;0 zárja.</p>

<p>Olvassa be a C programod ezeket az adatokat, és írja ki, hogy a nap mely órájában mennyi az 
összes kirótt bírság! Példa kimenet:</p>

<pre class="screenshot">
12:00-12:59, 60000 Ft
13:00-13:59, 230000 Ft
</pre>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
   int birsag[24]= {0};
   int ora, perc, seb;
   int i;

   scanf(&quot;%d %d %d&quot;, &amp;ora, &amp;perc, &amp;seb);
   while (seb!=0) {
      if (seb&gt;180)
         birsag[ora]+=100000;
      else if (seb&gt;140)
         birsag[ora]+=30000;

      scanf(&quot;%d %d %d&quot;, &amp;ora, &amp;perc, &amp;seb);
   }

   for (i=0; i&lt;24; i+=1)
      printf(&quot;%2d:00-%02d:59, %d Ft\n&quot;, i, i, birsag[i]);

   return 0;
}</pre>
</div>
</div>






<h3>Bliccelés I.</h3>

<div class="sticky">Kis ZH volt</div>

<p>Egy busztársaság kíváncsi az utasok bliccelési szokásaira. Felviszik
számítógépre az összes bírságolás időpontját. Arra kíváncsiak, a napok
fél órás intervallumaiban hány jegy nélkül utazót kaptak el.</p>

<p>Az időpontok „óra perc” formában érkeznek, vagyis szóközzel elválasztva. Így 13&nbsp;44
jelentése délután 13:44. Az adatsort -1 -1 zárja.
Írja ki a C programod, mely fél órás időszakban hány bliccelő volt! Pl.:</p>

<pre class="screenshot">
12:00-12:29 között 3 utas
12:30-12:59 között 5 utas
</pre>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
   int blicceles[24*2]={0};
   int ora, perc;
   int i;

   scanf(&quot;%d %d&quot;, &amp;ora, &amp;perc);
   while (ora!=-1) {
      i=ora*2;
      if (perc&gt;=30)
         i+=1;
      blicceles[i]+=1;
      scanf(&quot;%d %d&quot;, &amp;ora, &amp;perc);
   }

   for (i=0; i&lt;24; i+=1) {
      printf(&quot;%2d:00-%02d:29 kozott %d utas\n&quot;, i, i, blicceles[i*2]);
      printf(&quot;%2d:30-%02d:59 kozott %d utas\n&quot;, i, i, blicceles[i*2+1]);
   }

   return 0;
}</pre>

</div>
</div>



<h3>Bliccelés II.</h3>

<div class="sticky">Kis ZH volt</div>

<p>Egy busztársaság szeretné tudni, a napok mely óráiban hány ellenőrt érdemes terepmunkára 
küldenie. Ehhez összesítik a bírságok adatait. Egy adat a következőkből áll: „óra perc típus 
összeg”, ahol a típusnál <code>h</code> a helyszíni bírság, <code>c</code> pedig a csekk. 
„9&nbsp;45&nbsp;c&nbsp;6000” jelentése: egy utas 9:45-kor csekket kapott 6000 forintról. A 
helyszíni bírságokat az ellenőrök begyűjtik; a csekkes bírságoknak átlagosan 80%-át tudják 
behajtani. (Vagyis egy 6000-es csekk a társaság számára átlagosan csak 4800-at ér.) Az adatsor 
végén 0 0 x 0 szerepel.</p>

<p>Olvassa be a C programod ezeket az adatokat! Készíts kimutatást arról, hogy
mely napszakban mennyi a pótdíjakból a bevétel! Példa kimenet:</p>

<pre class="screenshot">
16:00-16:59, 14800 Ft
17:00-17:59, 12000 Ft
</pre>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
   int birsag[24]= {0};
   int ora, perc, osszeg;
   char tipus;
   int i;

   scanf(&quot;%d %d %c %d&quot;, &amp;ora, &amp;perc, &amp;tipus, &amp;osszeg);
   while (tipus!='x') {
      if (tipus=='c')
         osszeg*=0.8;
      birsag[ora]+=osszeg;
      scanf(&quot;%d %d %c %d&quot;, &amp;ora, &amp;perc, &amp;tipus, &amp;osszeg);
   }

   for (i=0; i&lt;24; i+=1)
      printf(&quot;%2d:00-%02d:59, %d Ft\n&quot;, i, i, birsag[i]);

   return 0;
}</pre>
</div>
</div>









<h3>ZH statisztika I.</h3>

<div class="sticky">Kis ZH volt</div>

<p>Egy oktató statisztikát szeretne készíteni a megíratott ZH-k sikerességéről.
A ZH-n 4 csoport volt (A…D). Mindegyikben három feladat, ezek
pontszáma egész szám, egyenként maximum 10 pont, így a ZH-k
maximum 30 pontosak lehetnek. A ZH akkor sikeres, ha a feladatok külön-külön
legalább 2 pontosak, és a ZH legalább 12 pontos.</p>

<p>Írj programot, mely a szabványos bemenetéről olvassa be soronként egy ZH
betűjelét és 3-3 pontszámát, és a szabványos kimenetre írja ki az egyes
sorokra, hogy hány embernek sikerült. A beolvasott adatsor végét x 0 0 0
zárja.</p>

<div class="columns">
<div>
<p>Példa bemenet:</p>
<pre class="screenshot">
A 1 10 7
C 3 3 5
B 10 10 9
x 0 0 0
</pre>
</div>

<div>
<p>Példa kimenet:</p>
<pre class="screenshot">
A 0
B 1
C 0
D 0
</pre>
</div>
</div>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
   int atment[4]={0};
   char csop;
   int p1, p2, p3;

   scanf(&quot;%c %d %d %d&quot;, &amp;csop, &amp;p1, &amp;p2, &amp;p3);
   while (csop!='x') {
      int szum=p1+p2+p3;
      if (p1&gt;=2 &amp;&amp; p2&gt;=2 &amp;&amp; p3&gt;=2 &amp;&amp; szum&gt;=12)
         ++atment[csop-'A'];
      scanf(&quot;%c %d %d %d&quot;, &amp;csop, &amp;p1, &amp;p2, &amp;p3);
   }

   for (csop='A'; csop&lt;='D'; ++csop)
      printf(&quot;%c %d\n&quot;, csop, atment[csop-'A']);

   return 0;
}</pre>

</div>
</div>




<h3>ZH statisztika II.</h3>

<div class="sticky">Kis ZH volt</div>

<p>Egy oktató statisztikát szeretne készíteni a megírt ZH-król. A ZH-ban három feladat van, ezek 
pontszáma nemnegatív egész szám, egyenként max. 10 pont, így az egész max. 30 pontos lehet.</p>

<p>Írj programot, mely a szabványos bemenetéről olvassa be soronként a ZH-k pontszámait. Az 
adatsort -1 -1 -1 zárja. Írja ki ezután a szabványos kimenetre, hány 0 pontos, hány 1 pontos, … 
és hány 30 pontos megoldás lett. Ha adott pontszámú dolgozat nem született, a sort ne írja ki.</p>

<div class="columns">
<div>
<p>Példa bemenet:</p>
<pre class="screenshot">
8 10 7
4 3 5
10 10 9
10 9 10
-1 -1 -1
</pre>
</div>

<div>
<p>Példa kimenet:</p>
<pre class="screenshot">
12 pontos: 1 db
25 pontos: 1 db
29 pontos: 2 db


</pre>
</div>
</div>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
   int stat[31]= {0};
   int p1, p2, p3, x;

   scanf(&quot;%d %d %d&quot;, &amp;p1, &amp;p2, &amp;p3);
   while (p1!=-1) {
      int szum=p1+p2+p3;
      ++stat[szum];
      scanf(&quot;%d %d %d&quot;, &amp;p1, &amp;p2, &amp;p3);
   }

   for (x=0; x&lt;=30; ++x)
      if (stat[x]!=0)
         printf(&quot;%2d pontos: %2d db\n&quot;, x, stat[x]);

   return 0;
}</pre>
</div>
</div>






<h3>Múzeum I.</h3>

<div class="sticky">Kis ZH volt</div>

<p>Egy múzeumban kíváncsiak arra, a hét mely napján van a legtöbb
látogató. Ehhez több hét adatait feldolgozzák.</p>

<p>Írj programot, mely a szabványos bemenetén fogadja a múzeum napi látogatási
adatait úgy, hogy soronként a hét napjának sorszámát kapjuk 0-6 között, majd
szóközzel elválasztva a látogatók számát.  Az adatok rendezetlenül érkeznek, adott sorszámú
naphoz több bejegyzés is tartozhat. A bemenet végét -1 -1 jelzi.</p>

<p>Írja ki a program a szabványos kimenetre annak a napnak a sorszámát, mely
a legtöbb látogatót jelenti. Feltételezzük, hogy egy ilyen nap van.</p>

<div class="columns">
<div>
<p>Példa bemenet:</p>
<pre class="screenshot">
1 7
2 3
6 33
5 44
4 4
6 55
-1 -1
</pre>
</div>

<div>
<p>Példa kimenet:</p>
<pre class="screenshot">
6






</pre>
</div>
</div>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
   int latogato[7]={0};
   int nap, db, max, x;

   scanf(&quot;%d %d&quot;, &amp;nap, &amp;db);
   while (nap!=-1) {
      latogato[nap]+=db;
      scanf(&quot;%d %d&quot;, &amp;nap, &amp;db);
   }

   max=0;
   for (x=1; x&lt;7; ++x)
      if (latogato[x]&gt;latogato[max])
         max=x;

   printf(&quot;%d\n&quot;, max);

   return 0;
}</pre>

</div>
</div>




<h3>Múzeum II.</h3>

<div class="sticky">Kis ZH volt</div>

<p>Egy múzeumban gazdasági okok miatt heti egy szünnapot szeretnének tartani, ezért keresik a 
hét azon napját, amikor a legkevesebb a látogató.</p>

<p>Írj programot, mely a szabványos bemenetén fogadja a múzeum napi látogatási adatait úgy, hogy 
soronként a hét napjának sorszámát kapjuk 1-7 között, majd szóközzel elválasztva a látogatók 
számát.  Az adatok rendezetlenül érkeznek, adott sorszámú naphoz több bejegyzés is tartozhat. A 
bemenet végét 0 0 jelzi.</p>

<p>Írja ki a program a szabványos kimenetre annak a napnak a sorszámát, amely a legkevesebb 
látogatót jelenti. Feltételezzük, hogy egy ilyen nap van.</p>

<div class="columns">
<div>
<p>Példa bemenet:</p>
<pre class="screenshot">
1 7
3 5
6 56
2 3
7 88
5 25
4 7
1 6
0 0
</pre>
</div>

<div>
<p>Példa kimenet:</p>
<pre class="screenshot">
2








</pre>
</div>
</div>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
   int latogato[7]= {0};
   int nap, db, min, x;

   scanf(&quot;%d %d&quot;, &amp;nap, &amp;db);
   while (nap!=0) {
      latogato[nap-1]+=db;
      scanf(&quot;%d %d&quot;, &amp;nap, &amp;db);
   }

   min=0;
   for (x=1; x&lt;7; ++x)
      if (latogato[x]&lt;latogato[min])
         min=x;
   printf(&quot;%d\n&quot;, min+1);

   return 0;
}</pre>
</div>
</div>




<h3>Kasszák I.</h3>
<div class="sticky">Kis ZH volt</div>
<p>Egy áruházban 32 kassza van, 1-től számozva. A tulajdonos nyomon szeretné követni a napi 
forgalom adatait az egyes kasszáknál. Így minden vásárláskor egy központi gépen megjelenik a 
kassza sorszáma és a fizetett összeg, szóközzel elválasztva:  <code>11 33800</code> – Ez a 11-es 
kassza, 33800 Ft. Írj olyan programot, ami beolvassa ezeket az adatokat a szabványos bemenetéről, 
és összegzi kasszánként a bevételeket! (Záráskor <code>0 0</code> számokkal zárul az aznapi 
forgalom figyelése.) Írja ki az összegzés után, melyik kasszánál mekkora volt a bevétel, és hogy 
az az összbevétel hány százaléka! Ha egy kassza az adott napon nem üzemelt, akkor az ne jelenjen 
meg.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int kassza, osszeg, i;
    int forint[32] = {0}, osszbevetel = 0;

    scanf(&quot;%d %d&quot;, &amp;kassza, &amp;osszeg);
    while (kassza!=0) {
        forint[kassza-1] += osszeg;
        osszbevetel += osszeg;
        scanf(&quot;%d %d&quot;, &amp;kassza, &amp;osszeg);
    }

    for (i=0; i&lt;32; i+=1)
        if (forint[i]!=0)
            printf(&quot;%2d. kassza, %6d Ft, %f%%.\n&quot;,
                i+1, forint[i], 100.0*forint[i]/osszbevetel);

    return 0;
}</pre>
</div>
</div>

<h3>Kasszák II.</h3>
<div class="sticky">Kis ZH volt</div>
<p>Egy áruházban 32 kassza van, 1-től számozva. A tulajdonos észrevette, hogy bizonyos 
kasszákat valamiért a vevők jobban preferálnak, és ezt szeretné megfigyelni. Minden vásárláskor 
egy központi gépen megjelenik a kassza sorszáma, amely egy 1...32 közötti egész szám. Záráskor a 
0 számmal zárul az aznapi forgalom figyelése. Írj olyan programot, ami beolvassa a kasszák 
sorszámait, és a nap végén kiírja a szabványos kimenetre annak a kasszának a sorszámát, ahol a 
legtöbb vevő járt, és azt is, hogy ez az összes vevő hány százaléka!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int kassza, max, i;
    int vasarlok[32] = {0}, osszvasarlok = 0;

    scanf(&quot;%d&quot;, &amp;kassza);
    while (kassza!=0) {
        vasarlok[kassza-1] += 1;
        osszvasarlok += 1;
        scanf(&quot;%d&quot;, &amp;kassza);
    }

    max = 0;
    for (i=1; i&lt;32; i+=1)
        if (vasarlok[i]&gt;vasarlok[max])
            max = i;

    printf(&quot;A kedvenc kassza a(z) %d-edik, &quot;
           &quot;a vasarlok %f%%-a ment oda.\n&quot;,
        max+1, 100.0*vasarlok[max]/osszvasarlok);

    return 0;
}</pre>
</div>
</div>

<h3>Kódtörő I.</h3>
<div class="sticky">Kis ZH volt</div>
<p>Bölcsész haverod, aki az angol nyelvvel foglalkozik, szeretné megvizsgálni a szavakban 
előforduló betűk gyakoriságát. Ezért megkér téged, hogy írj egy programot, amely a szabványos 
bemenetén egy angol nyelvű szöveget fogad (fájl vége jelig). A szöveg eleve nagybetűsítve van: 
„TO BE OR NOT TO BE: THAT IS THE QUESTION.” A programod feladata egy statisztikát készíteni, 
amelyben az szerepel, hogy melyik betű hányszor fordult elő a szövegben, és az összes betű hány 
százalékát adja. A kimenete ilyen:<br> <code>A: 19 db, 5.0%<br> B: 7 db, 1.8%</code> stb.<br> Ha 
valamelyik betű nem szerepelt a szövegben, az ne jelenjen meg a statisztikában se! A nem betű 
karaktereket figyelmen kívül kell hagyni.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    char c;
    int gyakorisag['Z'-'A'+1] = {0}, osszes = 0;

    while (scanf(&quot;%c&quot;, &amp;c)==1)
        if (c&gt;='A' &amp;&amp; c&lt;='Z') {
            gyakorisag[c-'A'] += 1;
            osszes += 1;
        }

    for (c='A'; c&lt;='Z'; c+=1)
        if (gyakorisag[c-'A']!=0)
            printf(&quot;%c: %d db, %f %%.\n&quot;,
                c-'A', gyakorisag[c-'A'], 100.0*gyakorisag[c-'A']/osszes);

    return 0;
}</pre>
</div>
</div>

<h3>Kódtörő II.</h3>
<div class="sticky">Kis ZH volt</div>
<p>Kódtörő haverod nagyon ért a titkosítások visszafejtéséhez, a programozással viszont 
hadilábon áll. Szerzett egy számjegyekből álló titkos kódot:
<br> 
<code>1238971125432563125555535555665554325671231321555253555</code>
<br>
Megfigyelte, hogy ebben nem egyforma a jegyek gyakorisága. Megkért téged, hogy írj egy 
programot, amely a szabványos bemenetén fogadja ezt a karaktersorozatot (fájl vége jelig), és 
megmondja, hogy melyik az a számjegy, amely a legtöbbször szerepelt, és azt is, hogy hány % a 
gyakorisága! A fenti bemenetre ez az 5-ös számjegy, 40%-kal. Ha bemeneten számjegyen kívül más 
karakter is szerepel, azt figyelmen kívül kell hagyni.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int gyakorisag[10] = {0}, osszes;
    char c;
    int max, i;

    while (scanf(&quot;%c&quot;, &amp;c)==1)
        if (c&gt;='0' &amp;&amp; c&lt;='9') {
            gyakorisag[c-'0']+=1;
            osszes += 1;
        }

    max = 0;
    for (i=1; i&lt;10; i+=1)
        if (gyakorisag[i]&gt;gyakorisag[max])
            max = i;

    printf(&quot;Leggyakoribb: %c, %f %%-kal.\n&quot;, '0'+max,
        100.0*gyakorisag[max]/osszes);

    return 0;
}</pre>
</div>
</div>

<h3>Melyik szerepel előbb?</h3>
<p>Adott egy egész értékekkel feltöltött m tömb. Készíts programot, mely a felhasználótól kért 
két számról eldönti, hogy a két szám szerepel-e a tömbben, és ha igen, akkor melyik szerepel 
előbb.</p>

<h3>Páronként</h3>
<p>Készíts programot, mely egy 50 elemű tömböt véletlen egész számokkal tölt fel 0 és 200 között.
Keress a tömbben két olyan elemet, melyekre teljesül, hogy a nagyobbik elem a kisebbik duplája! 
Keresd meg az összes ilyen párost!</p>

<h3>Átlaghoz legközelebb</h3>
<p>Írj programot, amely egy egészekből álló tömbben megkeresi azt az számot, amely
az összes szám átlagához a legközelebb van!</p>

<h3>Számjegyek tárolása tömbben</h3>
<p>Az m tíz elemű, egész számokból álló tömb egy decimális szám (x) számjegyeit tartalmazza 
helyiérték szerint csökkenő sorrendben. Készíts programot, mely
<br>
a.) kiszámítja az így ábrázolt szám (x) értékét!
<br>
b.) előállítja m-ben az eredetinél egyel nagyobb szám (x+1) ugyanilyen ábrázolását, illetve 
közölje, ha volt túlcsordulás!</p>

<h3>„Írásbeli összeadás”</h3>
<p>Az <code>m</code>, <code>k</code> két tíz elemű, egész számokból álló tömb egy-egy decimális 
szám (x,y) számjegyeit tartalmazza helyiérték szerint csökkenő sorrendben. Készíts programot, 
mely kiszámítja az így ábrázolt két szám összegét (x+y) és az eredményt x-be ugyanilyen 
ábrázolásban visszatárolja, illetve közölje, ha volt túlcsordulás!</p>

<h3>Összegzés</h3>

<p>Adott két n elemszámú, egészekből álló tömb (<code>m[]</code> és 
<code>b[]</code>). Az <code>m[]</code> tömb véletlen elemekkel van feltöltve. 
Készíts programot, amely <code>b[]</code> tömb elemeit feltölti úgy, hogy minden 
<code>b[i]</code> értéke az <code>m[]</code> tömb első <code>i+1</code> elemének 
összege legyen. Például <code>b[2]=m[0]+m[1]+m[2]</code>. Határozd meg egy 
ugyanilyen programmal, hogy az év hónapjainak első napjai (január 1., február 1. 
stb.) az év hányadik napjai!</p>


<h3>Egyforma elemek</h3>
<p>Írj programot, amely egy adott (előre feltöltött vagy billentyűzetről beolvasott)
tömböt vizsgálva kiírja azon elempárok indexeit, amelyek egyformák!
Vajon hány összehasonlítás kell ehhez, ha <code>n</code> a tömb elemszáma?</p>
<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Nem kell <code>n<sup>2</sup></code>, csak <code>n(n-1)/2</code> összehasonlítás,
mivel minden párt elég csak egyszer megvizsgálni (ha <code>a=b</code>, akkor <code>b=a</code>
is igaz). Ez látszik a programon is: a külső (<code>i</code>-s) ciklus végigmegy
az összes elemen, a belső (<code>j</code>-s) ciklus pedig minden <code>i</code>-nél
már csak az „összes többit” nézi, <code>i+1</code>-től indul. A külső ciklus
nem is megy el az utolsó elemig, hanem az utolsó előtti elem indexe a legvégső,
aminél lefut, mert az utolsó elemnél már nem is lenne „összes többi”. Tehát a <code>10</code>
elemű, <code>0&hellip;9</code> indexelő tömbre <code>i</code> <code>0</code>-tól <code>8</code>-ig,
<code>j</code> pedig <code>i+1</code>-től <code>9</code>-ig fut.</p>
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int szamok[10] = { 4, 6, 8, 9, 4, 5, 6, 7, 3, 8 };
    int i, j;
    
    printf(&quot;Egyformak:\n&quot;);
    for (i = 0; i &lt; 10-1; i += 1)
        for (j = i+1; j &lt; 10; j += 1)
            if (szamok[i] == szamok[j])
                printf(&quot;szamok[%d] == szamok[%d] == %d\n&quot;, i, j, szamok[i]);
    
    return 0;
}</pre>
</div>
</div>

<h3>Mind különböző?</h3>
<p>Írj programot, amely egy adott (előre feltöltött vagy billentyűzetről beolvasott)
tömbről megmondja, hogy minden eleme különböző-e!</p>
<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Tipp</a></h4>
<div class="megjelenik csik">
<p>Mit kell találni a tömbben ahhoz, hogy tudjuk, nem minden elem különböző?
Lásd az előző feladatot!</p>
</div>
</div>

<h3>Emeletes ház (Dinesman feladata)</h3>
<p>Baker, Cooper, Fletcher, Miller és Smith egy ötemeletes ház különböző 
emeletein laknak. Baker nem a legfölső emeleten lakik, Cooper pedig nem az alsó 
szinten. Fletcher lakhelye sem a legalsó szinten van, de nem is a legfölsőn. 
Miller magasabban lakik, mint Cooper. Smith nem Fletcherrel szomszédos emeleten 
lakik, ahogy Cooper és Fletcher sem emelet-szomszédok.</p> <p>A kérdés: melyik 
emelet kié?</p>
<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Tipp</a></h4>
<div class="megjelenik csik">
<p>Az, hogy különböző emeleteken laknak, csak egy feltétel a sok közül. Próbáld
végig programban az összes lehetőséget! A „különböző emeletek” feltétel ellenőrzését
úgy is megoldhatod, hogy beteszed az öt változót egy tömbbe, és megnézed, mind
különbözőek-e az elemei. Lásd az előző feladatot.</p>
</div>
</div>





</div>
</section>
<section id="6">
<div class="slide" id="slide_6">
<div class="slideheader">
<h2><span class="oldalszam">6</span>Véletlenszámok, játékok</h2>
</div>

<h3>Egyenletes eloszlású véletlenszámok</h3>
<p>Írj egy programot, amelyik 0 és 99 között generál egy egyenletes eloszlású véletlen számot 
a szabványos <code>rand()</code> segítségével! (A modulós módszerrel generáltak nem teljesen egyenletes 
eloszlásúak. Pl. ha egy C fordítónál a <code>RAND_MAX</code> értéke 32767, akkor a <code>rand()%100</code>
kifejezés kicsit gyakrabban ad 67-nél kisebb számot, mint nagyobbat.)</p>





<h3>Fej vagy írás</h3>
<p>Adott egy feladat: „dobjunk fel egy pénzt” a C programunkban, és írjuk ki, hogy fej vagy írás lett.
Ennek a feladatnak az alábbi megoldása helytelen:</p>
<pre class="brush: c "  >
if (rand() % 2 == 0)
    printf(&quot;Fej.\n&quot;);
if (rand() % 2 == 1)
    printf(&quot;Iras.\n&quot;);</pre>
<p>A kipróbálás nélkül mondd meg: milyen hibás eredményt adhat ez a program, és milyen elvi hiba miatt?
Ha megvan, próbáld ki, és végül javítsd ki a programot!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>A <code>rand()</code> minden hívása egy <em>új</em> véletlenszámot ad. A fenti, hibás kódrészletben
a <code>rand()</code>-ot kétszer hívjuk meg, tehát tulajdonképpen mintha nem egy, hanem két pénzérmét
vizsgálnánk: ha az első fej, kiírjuk hogy fej, ha a második írás, kiírjuk, hogy írás. Így aztán az is
lehet, hogy mindkét szó kiíródik, de az is, hogy egyik sem. Javítva:</p>
<pre class="brush: c "  >
if (rand() % 2 == 0)
    printf(&quot;Fej.\n&quot;);
else
    printf(&quot;Iras.\n&quot;);</pre>
</div>
</div>



<h3>Kő, papír, olló</h3>
<pre class="screenshot float">
Kő (k), papír (p), olló (o) vagy vége (v)?

Szerinted: k
Szerintem: k.
Senki nem kap pontot.

Szerinted: p
Szerintem: k.
p&gt;k, ezt te vitted!

Szerinted: v

Te nyertél, 1&gt;0 ponttal.
</pre>
<p>Írj programot, amelyik „kő, papír, olló” játékot játszik! A program először kérje el a 
felhasználó tippjét (<code>k</code>, <code>p</code>, <code>o</code> betűk, mint kő, papír, olló).
Ezután válasszon ő maga is egyet, és hasonlítsa a kettőt össze! A kő erősebb, mint az olló, 
mert kicsorbítja. A papír erősebb, mint a kő, mert becsomagolja. Az olló erősebb, mint a papír, 
mert elvágja. Ezek alapján a gép vagy a játékos kapjon egy pontot! Ha egyformát tippeltek, akkor 
semelyikük nem kap. A <code>v</code> beírása után írja ki a program, hogy ki nyert!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Tipp</a></h4>
<div class="megjelenik csik">
<p>A gépnek háromféle választása lehet. Ehhez egy véletlenszámot kell sorsolni, amely a 0, 1 vagy
2 értékeket veheti fel. (A 3-mal osztás maradékát figyelve éppen ilyen szám áll elő.)</p>
<p>A véletlenszám sorsolása után érdemes a 0, 1 és 2 értékeket a programban a <code>k</code>,
<code>p</code>, <code>o</code> karakterekre cserélni, hogy egységes legyen azzal, amit
a felhasználó beírt. Ez javítja a programkód érthetőségét.</p>
<p>Amikor karaktert kell beolvasni, a feladattól függően
érdemes a <code>scanf()</code>-et <code>scanf("%c", &amp;betu)</code> helyett
<code>scanf(" %c", &amp;betu)</code> formában használni, azaz tenni egy szóközt
a <code>%c</code> elé. Ennek hatására a <code>scanf()</code> eldobja a kapott
szóköz és újsor (enter) karaktereket, és megvárja az első nem szóközt.
Erre azért van szükség, mert karakterek beolvasásánál alapértelmezés
szerint megkapjuk a felhasználó által leütött entereket is.</p>
</div>
</div>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main(void) {
    int jatekospont, geppont;
    char jatekostipp, geptipp;
    
    /* pontszámok nullázása és üdvözlés*/
    jatekospont = geppont = 0;
    srand(time(0));
    printf(&quot;Kő (k), papír (p), olló (o) vagy vége (v)?\n&quot;);
    
    /* az első tipp a játékostól */
    printf(&quot;\nSzerinted: &quot;);
    scanf(&quot; %c&quot;, &amp;jatekostipp);
    
    /* végjeles sorozat - a 'v' karakter jelzi a végét */
    while (jatekostipp != 'v') {
        /* tippel a gép is: 0, 1 vagy 2 véletlenszám. */
        int geptipp_i = rand() % 3;
        /* karakterré alakítjuk: 0-&gt;olló, 1-&gt;papír, 2-&gt;kő. */
        /* hogy melyikből mi lesz, az mindegy. */
        if (geptipp_i == 0)
            geptipp = 'o';
        else if (geptipp_i == 1)
            geptipp = 'p';
        else
            geptipp = 'k';
        printf(&quot;Szerintem: %c.\n&quot;, geptipp);

        /* összehasonlítás és pontozás */
        if ((jatekostipp == 'k' &amp;&amp; geptipp == 'o')        /* kő veri az ollót */
            || (jatekostipp == 'p' &amp;&amp; geptipp == 'k')     /* papír veri a követ */
            || (jatekostipp == 'o' &amp;&amp; geptipp == 'p')) {  /* olló veri a papírt */
            ++jatekospont;
            printf(&quot;%c&gt;%c, ezt te vitted!\n&quot;, jatekostipp, geptipp);
        }
        else if ((geptipp == 'k' &amp;&amp; jatekostipp == 'o')   /* kő veri az ollót */
            || (geptipp == 'p' &amp;&amp; jatekostipp == 'k')     /* papír veri a követ */
            || (geptipp == 'o' &amp;&amp; jatekostipp == 'p')) {  /* olló veri a papírt */
            ++geppont;
            printf(&quot;%c&lt;%c, ezt én vittem!\n&quot;, jatekostipp, geptipp);
        }
        else
            printf(&quot;Senki nem kap pontot.\n&quot;);

        /* a következő tipp a játékostól */
        printf(&quot;\nSzerinted: &quot;);
        /* a karakter beolvasása előtt a scanf() egy szóközt kap.
         * ez azt jelenti, hogy a beolvasott szóközöket és újsor
         * karaktereket dobja el, és várjon tovább betűre. */
        scanf(&quot; %c&quot;, &amp;jatekostipp);
    }
    
    /* végeredmény */
    printf(&quot;\n&quot;);
    if (jatekospont &gt; geppont)
        printf(&quot;Te nyertél, %d&gt;%d ponttal.\n&quot;, jatekospont, geppont);
    else if (jatekospont &lt; geppont)
        printf(&quot;Én nyertem, %d&gt;%d ponttal.\n&quot;, geppont, jatekospont);
    else
        printf(&quot;A játék döntetlen, mindkettőnknek %d pontja lett.\n&quot;, jatekospont);
    
    return 0;
}</pre>
</div>
</div>


<h3>Memóriajáték</h3>
<p>Memóriajátékot írunk. 6x6 kártya van lefordítva a játékosok előtt, 18 
pár, amelyek egyformák. A kártyákon betűk vannak, A, B, C, ...  Írj egy 
programot, amelyik generál egy véletlenszerű leosztást! Természetesen egy betűnek
pontosan kétszer kell szerepelnie (egy pár)!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Tipp</a></h4>
<div class="megjelenik csik">
<p>Ehhez érdemes előbb a tömböt úgy feltölteni, hogy sorrendben
szerepelnek benne a kártyák, és utána összekeverni. Úgy nem kell mindig vizsgálni,
hogy minden kártya pontosan kétszer szerepel-e benne.
A tömb megkeveréséhez minden elemet cserélj meg egy véletlenedikkel!
<code>for(…tömbelemek…)</code> – valahogy így.</p>
</div>
</div>





<h3>Sorbarakó játék</h3>
<pre class="screenshot float">
    1    2    3    4    5    6
  145   12    5   77  100   44

1. felcserelendo = 3
2. felcserelendo = 1
    1    2    3    4    5    6
    5   12  145   77  100   44
</pre>

<p>Írj C programot, amely a felhasználótól bekért egész számokkal feltölt
egy hatelemű tömböt! A program ezután keverje össze véletlenszerűen a
számokat, majd írja ki ezeket az oldalt látható módon.</p>

<pre class="screenshot float">
    1    2    3    4    5    6
    5   12   44   77  100  145

Gratulalok, nyertel!
</pre>

<p>A program ezután kérjen a felhasználótól két 1 és 6 közötti 
sorszámot, majd a program cserélje fel az ezekhez a sorszámokhoz 
tartozó értékeket, és írja ki ismét a számokat. Mindaddig ismételje 
a sorszámok bekérését és a cserét, míg a felhasználó nem rakta 
növekvő sorrendbe a számokat. Ha a felhasználó nem 1 és 6 közötti 
értékeket ad meg, adjon hibaüzenetet!</p>


<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main(void) {
    int tomb[6],i,csere,rnd;
    int sorban,cs1,cs2;

    srand(time(0));  /* Véletlengenerátor inicializálása */

    /* 6 szám bekérése a tömbbe */
    for (i=0; i&lt;6; i++){
        printf(&quot;%d. szam: &quot;,i+1);
        scanf(&quot;%d&quot;,&amp;tomb[i]);
    }

    /* Elemek véletlen rendezése */
    for (i=0; i&lt;6; i++){
        rnd=rand()%6;  /* Generálunk egy véletlenszámot */
        /* Csere 3 lépésben */
        csere=tomb[i];  /* i. elem elmentése */
        tomb[i]=tomb[rnd];  /* i. elem felülírása */
        tomb[rnd]=csere;  /* rnd. elem helyére az elmentett elem */
    }

    /* Tömb kiírása */
    for (i=0; i&lt;6; i++) printf(&quot;%4d &quot;,i+1);
    printf(&quot;\n&quot;);
    for (i=0; i&lt;6; i++) printf(&quot;%4d &quot;,tomb[i]);
    printf(&quot;\n&quot;);

    /* Rendezetség ellenőrzése */
    sorban=1;  /* Tegyük fel hogy sorba van rendezve */
    /* Ha van két elem ami rossz sorrendben van akkor már nincs rendezve */
    for (i=0; i&lt;5; i++)
        if (tomb[i]&gt;tomb[i+1])
            sorban=0;

    /* Ciklus amíg rossz a sorrend */
    while (sorban==0) {
        /* Bekérünk két indexet */
        printf(&quot;1. cserelendo: &quot;); scanf(&quot;%d&quot;,&amp;cs1);
        printf(&quot;2. cserelendo: &quot;); scanf(&quot;%d&quot;,&amp;cs2);
        /* Ellenőrizzük a határokat */
        if (cs1!=cs2 &amp;&amp; cs1&gt;=1 &amp;&amp; cs2&gt;=1 &amp;&amp; cs1&lt;=6 &amp;&amp; cs2&lt;=6){
            /* 3 lépéses csere */
            /* Az indexekből 1-et ki kell vonni: 1..6 -&gt; 0..5 */
            csere=tomb[cs1-1];
            tomb[cs1-1]=tomb[cs2-1];
            tomb[cs2-1]=csere;
        }
        else
            printf(&quot;Hibas indexek!\n&quot;);

        /* Tömb kiírása */
        for (i=0; i&lt;6; i++)
            printf(&quot;%4d &quot;,i+1);
        printf(&quot;\n&quot;);
        for (i=0; i&lt;6; i++)
            printf(&quot;%4d &quot;,tomb[i]);
        printf(&quot;\n&quot;);

        /* Rendezettség ellenőrzése */
        sorban=1;
        for (i=0; i&lt;5; i++)
            if (tomb[i]&gt;tomb[i+1])
                sorban=0;
    }

    /* Ha vége a ciklusnak akkor győzelem */
    printf(&quot;Gratulalok, nyertel!&quot;);

    return 0;
}</pre>
</div>
</div>



<h3>Master Mind</h3>
<p>A Master Mind játékban egyik játékos kitalál egy feladványt, amely
4 tüskéből áll. A tüskék 6-féle színűek lehetnek. Lehetséges az is,
hogy két vagy több tüske ugyanolyan színű, pl. piros, piros, zöld, kék.
A másik játékos ezután megtippeli,
mire gondolhatott az első. Az előbbi minden körben aképpen segít kitalálni
a feladványt, hogy elárulja, a tippben hány olyan tüske van, amely a megfelelő
színű és a megfelelő helyen is van (ezt feketékkel jelöli); és hány olyan, amely az előbbieken kívül
még jó színű, de rossz helyen van (ezt pedig fehérekkel).</p>


<p>Pl.
feladvány: <span class="mastermind"><span style="color: red">oo</span><span style="color: yellow">o</span><span style="color: green">o</span></span>,
tipp: <span class="mastermind"><span style="color: green">o</span><span style="color: red">o</span><span style="color: blue">o</span><span style="color: yellow">o</span></span>,
segítség: <span class="mastermind"><span style="color: black">o</span><span style="color: #eee">oo</span></span> (a második piros, illetve a zöld és a sárga miatt).</p>

<p>Írj programot, amely feladványt ad a felhasználónak, és a leírt
szabályok alapján segít neki kitalálni azt! A hat színt jelöld a programban
az <code>a…f</code> betűkkel.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Tipp</a></h4>
<div class="megjelenik csik">
<p>Miután a felhasználó megadta a tippjét, a program használhat olyan algoritmust, amely
hatására ez a beírt tipp elfelejtődik. Először a pozíció szerint is stimmelő tüskéket
érdemes keresni, és az így megtalált egyezések a tömbből törölhetőek, hogy a második,
pozíciót figyelembe már nem vevő keresés ne találja meg azokat újra.</p>
<p>Karakterek beolvasásával kapcsolatban lásd a fentebbi megjegyzéseket (pl. a kő, papír, olló
játéknál.)</p>
</div>
</div>

</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="f03.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="index.html"><img src="modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="index.html">főoldal</a> · <a href="elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
