<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: 4. hét: számábrázolás, bitek, függvények</title>
<meta property="og:title" content="InfoC :: 4. hét: számábrázolás, bitek, függvények">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="Gyakorlófeladatok a 4. előadás anyagához kapcsolódóan.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="Gyakorlófeladatok a 4. előadás anyagához kapcsolódóan.">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="modulz/logo_touch.png">
<link rel="image_src" href="modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<script>infoc.onloads.push(function(){ h3toid(); });
</script>
<link rel="stylesheet" href="modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="modulz/style/localfonts.css@v10.css">
<script src="modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="index.html">InfoC</a></div>
<ul>
<li class="al "><a href="f04.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="index.html">Kezdőlap</a>
<li><a href="nhf.html">Nagy házi feladat</a>
<li><a href="elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="f04.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="f04.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="ea01.html">1. hét: bevezetés</a>
<li><a href="ea02.html">2. hét: algoritmusok</a>
<li><a href="ea03.html">3. hét: tételek, tömbök</a>
<li><a href="ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="ea09.html">9. hét: láncolt listák</a>
<li><a href="ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="ea12.html">12. hét: bináris fák</a>
<li><a href="ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="f04.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="gy02.html">2. hét: algoritmizálás</a>
<li><a href="gy03.html">3. hét: egyszerű programok</a>
<li><a href="gy04.html">4. hét: tételek és tömbök</a>
<li><a href="gy05.html">5. hét: függvények</a>
<li><a href="gy06.html">6. hét: származtatott típusok</a>
<li><a href="gy07.html">7. hét: mutatók használata</a>
<li><a href="gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="gy11.html">11. hét: láncolt listák I.</a>
<li><a href="gy12.html">12. hét: láncolt listák II.</a>
<li><a href="gy13.html">13. hét: bináris fák</a>
<li><a href="gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="f04.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="lab01.html">1. hét: operációs rendszer</a>
<li><a href="lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="lab03.html">3. hét: egyszerű programok</a>
<li><a href="lab04.html">4. hét: tömbök</a>
<li><a href="lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="lab11.html">11. hét: láncolt listák</a>
<li><a href="lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="lab13.html">13. hét: bináris fák</a>
<li><a href="lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="f04.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="f01.html">1. hét: egyszerű programok</a>
<li><a href="f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="f09.html">9. hét: láncolt listák</a>
<li><a href="f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="f04.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="jegyzet.html">Jegyzet és puska</a>
<li><a href="fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="stilus.html">Kódolási stílus</a>
<li><a href="tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="debugmalloc.html">Debugmalloc</a>
<li><a href="mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="f04.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="f04.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="orak.html">SVG óra galéria</a>
<li><a href="angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="f04.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="turing.html">Mit tud a számítógép?</a>
<li><a href="bf.html">BF</a>
<li><a href="bitturmix.html">Bitturmix</a>
<li><a href="labirintus.html">Labirintusok</a>
<li><a href="tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="f04.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="karakterkodolas.html">Karakterkódolások</a>
<li><a href="strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="internet.html">Internet</a>
</ul>

<li class="al "><a href="f04.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="sdl.html">SDL grafika</a>
<li><a href="sdl_telepito.html">SDL telepítés</a>
<li><a href="fa.html">Fák rajzolása</a>
<li><a href="lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="f04.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="mondatelemzo.html">Mondatelemző</a>
<li><a href="kifejezesek.html">Kifejezések</a>
<li><a href="derivalas.html">Deriválás</a>
<li><a href="ast_epit.html">AST: szintaxisfák</a>
<li><a href="ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<a id="feladatbit" class="namer"></a>
<h1 class="eloadascim">4. hét: számábrázolás, bitek, függvények</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán, Nagy Gergely, Pohl László · <i class="ido"></i> 2015.02.18 · Frissítve: 2015.02.15</p>
<p class="kivonat">Gyakorlófeladatok a 4. előadás anyagához kapcsolódóan.</p>
</div>


<p>Ezen az oldalon rengeteg feladat található a gyakorláshoz. Egy részük megoldással együtt, míg 
a többi anélkül. A gyakorlófeladatok megoldásához elvileg elegendő az az ismeretanyag, amely az előadáson 
szerepelt. Természetesen a megoldás kitalálásához szükség lehet arra a rálátásra és 
tapasztalatra, amit a gyakorlatok és a laborok adnak. A feladatok témakörök szerinti 
csoportosítása viszont ettől függetlenül az előadást követi.</p>

<p>Felhívjuk a figyelmed arra, hogy a megoldások olvasgatása lényegében nulla 
tapasztalatot és gyakorlatot ad, így az eredményes számonkérésekhez nem tud hozzásegíteni! A 
megoldásokat akkor nézd csak meg, ha a saját megoldás elkészítése közben elakadsz.
Lásd <a href="tanacsok.html">itt</a>.</p>


<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="f04.html#1">Függvények</a>
<li><a href="f04.html#2">Számrendszerek, bitműveletek</a>
<li><a href="f04.html#3">Számábrázolási problémák</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>Függvények</h2>
</div>

<h3>Előjelek</h3>
<p>Készíts függvényt, amelyik megadja két számról, hogy egyezik-e az előjelük!</p>


<h3>Szökőév</h3>
<p>Készíts függvényt, amelyik adott évszámról eldönti, hogy az szökőév-e. 
(Szökőév minden negyedik, nem szökőév minden századik, mégis az minden 
400-adik. A 2000. évben ezért volt szökőév.)</p>




<h3>Sakktábla</h3>
<p>Írj függvényeket, amelyek paraméterei két koordinátapár, amelyek egy mezőre hivatkoznak a 
sakktáblán! (Ez lehet négy karakter is, pl. <code>d6</code> és <code>e8</code>.) Az egyes 
függvények mondják meg a logikai típusú visszatérési értékükben, hogy az adott mezőpár helyes 
lépés-e egy királynak, bástyának, futónak, huszárnak vagy vezérnek!</p>
<p>Írj programot, amely megkérdezi egy kiinduló mezőnek a koordinátáit a felhasználótól, és 
aztán kilistázza az egyes figurák által elérhető mezőket!</p>
<p>A függvények segítségével „sormintamentessé” tehető a program. Hasonlítsd össze az így kapott 
programot a régebbi gyakorlófeladat anyagában található megoldással. Miben segítenek még a 
függvények?</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* a betűkre karakterként (számként) tekintek.
 * mivel ábécé sorban vannak, a számjegyek pedig növekvő
 * sorrendben, ezért kisebb/nagyobb összehasonlítást
 * végezhetek, és kivonhatom őket egymásból. */


/* igazat ad vissza, ha a megadott koordinatak nem
 * egy helyes mezot adnak (a1-&gt;h8). */
int helytelen_mezo(char o, char s) {
    return o&lt;'a' || o&gt;'h' || s&lt;'0' || s&gt;'8';
}


/* kivételes eset mindegyik figuránál, ha nem lépett
 * sehova (o1==o2 és s1==s2), hiszen az nem is lépés.
 * ha a két kapott koordinátapár ilyen, a függvény
 * igazzal tér vissza. */
int mozdulatlan(char o1, char s1, char o2, char s2) {
    return o1==o2 &amp;&amp; s1==s2;
}


/* a király egyet léphet valamelyik irányba. ez
 * azt jelenti, hogy a sor- és az oszlopugrás
 * távolságának abszolút értéke maximum egy, de
 * az nem helyes lépés számára, ha mozdulatlan marad. */
int kiralynak(char o1, char s1, char o2, char s2) {
    return abs(o1-o2)&lt;=1 &amp;&amp; abs(s1-s2)&lt;=1 &amp;&amp; !mozdulatlan(o1, o2, s1, s2);
}


/* a ló nehéznek tűnik, de nem az. az L alak
 * azt jelenti, hogy a vízszintes elmozdulás 1,
 * a függőleges 2, vagy fordítva. itt a képlet
 * kizárja a mozdulatlanságot. */
int huszarnak(char o1, char s1, char o2, char s2) {
    return (abs(o1-o2)==2 &amp;&amp; abs(s1-s2)==1) || (abs(o1-o2)==1 &amp;&amp; abs(s1-s2)==2);
}


/* a bástyánál az oszlop- vagy a sor változatlan.
 * de mindkettő nem lehet ugyanaz, azaz nem lehet
 * mozdulatlan a figura, mert az nem lépés. */
int bastyanak(char o1, char s1, char o2, char s2) {
    return (o1==o2 || s1==s2) &amp;&amp; !mozdulatlan(o1, s1, o2, s2);
}


/* a futónál mindkét irányba ugyanannyit kell
 * mozdulni, úgy jön ki az átlós lépés. */
int futonak(char o1, char s1, char o2, char s2) {
    return abs(o1-o2)==abs(s1-s2) &amp;&amp; !mozdulatlan(o1, s1, o2, s2);
}


/* a királynő mint a bástya és a futó együtt. */
int vezernek(char o1, char s1, char o2, char s2) {
    return bastyanak(o1, s1, o2, s2) || futonak(o1, s1, o2, s2);
}


int main(void) {
    /* a kapott mezők koordinátái */
    char o1, s1, o2, s2;

    /* megkérdezzük a felhasználót. */
    /* a scanf-nél a szóközök elnyelik a whitespace karaktereket. */
    printf(&quot;Írd be az első mezőt, pl. d6!\n? &quot;);
    scanf(&quot; %c %c&quot;, &amp;o1, &amp;s1);
    printf(&quot;Írd be a második mezőt, pl. f8!\n? &quot;);
    scanf(&quot; %c %c&quot;, &amp;o2, &amp;s2);

    if (helytelen_mezo(o1, s1) || helytelen_mezo(o2, s2)) {
        printf(&quot;Hibás sor- vagy oszlopmegadás!\n&quot;);
    } else {
        if (kiralynak(o1, s1, o2, s2)) {
           printf(&quot;Ez szabályos a király számára.\n&quot;);
        }
        if (huszarnak(o1, s1, o2, s2)) {
            printf(&quot;Huszár számára szabályos.\n&quot;);
        }
        if (bastyanak(o1, s1, o2, s2)) {
            printf(&quot;Egy bástya léphet így.\n&quot;);
        }
        if (futonak(o1, s1, o2, s2)) {
            printf(&quot;Egy futó számára ez helyes lépés lehet.\n&quot;);
        }
        if (vezernek(o1, s1, o2, s2)) {
            printf(&quot;A vezér léphet ilyet.\n&quot;);
        }
    }

    return 0;
}</pre>

</div>
</div>



<h3>Armstrong-számok</h3>
<p>Írj függvényt, amely megmondja egy számról, hogy hány számjegyű!</p>
<p>Írj függvényt, amely hatványozást végez egész számokon!</p>
<p>Készíts programot, mely Armstrong-számokat keres, és a találatkat megjeleníti a képernyőn! 
N-jegyű Armstrong számoknak nevezzük azokat a számokat, melyek számjegyei N-dik hatványainak 
összege éppen a számot adja. Például: egy négyjegyű Armstrong-szám a 1634, mivel: 
1634=1<sup>4</sup>+6<sup>4</sup>+3<sup>4</sup>+4<sup>4</sup>




</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<a id="bitmuveletek" class="namer"></a>
<div class="slideheader">
<h2><span class="oldalszam">2</span>Számrendszerek, bitműveletek</h2>
</div>




<h3>Mennyi?</h3>

<div class="sticky">Kis ZH-ban voltak</div>

<p>Mennyi 27|13? Írd le mindkét számot, valamint az eredményt is kettes
számrendszerben! Az eredményt tízes számrendszerben is add meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre>
  27 = 11011
 |13 = 01101
------------
  31 = 11111
</pre>
</div>
</div>

<p>Mennyi 45&amp;57? Írd le mindkét számot, valamint az eredményt is kettes
 számrendszerben! Az eredményt tízes számrendszerben is add meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre>
 45 = 101101
&amp;57 = 111001
------------
 41 = 101001
</pre>
</div>
</div>

<p>Mennyi 27^13? Írd le mindkét számot, valamint az eredményt is kettes számrendszerben! Az 
eredményt tízes számrendszerben is add meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre>
 27 = 11011
^13 = 01101
-----------
 22 = 10110
</pre>
</div>
</div>

<p>Mennyi (~20) &amp; 13? Írd le mindkét számot, valamint az eredményt is kettes 
számrendszerben! Az eredményt tízes számrendszerben is add meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre>
 20  = 00010100
~20  = 11101011
&amp;13  = 00001101
---------------
   9 = 00001001
</pre>
</div>
</div>

<p>Mennyi 0x2A | 0x82? Írd le mindkét számot, valamint az eredményt is kettes 
számrendszerben! Az eredményt tizenhatos számrendszerben is add meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre>
 0x2A = 00101010
|0x82 = 10000010
----------------
 0xAA = 10101010
</pre>
</div>
</div>

<p>Mennyi 20|13? Írd le mindkét számot, valamint az eredményt is kettes számrendszerben! Az 
eredményt tízes számrendszerben is add meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre>
 20 = 10100
|13 = 01101
-----------
 29 = 11101
</pre>
</div>
</div>
 
<p>Mennyi 42&amp;54? Írd le mindkét számot, valamint az eredményt is kettes számrendszerben! Az 
eredményt tízes számrendszerben is add meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre>
 42 = 101010
&amp;54 = 110110
------------
 34 = 100010
</pre>
</div>
</div>


<p>Mennyi 0x2A ^ 0x36? Írd le mindkét számot, valamint az eredményt is kettes számrendszerben! 
Az eredményt tizenhatos számrendszerben is add meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre>
 0x2A = 101010
^0x36 = 110110
--------------
 0x1C = 011100
</pre>
</div>
</div>


<p>Mennyi (~22) &amp; 10? Írd le 22-t, ~22-t és 10-et, valamint az eredményt is kettes 
számrendszerben!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre>
 22 = 010110
~22 = 101001
 10 = 001010
------------
  8 = 001000
</pre>
</div>
</div>



<h3>Hexadecimális</h3>
<p>Készíts programot, mely a felhasználó által megadott decimális (poz. 
egész) számot átváltja 16-os számrendszerbe (hexadecimális), és az eredményt 
kiírja a képernyőre.
<br>(Ehhez a <code>printf()</code>-fel is lehet ügyeskedni.)</p>




<h3>Igazságtábla</h3>
<p>Készíts programot, mely elkészíti az alábbi logikai függvények igazságtáblázatát, és kiírja a képernyőre:
a.) ÉS
b.) VAGY
c.) NOT
d.) NOR
e.) XOR.</p>




<h3>Bináris szám megadása</h3>
<p>Írj programot, mely bekér egy max 16 hosszú bitsorozatot karakterlánc 
formában karakterenként úgy, hogy csak 0-ás és 1-es karakterek bevitelét 
engedélyezi. A bevitel végét az enter megnyomása jelzi. Ezután írja ki az 
ilyen módon kettes számrendszerben megadott szám tízes számrendszerbeli 
alakját! (Elsőleg legnagyobb helyiértéket adja meg a felhasználó.)</p>




<h3>Egyszerű bitműveletek</h3>

<p>Írjunk programot, amelyik kér egy nemnegatív számot. Írja ki ezt a számot binárisan. Utána 
állítsa 1-be a 7.&nbsp;bitjét; állítsa 0-ba a 6.&nbsp;bitjét, és végül negálja a 0.&nbsp;bitjét. 
Írja ki az így megváltoztatott számot!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

/* A kiirast megvalosito fuggveny */
void kiir(unsigned a) {
    int n;  /* az n-- és n&gt;=0 miatt ez csak int lehet, unsigned nem! */

    for (n=7; n&gt;=0; n--)            /* 7-tol nullaig a fejlec */
        printf(&quot;%d&quot;, n);
    printf(&quot;\n&quot;);
    for (n=7; n&gt;=0; n--)            /* a kapott szam bitjei */
        printf(&quot;%d&quot;, (a &amp; 1&lt;&lt;n)?1:0);
    printf(&quot;\n&quot;);
}

int main(void) {
    unsigned x;

    printf(&quot;Kerem a szamot! &quot;);
    scanf(&quot;%u&quot;, &amp;x);
    printf(&quot;Eredeti:\n&quot;);
    kiir(x);

    /* a feladat altal eloirt muveletek */
    x=x | (1&lt;&lt;7);         /* 1-be billentjuk a 7-es bitet */
    x=x &amp; ~(1&lt;&lt;6);        /* 0-ba billentjuk a 6-os bitet */
    x=x ^ 1&lt;&lt;0;           /* negaljuk a 0-s bitet */
    printf(&quot;1-be a 7-es, 0-ba a 6-os, negalva a 0-s:\n&quot;);
    kiir(x);
    if (x &amp; 1&lt;&lt;5)
        printf(&quot;Az 5. bit egyes.\n&quot;);
    else
        printf(&quot;Az 5. bit nullas.\n&quot;);

    return 0;
}</pre>
</div>
</div>




<h3>Bitek cseréje – adott sorszámú bitek</h3>
<p>Írjunk egy függvényt, amelyik első paraméterként átvesz egy nemnegatív egész számot, és 
ennek a számnak cseréli meg két, a második és harmadik paraméterrel megadott sorszámú bitjét. Az 
így keletkező számot adja vissza a visszatérési értékében. A 0.&nbsp;bit a legkisebb 
helyiértékű.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>A lenti megoldás gondolatmenete a következő. Az <code>a_bit</code> és <code>b_bit</code> 
változókba elmentem az a. és b. helyiértéken álló számot. Ezután az eredményben mindkét helyen 
kinullázom a biteket, aztán ha az egyik helyen 1-es volt, akkor a másik helyen billentem be 
1-esbe utólag, és fordítva. Az <code>a_bit</code> és <code>b_bit</code> változókat logikai 
értéknek használom.</p>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

void kiir(unsigned a)           /* ua. fuggveny, mint a fenti kodban */ {
    int n;
    for (n=7; n&gt;=0; n--)
        printf(&quot;%d&quot;, n);
    printf(&quot;\n&quot;);
    for (n=7; n&gt;=0; n--)
        printf(&quot;%d&quot;, (a &amp; 1&lt;&lt;n)?1:0);
    printf(&quot;\n&quot;);
}

// a. es b. bitet csereli - ez a feladat megoldasa
unsigned csere(unsigned be, int a, int b) {
    /* ezeket a maszkokat vegig hasznaljuk */
    unsigned a_mask=1&lt;&lt;a;
    unsigned b_mask=1&lt;&lt;b;
    /* kivesszuk az adott bitet */
    unsigned a_bit=be &amp; a_mask;
    unsigned b_bit=be &amp; b_mask;
    unsigned eredmeny;

    /* kinullazzuk mindket helyen a biteket */
    /* a_mask|b_mask egy olyan szam, amely mindket helyen
     * 1-est tartalmaz */
    eredmeny=be &amp; ~(a_mask|b_mask);
    /* tulajdonkepp itt tortenik meg a csere.
     * ha a_bit 1-es, akkor a b helyere rakunk
     * be 1-est, es forditva. */
    if (a_bit)
        eredmeny |= b_mask;
    if (b_bit)
        eredmeny |= a_mask;
    return eredmeny;
}

int main(void) {
    kiir(23);
    kiir(csere(23, 1, 3));

    return 0;
}</pre>

<p>Másik megoldás: kiveszem a biteket, és egyből eltolom őket a 0. helyiértékre (így az 
<code>a_bit</code> és <code>b_bit</code> változók 0-t vagy 1-et tartalmaznak). Ezek után 
kinullázhatom őket az eredeti számban; és az így keletkező számhoz hozzávagyolom a biteket újra, 
de mindig a másik helyre tolva az elmentett bitet. Még elég sok különböző megoldást ki lehetne 
találni.</p>

<pre class="brush: c "  >
// a. es b. bitet csereli - egy masik lehetseges megoldas
unsigned csere(unsigned be, int a, int b) {
    /* kivesszuk az adott bitet */
    unsigned a_bit=(be &amp; 1&lt;&lt;a) &gt;&gt; a;
    unsigned b_bit=(be &amp; 1&lt;&lt;b) &gt;&gt; b;
    unsigned eredmeny;

    /* kinullazom */
    eredmeny=be &amp; ~(1&lt;&lt;a|1&lt;&lt;b);
    /* es utana vagyolok, de keresztbe */
    eredmeny|=(a_bit &lt;&lt; b) | (b_bit &lt;&lt; a);

    return eredmeny;
}</pre>
</div>
</div>




<h3>Bitek cseréje – minden egymás melletti</h3>

<p>Írj egy függvényt, amely egy 8 bites <code>unsigned char</code> típusú változó egymás melletti 
bitjeit cseréli meg! 7↔6, 5↔4 stb. Térjen vissza a függvény az így feldolgozott számmal. A 
bitenként kiíró függvény segítségével ellenőrizd az eredményt!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

/* Bitmintát kiíró függvény */
void bitminta(unsigned char c) {
    int i;             /* Adott helyiértékű bit kiírása */
    for (i=7; i&gt;=0; i--)
        printf(&quot;%c&quot;, ((c&gt;&gt;i)&amp;1) ? '1' : '0');
}

/* Szomszádos bitek cseréje */
unsigned char bitcsere(unsigned char c) {
    int i;
    /* Végigmegyünk a biteken kettesével */
    /* Kivesszük az i. és i+1. biteket */
    /* Ha nem egyeznek nem egyeznek meg, akkor mindkettőt invertáljuk */
    /*    úgy, hogy egy 3-ast (00000011) a megfelelő helyre shiftelünk, */
    /*    majd XOR kapcsolatba hozzuk az eredetivel, így az adott 2 bit */
    /*    invertálódik */
    /* Ha megegyeznek, akkor nem kell semmit csinálni */
    for (i = 0; i &lt; 8; i += 2)
        if (((c&gt;&gt;i)&amp;1) != ((c&gt;&gt;(i+1))&amp;1))
            c = c ^ (3&lt;&lt;i);
    return c;
}

int main(void){
    unsigned char c = 46;
    bitminta(c); printf(&quot;\n&quot;);
    c = bitcsere(c);
    bitminta(c); printf(&quot;\n&quot;);

    return 0;
}</pre>
</div>
</div>




<h3>Tükrözve</h3>
<p>Készíts programot, mely egy unsigned char típusú változóban tükrözi a 
biteket, vagyis a legnagyobb helyiértékű bit helyet cserél a legkisebbel (0↔7),
a második legnagyobb a második legkisebbel (1↔6) stb.</p>


<h3>Adott bitek invertálása</h3>
<p>Írj olyan <code>unsigned int invert(unsigned int x, int p, int n)</code> függvényt, 
amely az x-ben p pozíciótól kezve n bitet invertál! Például bemenet: x=10110 (binárisan), p=2, 
n=3-ra a kimenet x=01010.</p>



<h3>Páros számú 1-es bit</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely paraméterként kap egy pozitív egész számot, és logikai igazzal tér 
vissza, ha a szám páros számú 1-es bitet tartalmaz!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
int paritas(int szam) {
    int db=0;
    for (; szam!=0; szam&gt;&gt;=1)
        db += szam &amp; 1;
    return db % 2 == 0;
}</pre>
</div>
</div>




<h3>Mind a 32 bit cseréje</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely paraméterként kap egy előjel nélküli egész számot, melyről 
feltételezzük, hogy 32 bites. A függvény cserélje fel a szám összes szomszédos bitpárját (0. az 
1.-vel, 2. a 3.-kal, … 30. a 31.-kel)! A függvény ezt az értéket adja vissza!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Egy egyszerű megoldás:</p>
<pre class="brush: c "  >
unsigned csere(unsigned miben) {
    int i;
    unsigned eredmeny = 0;
    for (i = 0; i &lt; 32; i+=2) {
        if (miben &amp; 1&lt;&lt;i)
            eredmeny |= 1&lt;&lt;(i+1);
        if (miben &amp; 1&lt;&lt;(i+1))
            eredmeny |= 1&lt;&lt;i;
    }
    return eredmeny;
}</pre>

<p>Egy nagyon trükkös megoldás:</p>
<pre class="brush: c "  >
unsigned csere(unsigned szam) {
    return ((szam &amp; 0xaaaaaaaa)&gt;&gt;1) | ((szam &amp; 0x55555555)&lt;&lt;1);
}</pre>
</div>
</div>




<h3>Hány 0 értékű bit?</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely paraméterként kap egy előjel nélküli egész számot, melyről 
feltételezzük, hogy 32 bites, és visszatérési értékként adja, hogy a szám hány 0 értékű bitet 
tartalmaz!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
int nullbit(unsigned szam) {
    int db=0, i;
    for (i=0; i&lt;32; szam&gt;&gt;=1, i++)
        if ((szam &amp; 1) == 0)
            ++db;
    return db;
}</pre>
</div>
</div>




<h3>Mindkét oldalról 0</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely paraméterként kap egy előjel nélküli egész számot, melyről 
feltételezzük, hogy 32 bites! A függvény számítsa ki és adja vissza, hogy hány olyan 1-es 
bit van a számban, amelyet mindkét oldalról 0 bit határol! (Értelemszerűen a legalsó és 
legfelső bit nem lehet ilyen.) Pl. ha a bemenő bitminta 1011101000010101011001010011111, 
akkor az eredmény 6.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Ha egymás melletti három bitet vizsgálunk, akkor ehhez <code>010</code>-t kell lássunk.
A <code>szam&amp;7</code> kivág három bitet (mert 7 = 111), ahol ez a 010 (értéke: 2) kell legyen.</p>
<pre class="brush: c "  >
int egyedulallo(unsigned szam) {
    int db = 0, i;
    for (i=0; i&lt;30; i++, szam&gt;&gt;=1)
        if ((szam&amp;7) == 2) db++;
    return db;
}</pre>
</div>
</div>




<h3>Pontosan hat darab 1-es</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj C függvényt, amely paraméterként kap egy pozitív egész számot,
és logikai igazzal tér vissza, ha a szám pontosan 6 db 1-es bitet
tartalmaz!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
int hat(unsigned szam) {
    int db=0;
    for (db=0; szam!=0; szam&gt;&gt;=1)
        db += szam &amp; 1;
    return db == 6;
}</pre>
</div>
</div>


<h3>Rotálás</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj C függvényt, amely paraméterként kap két előjel nélküli
egész számot (mit, db), és mit-et db számú bittel forgatja el jobbra,
és ezt az értéket adja vissza (az előjel nélküli egészeket 32
bitesnek feltételezzük)! A jobbra forgatás azt jelenti, hogy mit
bitjei db számú bittel jobbra tolódnak, és a „kieső” bitek a szám
elejére kerülnek vissza. Pl. be:
<br>0000000011111111111110101010<strong>1010</strong> és db = 4, ki:
<br><strong>1010</strong>0000000011111111111110101010.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
/* a naív megoldás */
unsigned rotr1(unsigned mit, int db) {
    unsigned eredmeny = 0, i;
    for (i = 0; i &lt; 32; i++)
        if (mit &amp; (1 &lt;&lt; ((i + db) % 32)))
            eredmeny |= 1 &lt;&lt; i;
    return eredmeny;
}

/* a trükkös megoldás */
unsigned rotr2(unsigned mit, int db) {
    return (mit &gt;&gt; db) | (mit &lt;&lt; (32-db));
}</pre>
</div>
</div>


<h3>Egyesek egymás mellett</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely paraméterként kap egy egész számot, melyről 
feltételezzük, hogy 16 bites. A függvény logikai igazzal térjen 
vissza, ha a számban bárhol található egymás mellett két 1-es értékű 
bit, és hamissal, ha nem! Pl. 138=10001010 esetén hamis a válasz, 
154=10011010 esetén pedig igaz.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
int dupla(unsigned szam) {
    int i;
    for (i = 0; i &lt; 15; i++)
        if (((szam &gt;&gt; i) &amp; 3) == 3)
            return 1;
    return 0;
}</pre>

<p>Egy trükkös megoldás. (Ha egymás mellett két egyes van, eggyel léptetve
azok át fogják fedni egymást. Az így kapott számok bitenkénti ÉS-elve
ezért nem nullát adnak.)</p>

<pre class="brush: c "  >
int dupla(unsigned szam) {
    return (szam &amp; (szam &lt;&lt; 1)) != 0;
}</pre>
</div>
</div>




<h3>Bitsorozat kivágása</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely paraméterként kap három egész számot (szam,
honnan, db)! A függvény vegye ki a szam jobbról honnan sorszámú, db
számú bitet tartalmazó tartományát, és ezt adja vissza egész
számként! Pl. Be: 471, 3, 5 &rarr; 471=11<strong>10101</strong>11 &rarr; 10101=21, tehát ki:
21.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<pre class="brush: c "  >
unsigned kivesz2(unsigned szam, int honnan, int db) {
    unsigned temp = 0, tolt = szam &gt;&gt; (honnan - 1);
    int i;
    for (i = 0; i &lt; db; i++)
        temp |= tolt &amp; (1 &lt;&lt; i);
    return temp;
}</pre>

<p>Pohl László trükkös megoldása az alábbi. (A temp az alsó helyiértékein már a kivágandó biteket
tartalmazza. Ebből eldobva az alsó db darabot, invertálva saját magával, az összes
többi 1-es eltűnik.)</p>

<pre class="brush: c "  >
int temp = szam &gt;&gt; (honnan-1);
return temp ^ (temp &gt;&gt; db &lt;&lt; db);</pre>

<p>Benedek Zsófia ötlete. (Balra csúsztatva a felső bitek dobhatóak el (aztán vissza), jobbra csúsztatva
az alsók. Ez 32 bitesen működik. A két jobbra shift egyébként összevonható.)</p>

<pre class="brush: c "  >
return (szam&lt;&lt;(32-(honnan-1)-db)&gt;&gt;(32-(honnan-1)-db))) &gt;&gt; (honnan-1);</pre>

<p>Estók Dániel megoldása. (0 = csupa 0, ~0 = csupa 1, ~0&lt;&lt;db = csupa 1, de alul
db darab 0, ~(~0&lt;&lt;db) = csupa 0, de alul db darab 1-es, és ez pont a maszk, ami kell.)</p>

<pre class="brush: c "  >
return (szam&gt;&gt;(honnan-1)) &amp; ~(~0 &lt;&lt; db);</pre>

<p>Abonyi József megoldása. (1&lt;&lt;db a fenti maszknál pont eggyel nagyobb szám, ami ráadásul
pont kettő hatványa. Ezzel modulózva kivághatók az alsó bitek.)</p>

<pre class="brush: c "  >
return (szam&gt;&gt;(honnan-1)) % (1&lt;&lt;db);</pre>

</div>
</div>




<h3>Bitek cseréje – bármekkora változóra</h3>
<div class="sticky">Vizsga volt</div>
<p>Készíts egy olyan szabványos ANSI C függvényt, amely paraméterként kap egy előjel nélküli 
egész számot, és visszaad szintén egy előjel nélküli egész számot! A visszaadott szám úgy 
keletkezik, hogy a paraméterként átvett számban megcseréli a szomszédos bitpárokat. Nem tudjuk, 
hogy az adott gépen hány bites az egész, de biztosan páros bitszámú. Pl. be:
25&nbsp;→&nbsp;011001, ki: 100110&nbsp;→&nbsp;38.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Itt a 0. bittől érdemes haladni. Két dologra kell figyelni:</p>
<ul>
    <li>Mindig az i. és az i+1. bitet cseréljük; utána i-t 2-vel növeljük.
    <li>És ezt addig csináljuk, amíg a számból ha levágjuk az utolsó i bitet, akkor az eredmény nem 0.
    Mert ha 0, akkor ott már nincs több 1-es, amit cserélgetni kellene – akármekkora is az int.
</ul>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

unsigned bitcsere(unsigned szam) {
    int i;

    i=0;
    while ((szam&gt;&gt;i) &gt; 0) {
        int egyik=(szam&gt;&gt;i)&amp;1;
        int masik=(szam&gt;&gt;(i+1))&amp;1;
        /* megjegyeztuk... nullazzuk ki: szam ES nulla itt ES nulla ott */
        szam=szam &amp; ~(1&lt;&lt;i) &amp; ~(1&lt;&lt;(i+1));
        /* es rakjuk be oket forditva. */
        /* szam VAGY egyik bit itt VAGY masik bit ott */
        szam=szam | egyik&lt;&lt;(i+1) | masik&lt;&lt;i;
        /* kettesevel tovabb */
        i+=2;
    }
    return szam;
}

int main(void) {
    printf(&quot;%u\n&quot;, bitcsere(25));
    printf(&quot;%u\n&quot;, bitcsere(38));

    return 0;
}</pre>

</div>
</div>




<h3>Bájtsorrend</h3>
<p>Készíts függvényt, amelyik egy 32 bites előjel nélküli szám bájtsorrendjét megfordítja. 
Például, ha a bemenet 0x11223344, a függvény kimenete legyen 0x44332211. Tételezd fel, hogy az 
unsigned int a futtató gépen 32 bites!</p>




</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>Számábrázolási problémák</h2>
</div>




<h3>Emeletes tört</h3>
<p>Írj programot, amely kiszámítja az</p>
<pre class="boxdrawing" style="line-height: 0.7;">
                       4
5 + 4 + (2 − (3 − (6 + ─)))
                       5
───────────────────────────
           3(2−7)
</pre>
<p>tört valós (tizedestört) értékét! (−0.986667-et kell kapj).</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    /* valahol, leginkább a 4/5 törtnél, szerepelnie kell
       a kifejezésben egy valós számnak. különben egész osztás történik. */
    printf(&quot;%f&quot;, (5+4+(2-(3-(6+4.0/5))))/(3*(2-7)));

    return 0;
}</pre>
</div>
</div>




<h3>Lottó 5-ös</h3>

<p>Hányféleképpen lehet n valamiből kiválasztani k valamit? Ezt a
kombinatorikában kombinációnak nevezik („<code>n</code> alatt a <code>k</code>”). A lottóban 90 szám
van, és 5-öt kell választani; a biztos 5-ös találathoz
majdnem 44 millió szelvényt kell kitölteni:

</p>
<pre class="boxdrawing" style="line-height: 0.7">
90·89·88·87·86
────────────── = 43 949 268
   1·2·3·4·5
</pre>

<p>Feladat: írd meg a programot, amely kéri a felhasználótól <code>n</code>
és <code>k</code> értékét. (A lottóban <code>n=90</code> és <code>k=5</code>.)
Ellenőrizd a program által adott eredményt! Vajon hibás a programod?
Kövesd a változók értékét a nyomkövetőben (különösen a számláló kiszámításánál),
és hasonlítsd össze azt a Számológép alkalmazásban kapottal!
</p>

<pre class="brush: c "  >
/* A nem igazán működő megoldás */
#include &lt;stdio.h&gt;

int main(void) {
    int n, k;
    int i, komb;

    printf(&quot;n=&quot;); scanf(&quot;%d&quot;, &amp;n);
    printf(&quot;k=&quot;); scanf(&quot;%d&quot;, &amp;k);

    /* 1, hogy ezt szorozgassuk tovabb */
    komb=1;
    for (i=n; i&gt;n-k; i--)
        komb=komb*i;
    /* es utana osztjuk a faktorialissal */
    for (i=1; i&lt;=k; i++)
        komb=komb/i;

    printf(&quot;Cnk=%d&quot;, komb);

    return 0;
}</pre>

<p>Miért helytelen az eredmény? Ellenőrizd
a nyomkövető segítségével a gép által végzett számítást. Miért ott
téveszti el, ahol? Az egyik fentebbi alapján, az <code>unsigned</code> típus bitjei számának
ismeretében magyarázd meg az eredményt!</p>

<p>Hogyan lehetne javítani? Megoldható úgy is, ha maradunk az egész számoknál.
Figyeld meg: <code>k=1</code> esetén a számláló csak <code>90</code>,
a nevező <code>1</code>. <code>k=2</code> esetén a számláló <code>90·89</code>,
a nevező <code>1·2</code>. A nevező miatt osztunk kettővel, de a számlálóban
a két tényező közül az egyik biztosan páros, mert <code>n·(n-1)</code> alakú.
Ugyanígy <code>k=3</code>-nál a számlálóban van egy szám, amely biztosan
osztható 3-mal. Ha a ciklusban minden szorzás után rögtön az osztást is
elvégezzük, akkor nem kell tárolnunk a <code>90·89·88·87·86</code> művelet
eredményét, hanem végig csak kisebb számokat. Írd így meg a programot!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
/* A fenti ötlettel javított megoldás */
#include &lt;stdio.h&gt;

int main(void) {
    int n, k;
    int i, komb;

    printf(&quot;n=&quot;); scanf(&quot;%d&quot;, &amp;n);
    printf(&quot;k=&quot;); scanf(&quot;%d&quot;, &amp;k);

    komb=1;
    /* szorzunk es osztunk - lasd a magyarazatot */
    for (i=1; i&lt;=k; i++) {
        komb=komb*(n+1-i);
        komb=komb/i;
    }

    printf(&quot;Cnk=%d&quot;, komb);

    return 0;
}</pre>
</div>
</div>




<h3>Gyökkettő – a gyakorlatról ismerős feladat</h3>

<p>A √<span class="felulhuzott">2</span> számjegyei egymás után, sorban meghatározhatóak
a következő módszerrel. Induljunk ki abból, hogy a gyöknek 1 és 2 között kell lennie, mivel
1<sup>2</sup>=1 és 2<sup>2</sup>=4. Az előbbi túl kicsi, az utóbbi már túl nagy, hogy
a gyök lehessen. Menjünk tovább ugyanezzel a gondolattal, és határozzuk meg a tizedesvessző utáni első
számjegyet:</p>

<table>
    <thead>
        <tr><th>Szám<th>Négyzet
    </thead>

    <tr><td>1,0<td>1,00
    <tr><td>1,1<td>1,21
    <tr><td>1,2<td>1,44
    <tr><td>1,3<td>1,69
    <tr><td>1,4<td>1,96
    <tr><td>1,5<td><strong>2,25</strong>
</table>

<p>Ebből tudjuk, hogy a gyök 1,4-gyel kezdődik. A következő számjegy:</p>

<table>
    <thead>
        <tr><th>Szám<th>Négyzet
    </thead>

    <tr><td>1,40<td>1,9600
    <tr><td>1,41<td>1,9881
    <tr><td>1,42<td><strong>2,0164</strong>
</table>

<p>Vagyis 1,41 a keresett szám eleje, és így meg lehet határozni a többit is.</p>

<ul>
    <li>Írj programot, amely a fenti algoritmussal 10<sup>&minus;10</sup> pontossággal meghatározza √<span class="felulhuzott">2</span> értékét!
    <li>Milyen típust kell ehhez használni? Meg tudod határozni a gyököt 10<sup>&minus;20</sup> pontossággal? Mi
		történik, ha megpróbálod, és miért?
    <li>Hasonlítsd össze ezt az algoritmust Hérón módszerével. Vajon melyik gyorsabb? Melyik ad kevesebb lépésből
        pontosabb megoldást?
</ul>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

double gyok(double szam) {
    double tipp, novekmeny;
    unsigned lepesszam;

    tipp = 1;
    novekmeny = 1;
    lepesszam = 0;

    do {
        do {
            tipp += novekmeny;
            ++lepesszam;
        } while (szam &gt; (tipp * tipp));

        tipp -= novekmeny;
        novekmeny /= 10;
    } while (novekmeny &gt; 1e-10);

    /* printf(&quot;Lepesszam: %d\n&quot;, lepesszam); */

    return tipp;
}

int main(void) {
    printf(&quot;2 gyoke: %.10f\n&quot;, gyok(2));

    return 0;
}</pre>
</div>
</div>




<h3>Gyökkeresés</h3>

<p>Tudjuk, hogy az x<sup>3</sup>-9x<sup>2</sup>+23x-15=0 egyenlet egy gyöke 2.2 és 4.5 között található. Írj programot, amely intervallumfelezéses módszerrel kiszámítja az egyenlet gyökét!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Tipp</a></h4>
<div class="megjelenik csik">
<p>Az intervallumfelezés módszere egy x_also és egy x_felso értékből indul ki, az ezekhez tartozó függvényértékekről tudjuk, hogy ellentétes előjelűek.
Kiszámítjuk az x_kozepe=(x_also+x_felso)/2 értéket: ha az ehhez tartozó függvényérték előjele az x_also-hoz tartozó függvényérték előjelével egyezik meg, akkor x_also=x_kozepe, egyébként x_felso=x_kozepe.
(Vagyis az x_also és x_felso távolságát felére csökkentjük úgy, hogy a gyök továbbra is a két határ között legyen.) Az eljárást addig folytatjuk, míg x_also és x_felső „elég közel” nem kerül egymáshoz (pl. epszilon=10<sup>-6</sup>). Ekkor a gyöknek x_also-t, x_felso-t, vagy az átlagukat tekinthetjük.</p>
</div>
</div>

<p>Ha sikerült kiszámítanod a gyököt, írd át a programot <code>float</code> típusra (ha eddig nem az volt), és epszilont csökkentsd 10<sup>-8</sup>-ra (C nyelven 1e-8). Mit tapasztalsz?</p>




<h3>(x-1)(x-10<sup>n</sup>)=0</h3>

<p>Írj függvényt, amely megoldja az (x-1)(x-10<sup>n</sup>)=0 egyenletet!
Ehhez alakítsd át az egyenletet x<sup>2</sup>-(1+10<sup>n</sup>)x+10<sup>n</sup>=0
alakba és az együtthatókat helyettesítsd be a megoldóképletbe. A függvény bemeneti paramétere n legyen.
Próbáld ki a függvényt n = 1, 2, 4, 8 esetekre és <code>float</code> valamint <code>double</code> típusokkal is! Figyeld meg, hogy mi történik és adj rá magyarázatot!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

void megold(int n) {
    float b,c;
     /* double b,c; */
    int i;
     /* a 10 hatványának kiszámolása */
    c=1;
    for (i=0;i&lt;n;i++)
        c*=10;
    b=-(c+1);
     /* Megoldások kiszámolása/kiírása */
    printf(&quot;x1=%f x2=%f\n&quot;,(-b+sqrt(b*b-4*c))/2,(-b-sqrt(b*b-4*c))/2);
}

int main(void) {
     /* Próba... */
    megold(1);
    megold(2);
    megold(4);
    megold(8);

    return 0;
}</pre>
</div>
</div>



</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="f04.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="index.html"><img src="modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="index.html">főoldal</a> · <a href="elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
