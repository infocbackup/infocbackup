<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: 6. hét: pointerek, sztringek, állapotgépek</title>
<meta property="og:title" content="InfoC :: 6. hét: pointerek, sztringek, állapotgépek">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="Gyakorlófeladatok a 6. előadás anyagához kapcsolódóan.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="Gyakorlófeladatok a 6. előadás anyagához kapcsolódóan.">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="modulz/logo_touch.png">
<link rel="image_src" href="modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<script>infoc.onloads.push(function(){ h3toid(); });
</script>
<link rel="stylesheet" href="modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="modulz/style/localfonts.css@v10.css">
<script src="modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="index.html">InfoC</a></div>
<ul>
<li class="al "><a href="f06.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="index.html">Kezdőlap</a>
<li><a href="nhf.html">Nagy házi feladat</a>
<li><a href="elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="f06.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="f06.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="ea01.html">1. hét: bevezetés</a>
<li><a href="ea02.html">2. hét: algoritmusok</a>
<li><a href="ea03.html">3. hét: tételek, tömbök</a>
<li><a href="ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="ea09.html">9. hét: láncolt listák</a>
<li><a href="ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="ea12.html">12. hét: bináris fák</a>
<li><a href="ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="f06.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="gy02.html">2. hét: algoritmizálás</a>
<li><a href="gy03.html">3. hét: egyszerű programok</a>
<li><a href="gy04.html">4. hét: tételek és tömbök</a>
<li><a href="gy05.html">5. hét: függvények</a>
<li><a href="gy06.html">6. hét: származtatott típusok</a>
<li><a href="gy07.html">7. hét: mutatók használata</a>
<li><a href="gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="gy11.html">11. hét: láncolt listák I.</a>
<li><a href="gy12.html">12. hét: láncolt listák II.</a>
<li><a href="gy13.html">13. hét: bináris fák</a>
<li><a href="gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="f06.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="lab01.html">1. hét: operációs rendszer</a>
<li><a href="lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="lab03.html">3. hét: egyszerű programok</a>
<li><a href="lab04.html">4. hét: tömbök</a>
<li><a href="lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="lab11.html">11. hét: láncolt listák</a>
<li><a href="lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="lab13.html">13. hét: bináris fák</a>
<li><a href="lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="f06.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="f01.html">1. hét: egyszerű programok</a>
<li><a href="f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="f09.html">9. hét: láncolt listák</a>
<li><a href="f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="f06.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="jegyzet.html">Jegyzet és puska</a>
<li><a href="fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="stilus.html">Kódolási stílus</a>
<li><a href="tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="debugmalloc.html">Debugmalloc</a>
<li><a href="mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="f06.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="f06.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="orak.html">SVG óra galéria</a>
<li><a href="angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="f06.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="turing.html">Mit tud a számítógép?</a>
<li><a href="bf.html">BF</a>
<li><a href="bitturmix.html">Bitturmix</a>
<li><a href="labirintus.html">Labirintusok</a>
<li><a href="tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="f06.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="karakterkodolas.html">Karakterkódolások</a>
<li><a href="strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="internet.html">Internet</a>
</ul>

<li class="al "><a href="f06.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="sdl.html">SDL grafika</a>
<li><a href="sdl_telepito.html">SDL telepítés</a>
<li><a href="fa.html">Fák rajzolása</a>
<li><a href="lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="f06.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="mondatelemzo.html">Mondatelemző</a>
<li><a href="kifejezesek.html">Kifejezések</a>
<li><a href="derivalas.html">Deriválás</a>
<li><a href="ast_epit.html">AST: szintaxisfák</a>
<li><a href="ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<h1 class="eloadascim">6. hét: pointerek, sztringek, állapotgépek</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán, Nagy Gergely, Pohl László · <i class="ido"></i> 2015.02.18</p>
<p class="kivonat">Gyakorlófeladatok a 6. előadás anyagához kapcsolódóan.</p>
</div>


<p>Ezen az oldalon rengeteg feladat található a gyakorláshoz. Egy részük megoldással együtt, míg 
a többi anélkül. A gyakorlófeladatok megoldásához elvileg elegendő az az ismeretanyag, amely az előadáson 
szerepelt. Természetesen a megoldás kitalálásához szükség lehet arra a rálátásra és 
tapasztalatra, amit a gyakorlatok és a laborok adnak. A feladatok témakörök szerinti 
csoportosítása viszont ettől függetlenül az előadást követi.</p>

<p>Felhívjuk a figyelmed arra, hogy a megoldások olvasgatása lényegében nulla 
tapasztalatot és gyakorlatot ad, így az eredményes számonkérésekhez nem tud hozzásegíteni! A 
megoldásokat akkor nézd csak meg, ha a saját megoldás elkészítése közben elakadsz.
Lásd <a href="tanacsok.html">itt</a>.</p>


<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="f06.html#1">Tömbök és függvények</a>
<li><a href="f06.html#2">Sztringek</a>
<li><a href="f06.html#3">Állapotgépek</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<a id="feladattombptr" class="namer"></a>
<div class="slideheader">
<h2><span class="oldalszam">1</span>Tömbök és függvények</h2>
</div>

<h3>Tömb eleme</h3>
<div class="sticky">Vizsga beugró volt</div>
<p> Írj függvényt, amely átvesz egy <code>int</code> tömböt, és visszatér a 4 indexű elemével,
ha az létezik, különben 0-val! </p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<p>A C-ben, ha egy tömböt átadunk paraméterként, akkor csak az első
elemének (nullás indexű elemének) a címe adódik át a függvénynek.
Ebből az is következik, hogy a függvény nem tudja, mekkora az a
tömb, vagyis azt is át kell adni, külön paraméterként. A függvény
paramétereinek típusa ezért <code>int*</code>, a tömb elejére mutató
pointer, és még egy <code>int</code>, amelyik pedig a tömb mérete.
Hogy létezik-e a tömb 4-es indexű eleme, azt pedig ebből a méret
változóból tudjuk.</p>

<pre class="brush: c "  >
int fv(int *t, int meret) {
    if (meret&gt;4)
        return t[4];
    else
        return 0;
}</pre>

</div>
</div>




<h3>Tömb összege</h3>
<p>Készíts függvényt, mely egy valós számokból álló tömb elemeit összegzi!</p>

<h3>Tömb három legkisebb eleme</h3>
<p>Készíts függvényt, amely egy tömb 3 legkisebb elemét határozza meg!</p>

<h3>Alig változik</h3>
<p>Készíts függvényt, mely a paraméterben kapott egész tömbről megvizsgálja, hogy elemeinek értéke
szomszédos elemek E sugaron belül helyezkednek el (különbségük nem nagyobb, mint E vagy -E)
A függvény bemenő paramétere a tömbre mutató pointer, a tömb elemeinek száma, valamint az E értéke.
Visszatérési értéke logikai típusú legyen, amely azt mutatja, teljesült-e a feltétel!</p>

<h3>Legalább kettő</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely paraméterként vesz át egy egészekből álló tömböt, és visszaadja az
első olyan tömbelem címét, amelyből legalább kettő található a tömbben! Ha nincs
ilyen tömbelem, adjon vissza NULL pointert!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
int *dupla(int *tomb, int n) {
    int i, j;
    for (i=0; i&lt;n-1; i++)
        for (j=i+1; j&lt;n; j++)
            if (tomb[i] == tomb[j])
                return tomb+i;
    return NULL;
}</pre>
</div>
</div>

<h3>Rendezett-e</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely paraméterként vesz át egy valós értékekből álló tömböt, melyről
biztosan tudjuk, hogy elemei különbözőek! A függvény ellenőrizze, hogy a tömb rendezett-e (akár
növekvő, akár csökkenő sorrendben; a feltételezett rendezettség iránya az első két tömbelem
vizsgálatával eldönthető). Ha a tömb nem rendezett, a függvény adja vissza az első olyan
tömbelem címét, amelyik elrontja a rendezettséget! Ha a tömb rendezett, adjon vissza NULL
pointert! Pl. be: {-8.11, -5.3, 0.1, 2.5, 1.4, 6.9, 12.0, 5.7}, a visszaadott érték az 1.4-et
tartalmazó tömbelem címe. Pl. be: {7, 1, 2, 3, 4, 5}, a visszaadott érték a 2-t tartalmazó
tömbelem címe.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
double *rendezette(double *tomb, int n) {
    int i, no;
    if (n&lt;3) return NULL;
    no = tomb[0] &lt; tomb[1];
    for (i=3; i&lt;n; i++) {
        if (no &amp;&amp; tomb[i-1] &gt; tomb[i]) return tomb+i;
        else if (!no &amp;&amp; tomb[i-1] &lt; tomb[i]) return tomb+i;
    }
    return NULL;
}</pre>
</div>
</div>

<h3>Legkisebb és legnagyobb</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely paraméterként vesz át egy egészekből álló tömböt! A függvény adja
vissza címével átvett változókban a tömb legkisebb  és  legnagyobb  elemének
indexét!  Ha  több  egyforma  érték  a legkisebb/legnagyobb, akkor ezek közül bármelyik indexét
visszaadhatja.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
void minmax(int *tomb, int n, int *min, int *max) {
    int i;
    *min = *max = 0;
    for (i = 1; i&lt;n; i++) {
        if (tomb[i] &lt; tomb[*min] ) *min = i;
        if (tomb[i] &gt; tomb[*max] ) *max = i;
    }
}</pre>
</div>
</div>

<h3>24×21-es képecskék</h3>

<p>Egy játékhoz, amit írunk, szükség vagy 24×21 fekete/fehér pontból álló kis képecskékre.
Mivel ezekből rengeteg lesz, kitaláljuk, hogy a fekete/fehér jelleg miatt egy bit is tárolhat
egy pontot, így az egy kép által lefoglalt memória (innentől feltételezve a 8 bites char-t)
3×21=63 bájtot foglal csak el a memóriából. Feladat: írni három függvényt, amelyek a
következőeket tudják:</p>
<ul>
    <li>Kirajzolni pontokból és csillagokból egy ilyen képecskét.
    <li>Fehérre állítani egy pontot.
    <li>Feketére állítani egy pontot.
</ul>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

typedef unsigned char kep[63];

// Az elso feladatresz megoldasa: egy kepecske kirajzolasa
void kirajzol(kep k) {
    int x, y;

    for (y=0; y&lt;21; y++) {
        for (x=0; x&lt;24; x++) {
            /* annyival shift, utana legalso bit */
            /* (szóköz helyett .-ot használtam most) */
            printf(&quot;%c&quot;, (k[y*3+x/8]&gt;&gt;(7-x%8))&amp;1 ? '*':'.');
        }
        printf(&quot;\n&quot;);
    }
    printf(&quot;---\n&quot;);
}

// A masodik feladatresz: adott pontot feherre allit
void feher(kep k, int x, int y) {
    /* keppont aktiv: bitenkenti VAGY */
    k[y*3+x/8]=k[y*3+x/8] | (1&lt;&lt;(7-x%8));
}

// A harmadik feladatresz: adott pontot feketere allit
void fekete(kep k, int x, int y) {
    /* keppont ki: bitenkenti ES a negalttal */
    k[y*3+x/8]=k[y*3+x/8] &amp; ~(1&lt;&lt;(7-x%8));
}

int main(void) {
    int x, y;
    kep k;

    for (y=0; y&lt;21; y++)
        for (x=0; x&lt;24; x++)
            fekete(k, x, y);
    kirajzol(k);
    for (x=0; x&lt;24; x++)
        feher(k, x, 10);
    kirajzol(k);
    for (y=0; y&lt;21; y++)
        feher(k, 5, y);
    kirajzol(k);

    return 0;
}</pre>

<p>Megoldható kétdimenziós tömbbel is, <code>kep[3][21]</code>. Az egy bájton belüli képpond
sorrend is tetszőleges; vagy mindenhol <code>7-x%8</code>, vagy mindenhol simán <code>x%8</code>.</p>
</div>
</div>


<h3>Minden második</h3>
<p>Írj függvényt, ami egy tömböt átvesz
paraméterként, és hátulról indulva kiírja minden második elemét!
Ügyelj arra, hogy nehogy túl/alulindexeld a tömböt!</p>


<h3>Súlypont</h3>
<p>Készíts struktúratípust, amely alkalmas egy térbeli pont
koordinátáinak eltárolására (x, y, z koordinálta). Írj függvényt,
amely átvesz egy térbeli pontokból álló tömböt, és visszaadja a
pontok súlypontját (azaz azt a pontot, amelynek a koordiátáit a
bemenő bontok megfelelő koordinátáinak átlagai)! Próbáld ki a
függvényt teljes programmá kiegészítve!</p>




<h3>Hány egyedi elem van?</h3>
<p>Készíts függvényt, mely egy adott tömbben megszámolja, hogy hány olyan
elem van, amely csak egyszer fordul elő! Pl. a { 2, 7, 5, 8, 9, 5, 7, 5, 5, 3 }
tömbre a visszatérési érték legyen 4, mert a { 2, 3, 8, 9 } számok mind
csak egyszer szerepeltek!</p>


<h3>A leggyakoribb elem</h3>
<p>Készíts függvényt, mely meghatározza egy adott (véletlen számokkal
feltöltött) tömbben, hogy melyik értékből található benne a legtöbb! Pl.
ha a tömb elemei { 2, 7, 5, 8, 9, 5, 7, 5, 5, 3 }, akkor a függvényt
visszatérési értéke legyen 5, mivel az a leggyakoribb elem.



<h3>Rendezettség vizsgálata</h3>

<div class="sticky">Kis ZH volt</div>

<p>Írj egy függvényt, amelyik egy double számokból álló tömböt vesz át paraméterként. A
függvény térjen vissza egy felsorolt típussal, amelynek lehetséges értékei: <code>csokkeno</code>
, ha a tömbben lévő számsorozat szigorúan monoton csökken; <code>novekvo</code>, ha szigorúan
monoton nő; <code>osszevissza</code>, ha egyik sem igaz rá. Írj egy programrészt, amelyik
definiál egy tömböt, és kiírja, hogy „növekvő”, ha a tömbben lévő számok szigmon növekvő sorban
vannak. Pl. [3 2.1 0.9] → <code>csokkeno</code>, [3 4 2 9 5] → <code>osszevissza</code>, [3 4.65
9 11] → <code>novekvo</code>.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

/* nem lenne muszaj typedefelni amugy */
typedef enum { osszevissza, novekvo, csokkeno } SzigMon;

/* a feladat nem definialja azt, mi a helyzet a 0 es 1 elemu
   tombokre (amik szigmon novekvoek es csokkenoek is :D) */

SzigMon vizsgal(double t[], int meret) {
    int i;
    int nov=1, csokk=1;     /* egyelore barmelyik lehet */

    /* vigyazni a tulindexelesre! i+1, szoval itt i&lt;meret-1*/
    for (i=0; i&lt;meret-1; i++)
        /* ha nem igaz, hogy kisebb a kovetkezonel */
        if (!(t[i]&lt;t[i+1]))
            /* akkor ez novekvo nem lehet */
            nov=0;

    /* ugyanaz a logika */
    for (i=0; i&lt;meret-1; i++)
        if (!(t[i]&gt;t[i+1]))
            csokk=0;

    /* hacsak nem 0 vagy 1 elemu a tomb, akkor ez megfelel */
    if (csokk) return csokkeno;
    if (nov) return novekvo;
    return osszevissza;
}

int main(void) {
    double t1[5]={5, 9, 1, 3, 45};
    double t2[5]={1, 2, 3, 4, 5};
    double t3[5]={9, 8, 7, 6, 5};

    if (vizsgal(t1, 5)==osszevissza) printf(&quot;t1 osszevissza\n&quot;);
    if (vizsgal(t2, 5)==novekvo) printf(&quot;t2 novekvo\n&quot;);
    if (vizsgal(t3, 5)==csokkeno) printf(&quot;t3 csokkeno\n&quot;);

    return 0;
}</pre>
</div>
</div>


<h3>Minden szám megfordítása</h3>

<div class="sticky">Kis ZH volt</div>

<p>Írj C programot, amelyik definiál egy 1000 elemű, bájtokból álló tömböt. A program fordítsa
meg az egyes bájtokban a biteket; a 7. helyiértékű cseréljen helyet a 0. helyiértékűvel, a 6.
helyiértékű az 1-essel stb. (Feltételezzük, hogy a bájtok 8 bitesek. A tömb számokkal
feltöltésével nem kell foglalkozni.) A program végezetül írja ki binárisan a tömb 0. elemét. A
megfordításra példa:</p>

<pre class="screenshot">
76543210
10110010    bemenet
01001101    kimenet
</pre>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    unsigned char t[1000];
    int i;

    /* egyet most itt inicializalok, hogy lassam az eredmenyt,
     * de a feladat nem keri */
    t[0]=0xd7;

    /* kiiras, csak hogy a csere elott is lassuk */
    for (i=7; i&gt;=0; i--)
        putchar((t[0]&gt;&gt;i)&amp;1 ? '1':'0');
    printf(&quot;\n&quot;);

    /* ez a MEGOLDAS LENYEGE */
    for (i=0; i&lt;1000; i++) {
        int j;
        unsigned char uj=0;

        /* amit a regi szambol kishiftelunk jobbRA,
         * azt az ujba beshifteljuk jobbROL */
        for (j=0; j&lt;8; j++) {
            int x=t[i]&amp;1;       /* ez kiveszi az also bitet */
            t[i] &gt;&gt;= 1;         /* a regit shifteli */
            uj=uj&lt;&lt;1 | x;       /* ez az ujat balra shifteli,
                                         es az ujat berakja */
        }
        t[i]=uj;
    }

    /* ez csak copypaste, a feladat egyszer keri */
    for (i=7; i&gt;=0; i--)
        putchar((t[0]&gt;&gt;i)&amp;1 ? '1':'0');
    printf(&quot;\n&quot;);

    return 0;
}</pre>
</div>
</div>


<h3>Bitek léptetése</h3>

<div class="sticky">Kis ZH volt</div>

<p>Írj egy C programot, amelyik 100 elemű, bájtokból álló tömböt léptet egy bittel jobbra! A
számokból jobbra kicsúszó bit jöjjön be mindig a következő számba balról. Az utolsó szám legalsó
helyiértékéből kicsúszó bit pedig kerüljön az első szám legfelső helyiértékébe. (Feltételezzük,
hogy a bájtok 8 bitesek. A tömb számokkal feltöltésével nem kell foglalkozni.) Például:</p>

<pre class="screenshot">
76543210 76543210 ... 76543210 76543210
01001010 11111101     01011110 00001101    bemenet
10100101 01111110 ... 10101111 00000110    kimenet
</pre>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
    unsigned char t[100];
    int i, atvitel;

    /* ezt nem kerte a feladat, csak hogy ne legyen inicializalatlan */
    for (i=0; i&lt;100; ++i)
        t[i]=rand()%256;

    /* ezt se kerte, csak hogy latszodjon az eredmeny */
    for (i=7; i&gt;=0; i--)
        putchar((t[0]&gt;&gt;i)&amp;1 ? '1':'0');
    printf(&quot; ... &quot;);
    for (i=7; i&gt;=0; i--)
        putchar((t[99]&gt;&gt;i)&amp;1 ? '1':'0');
    printf(&quot;\n&quot;);

    /* MEGOLDASA a feladatnak: tulajdonkepp ez a ciklus. */
    /* utolso szam utolso bitje,
     * mert ez csuszik be az elso szamba; mar most kivesszuk,
     * hogy lent, amikor az atvitelt &quot;becsusztatjuk&quot; az
     * if (atvitel) resznel, ott mar a megfelelo erteket
     * tartalmazza */
    atvitel=t[99]&amp;1;
    for (i=0; i&lt;100; i++) {
        int uj_atvitel=t[i]&amp;1; /* a kovetkezo szamhoz - ez a kicsuszo bit */
        t[i] &gt;&gt;= 1;         /* ezzel csuszik az egesz */
        if (atvitel)
            /* ha volt &quot;atvitel&quot;, akkor azt berakjuk a legfelsobe */
            t[i] |= 1&lt;&lt;7;
        atvitel=uj_atvitel;
    }

    /* kiirom az eredmenyt; a feladat nem kerte */
    for (i=7; i&gt;=0; i--)
        putchar((t[0]&gt;&gt;i)&amp;1 ? '1':'0');
    printf(&quot; ... &quot;);
    for (i=7; i&gt;=0; i--)
        putchar((t[99]&gt;&gt;i)&amp;1 ? '1':'0');
    printf(&quot;\n&quot;);

    return 0;
}</pre>
</div>
</div>






<h3>Párosak vagy negatívak?</h3>

<div class="sticky">Kis ZH volt</div>

<p>Írj egy függvényt, amelyik egy egész számokból álló tömböt vesz át paraméterként. A függvény
térjen vissza az alábbi felsorolt típusból valamelyik értékkel: <code>parosak</code>,
<code>negativak</code>, <code>mindketto</code>, <code>egyiksem</code>, ha a tömbben páros az
összes szám, negatív az összes, illetve ha mindkét tulajdonság, vagy egyik tulajdonság sem
érvényes rájuk. Írj programot, amelyik egy példaként definiált 100 elemű tömbre meghívja a
függvényt, és kiírja, hogy „párosak”, ha érvényes rá ez a tulajdonság.</p>

<ul>
<li>[3 4 5] → <code>egyiksem</code>
<li>[-2 -4 -6] → <code>mindketto</code>
<li>[4 6 10] → <code>parosak</code>
</ul>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

typedef enum { parosak, negativak, mindketto, egyiksem } Tulajdonsagok;

Tulajdonsagok vizsgal(int t[], int meret) {
    int i;
    int prsk, ngtvk;

    /* a megoldas gondolata, pl. parosakra:
     * 1) tetelezzuk fel, hogy az osszes szam paros.
     * 2) nezzuk vegig a tombot
     *    2a) ha talalunk egy nem paros szamot
     *       2aa) akkor nem igaz az, hogy mind parosak. */

    /* 1 */
    prsk=1;
    ngtvk=1;
    /* 2 */
    for (i=0; i&lt;meret; ++i) {
        if (t[i]%2!=0)        /* &lt;- 2a */
            prsk=0;            /* &lt;- 2aa */
        if (t[i]&gt;=0)
            ngtvk=0;
    }

    if (prsk &amp;&amp; ngtvk)
        return mindketto;
    if (prsk)        /* ... de nem ngtvk */
        return parosak;
    if (ngtvk)        /* ... de nem prsk */
        return negativak;
    return egyiksem;    /* mar csak ez lehet. */
}

int main(void) {
    int t[5]={4, 6, 8, 10, 12};

    if (vizsgal(t, 5)==parosak)
        printf(&quot;parosak&quot;);

    return 0;
}</pre>
</div>
</div>






<h3>Tic-tac-toe</h3>

<img src="f06/amoba.svg" class="float" alt="Tic-tac-toe" style="width: 8em;">

<p>3x3-as tic-tac-toe játékot kell csinálni. A 3x3-as pálya egyes
állapotai lehetnek: üres (még nem rajzolt oda senki), kör és iksz.</p>

<ul>
<li>Hozz létre egy ilyet tároló adatszerkezetet!
<li>Rajzold ki a pályát karakterekkel!
<li>Írj függvényt, amelyik ellenőrzi, hogy nyert-e valaki!
</ul>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<p>Az enum használatával olvashatóbbá tehetjük a kódot. A megadott
azonosítókhoz (a lehetséges értékekhez) ilyenkor a fordító egy egész
sorszámot rendel, és a végleges, gépi kódú programban már csak azok
szerepelnek. Erre azonban nem kell gondolni programozás közben: pont
azért nevezzük el őket, hogy ne kelljen a sorszámaikat megjegyezni.</p>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

typedef enum Babu { ures, kor, iksz } Babu;
typedef Babu Palya[3][3];

/* ilyenkor is pointer adodik at a palyara!
   tomb fuggvenynek -&gt; mindig pointer. */
int nyert_e(Palya p, Babu kicsoda) {
    int x, y;
    int nyert;

    /* nyert-e az x? */
    nyert=0;
    /* vizszintesen --- */
    for (y=0; y&lt;3; y++)
        if (p[y][0]==kicsoda &amp;&amp; p[y][1]==kicsoda &amp;&amp; p[y][2]==kicsoda)
            nyert=1;
    /* fuggolegesen ||| */
    for (x=0; x&lt;3; x++)
        if (p[0][x]==kicsoda &amp;&amp; p[1][x]==kicsoda &amp;&amp; p[2][x]==kicsoda)
            nyert=1;
    /* atlosan \ */
    if (p[0][0]==kicsoda &amp;&amp; p[1][1]==kicsoda &amp;&amp; p[2][2]==kicsoda)
        nyert=1;
    /* atlosan / */
    if (p[0][2]==kicsoda &amp;&amp; p[1][1]==kicsoda &amp;&amp; p[2][0]==kicsoda)
        nyert=1;

    return nyert;
}

void kirajzol(Palya p) {
    int x, y;

    printf(&quot;+---+\n&quot;);
    for (y=0; y&lt;3; y++) {
        printf(&quot;|&quot;);
        for (x=0; x&lt;3; x++)
            switch (p[y][x]) {
                case iksz: printf(&quot;x&quot;); break;
                case kor: printf(&quot;o&quot;); break;
                case ures: printf(&quot; &quot;); break;
            }
        printf(&quot;|\n&quot;);
    }
    printf(&quot;+---+\n&quot;);
}

int main(void) {
    Palya p;
    int x, y;

    for (y=0; y&lt;3; y++)
        for (x=0; x&lt;3; x++)
            p[y][x]=ures;

    printf(&quot;Nyert az iksz? %d\n&quot;, nyert_e(p, iksz));
    for (x=0; x&lt;3; x++)
        p[1][x]=iksz;
    printf(&quot;Nyert az iksz? %d\n&quot;, nyert_e(p, iksz));
    for (x=0; x&lt;3; x++)
        p[x][1]=kor;
    printf(&quot;Nyert a kor? %d\n&quot;, nyert_e(p, kor));
    p[1][1]=iksz;
    printf(&quot;Nyert a kor? %d\n&quot;, nyert_e(p, kor));
    kirajzol(p);

    return 0;
}</pre>

</div>
</div>









</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<a id="feladatsztring" class="namer"></a>
<div class="slideheader">
<h2><span class="oldalszam">2</span>Sztringek</h2>
</div>

<h3>Üdvözlés</h3>
<p>Készíts programot, amely bekéri a felhasználó nevét, majd üdvözli őt a nevén szólítva!</p>

<h3>Függőleges</h3>
<p>Készíts programot, mely bekér egy keresztnevet, majd azt betűnként
függőlegesen lefelé kiírja. Például ha a név "Imre", akkor az eredmény:</p>
<pre>
I
m
r
e
</pre>



<h3>Hány szóköz?</h3>
<p>Készíts programot, mely bekér egy mondatot, majd
<br>
a.) megszámolja és kiírja, hogy a mondatban hány szóköz található.
<br>
b.) kiírja a mondatot szóközök nélkül.</p>


<h3>Kisbetűk</h3>
<p>Készíts függvényt (numLower), ami megkap egy stringre mutató
pointert, és visszaadja az adott szövegben található kisbetűk
számát. (Ehhez használható a <code>ctype.h</code>
<code>islower()</code> függvénye is.)</p>


<h3>Nagybetűk</h3>
<p>Készíts függvényt, mely a paraméterben átadott sztringet nagybetűssé alakítja!</p>


<h3>Karakterek cseréje</h3>
<p>Készíts függvényt, mely paraméterben egy sztringet és további két
karaktert (mit és mire) kap. A függvény keresse meg a sztringben a "mit"
változóban megadott karaktereket, és cserélje azokat a "mire" változóban
megadottakra. A függvény visszatérési értéke a kicserélt karakterek számát
jelentse.</p>




<h3>Névelő</h3>
<p>Készíts programot, mely adott sztringben megszámolja, hányszor fordul
elő az "a" névelő. A névelő lehet mondat elején, de végén nem, viszont vessző
állhat előtte is és utána is, egyébként szóköz karakterek határolják.</p>



<h3>Hexadecimális</h3>
<p>Írj olyan int htoi(char *s) függvényt, amelyik a megadott
hexadecimális számjegyekből álló sztringet a neki megfelelő egész értékké
alakít! Pl. htoi("1ef") visszatérési értéke 495.</p>
<p>Oldd meg a feladatot a <code>sscanf()</code> segítségével és anélkül is!</p>




<h3>Része-e?</h3>
<p>Írj egy függvényt, amely egy adott sztringben megkeresi egy másik
sztring legutolsó előfordulását, és visszaadja annak pozícióját, illetve
-1-et, ha nem található. A megoldáshoz ne használd a könyvtári <code>strrstr()</code>
függvényt! Például "abcd<em>abc</em>e"-ben keressük "abc"-t, a visszatérési érték
4, a színnel jelölt előfordulás miatt.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<p>A következő módon bontható fel ezt részekre:</p>

<ul>
    <li>Kell egy függvény, amelyik megmondja, hogy egy adott sztring elején szerepel-e
    egy másik sztring. Ezt fogom lefuttatni a különböző részein az eredeti sztringeknek
    (visszafelé). Szemfülesek az <code>strncmp</code>-t használhatják erre.
    <li>Kell egy függvény, amelyik egy sztring hosszát megmondja (de jó a gyári <code>strlen</code> is), mivel
    <li>visszafelé futtatok egy ciklust, és nézem, hogy megtalálom-e valahol a szénakazal
    végén a tűt.
    <li>Ahol először megtalálom, azzal az indexszel vissza is térhetek; ha sehol
    nem találtam meg, akkor -1-gyel.
</ul>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int igy_kezdodik(char *mi, char *hogyan) {
    int i;

    /* amig egyiknek sincs vege, es egyeznek a betuk, kov. karakter */
    i=0;
    while (hogyan[i]!='\0' &amp;&amp; mi[i]!='\0' &amp;&amp; hogyan[i]==mi[i])
        i++;
    /* ha a hogyan string vegere ertunk, akkor eddig tuti megegyezett
       a mi-vel */
    return hogyan[i]=='\0';
}

int hossz(char *str) {
    int i = 0;
    while (str[i]!='\0') i++;
    return i;
}

int utolso_elofordulas(char *szenakazal, char *tu) {
    int h;

    h=hossz(szenakazal);
    h-=hossz(tu);   /* ennel csak elorebb lehet */
    while (h&gt;=0 &amp;&amp; !igy_kezdodik(szenakazal+h, tu))
        h--;
    /* ha ertelmes index van, akkor azzal terunk vissza */
    if (h&gt;=0)
        return h;
    /* amugy -1 */
    return -1;
}

int main(void) {
    printf(&quot;%d\n&quot;, utolso_elofordulas(&quot;almafa, eperfa&quot;, &quot;fa&quot;));
    printf(&quot;%d\n&quot;, utolso_elofordulas(&quot;almafa, eperfa&quot;, &quot;a&quot;));
    printf(&quot;%d\n&quot;, utolso_elofordulas(&quot;almafa, eperfa&quot;, &quot;kortefa&quot;));

    return 0;
}</pre>

<p>Az első függvénynek az is jó megoldás lenne, ha az összehasonlítandó
karakterek számát paraméterként kapja; olyankor nem kellene figyelnie
a lezáró nullákra.</p>

</div>
</div>




<h3>Felülírás és csere</h3>

<p>Írj függvényt, amely az első paraméterében kapott sztringben megkeresi
a második paraméterében adott karakter előfordulásait, és felülírja azokat
a harmadik paraméterében adott karakterrel! Pl. "alma", 'a', 'e' &rarr; "elme".</p>

<p>Írj függvényt, amely szintén egy sztringet és egy karakterpárost kap,
de ez ne felülírja az első előfordulásait a másodikkal, hanem cserélje meg
őket! Pl. 'a', 'e' jelentse azt, hogy 'a'-t 'e'-re kell cserélni, 'e'-t
pedig 'a'-ra. Hogyan lehet ezt megoldani az előző függvény felhasználásával?</p>


<h3>Squeeze</h3>
<p>Írj olyan "squeeze" függvényt, amely az első paraméterben megadott
sztringből az összes olyan karaktert törli, amelyik szerepel a második
paraméterben megadott sztringben. Például "megadott sztring", "gt"
paraméterekkel meghívva a függvényt az első paraméter így módosul: "meado
szrin".</p>




<h3>Pontosan egyszer</h3>
<p>Írj programot, amely beolvas egy karakterláncot, és megállapítja, hogy vannak-e benne olyan
karakterek, amelyek pontosan egyszer fordulnak elő. A program írja ki ezeket a karaktereket, ha
pedig nincsenek a karakterláncban egyedi karakterek, akkor közölje a felhasználóval!</p>





<h3>Palindrom</h3>
<p>Írj programot, amelyik egy sztringről eldönti, hogy palindrom-e: azaz oda-vissza olvasva
ugyanaz-e, mint önmaga. Közismert magyar nyelvű palindrom mondat a „Géza, kék az ég.” Hogyan
lehet a gyakorlat „mindentegybevéve” és „fordítva” feladatainak ötleteiből összerakni ezt a
programot? Hogyan egyszerű megírni, ha módosíthatjuk a sztringet, és hogyan akkor, ha nem?</p>
<p>A tesztelésnél figyelj arra, hogy egyes karakterkódolások esetén az ékezetes betűkhöz több
bájt is tartozhat. Ezek megfordítva nem ugyanazt a betűt jelentik. Ezért a programot inkább
ékezetes betűk nélkül teszteld!</p>




<h3>toupper()</h3>

<p>Készíts függvényt (myToUpper) mely egy sztringben képes a latin abc betűit nagybetűssé
alakítani! A bemenet legyen a sztringre mutató kezdőpointer, a végeredmény ugyanebbe a sztringbe
kerüljön bele!</p>



<h3>Legalább kettő – sztringre</h3>

<div class="sticky">Kis ZH volt</div>

<p>Írj függvényt, amely paraméterként vesz át egy sztringet, és visszaadja az első olyan
karakter címét, amelyből legalább kettő található a sztringben! Ha nincs ilyen karakter, adjon
vissza NULL pointert!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
char *duplas(char *string) {
    int i, j;
    for (i=0; string[i]!='\0'; i++)
        for (j=i+1; string[j]!='\0'; j++)
            if (string[i] == string[j] )
                return string+i;
    return NULL;
}</pre>
</div>
</div>





<h3>strlcat()</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj egy függvényt (paraméterei: cél, forrás, cél tömb mérete), amelyik egy cél sztring (1.
paraméter) végére hozzáfűz egy forrás sztringet (2. paraméter); figyelembe véve azt, hogy a cél
tömb maximális mérete adott (3. paraméter), amelybe már a lezáró nullának is bele kell férnie.
Mindkét helyen eredendően is 0-val lezárt sztring van. Ha az összefűzött sztring nem fér el a
cél helyen, akkor le kell vágnia a függvénynek – de nullával mindig legyen lezárva. Írj
programrészt, amelyben bemutatod a függvény használatát. A <code>string.h</code> függvényei NEM
használhatóak.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<img src="f06/kzh-strlcat.svg" alt="Az strlcat() függvény működése" class="kozep" style="width: 28em;">
<p>Rendes helyeken ilyen gyárilag szokott lenni, <code>strlcat</code> vagy
<code>g_strlcat</code> néven. Az egésznek az előnye, hogy a cél puffer
méretét kell megadni a harmadik paraméterben, ami statikus tömb esetén egy
sima sizeof. Nem kell levonni 1-et a lezáró 0 miatt, semmi ilyesmi, pontosan
a méretet várja.</p>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

void strlcat(char *cel, char *forras, int meret) {
    int celmeret, forrasidx;

    celmeret=0;
    while (cel[celmeret]!=0)
        ++celmeret;

    forrasidx=0;
    while (forras[forrasidx]!=0 &amp;&amp; celmeret+forrasidx&lt;meret-1) {
        cel[celmeret+forrasidx]=forras[forrasidx];
        forrasidx++;
    }

    /* akarmiert is lett vege, lezaro 0. */
    cel[celmeret+forrasidx]=0;
}

int main(void) {
    char cel[6]=&quot;alma&quot;;
    char cel2[9]=&quot;alma&quot;;
    strlcat(cel, &quot;le&quot;, sizeof(cel));
    strlcat(cel2, &quot;le&quot;, sizeof(cel2));
    printf(&quot;[%s]\n&quot;, cel);
    printf(&quot;[%s]\n&quot;, cel2);

    return 0;
}</pre>
</div>
</div>




<h3>Összefűzés</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely paraméterként vesz át egy cél sztringet, továbbá két másik sztringet és
egy elválasztó karaktert! Másolja be a cél sztringbe a másik két sztringet úgy, hogy közéjük az
elválasztó karaktert teszi.
<p>Írj főprogramot, amelyben egy példával bemutatod a függvény használatát! A beépített
sztringkezelő függvények <em>nem</em> használhatóak!
<p>Példa paraméterek: <code>„alma”</code> és <code>„körte”</code>, továbbá <code>„;”</code>
<p>Példa eredmény: <code>„alma;körte”</code>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

void osszefuz(char *ide, char *egyik, char *masik, char koze) {
   int pos, i;

   pos=0;
   for (i=0; egyik[i]!='\0'; ++i)
      ide[pos++]=egyik[i];
   ide[pos++]=koze;

   for (i=0; masik[i]!='\0'; ++i)
      ide[pos++]=masik[i];
   ide[pos++]='\0';
}

int main(void) {
   char kesz[20];

   osszefuz(kesz, &quot;alma&quot;, &quot;korte&quot;, ';');
   printf(&quot;%s\n&quot;, kesz);

   return 0;
}</pre>
</div>
</div>





<h3>Szétválasztás</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj egy függvényt, amely paraméterként vesz át egy bemeneti sztringet és egy elválasztó
karaktert! Legyen még két további paramétere, amelyekbe az eredményt írja. Vágja ketté a
függvény a sztringet az első elválasztó karakternél: az eleje menjen az egyik eredmény
sztringbe, másik pedig a másikba!
<p>Írj főprogramot, amelyben egy példával bemutatod a függvény használatát! A
beépített sztringkezelő függvények <em>nem</em> használhatóak.
<p>Példa paraméterek: <code>„alma;körte”</code> és <code>„;”</code>
<p>Példa eredmény: <code>„alma”</code> és <code>„körte”</code>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

void szeletel(char *be, char elvalaszto, char *egyik, char *masik) {
   int x, pos;

   x=0;
   pos=0;
   while (be[x]!=elvalaszto)
      egyik[pos++]=be[x++];
   egyik[pos]=0;

   x++;
   pos=0;
   while (be[x]!='\0')
      masik[pos++]=be[x++];
   masik[pos]=0;
}

int main(void) {
   char bal[20], jobb[20];

   szeletel(&quot;alma;korte&quot;, ';', bal, jobb);
   printf(&quot;[%s] es [%s]\n&quot;, bal, jobb);

   return 0;
}</pre>
</div>
</div>





<h3>Karakterek törlése</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely átvesz paraméterként egy módosítandó sztringet és még egy karaktert.
Alakítsa át úgy a sztringet úgy, hogy a megadott karaktert törölje a sztring elejéről és a
végéről is! Mindkét oldalon lehet több is, vagy akár semennyi. A belsejében viszont tudjuk, hogy
nincsen.
<p>Írj főprogramot, amelyben egy példával bemutatod a függvény használatát! A beépített
sztringkezelő függvények <em>nem</em> használhatóak.
<p>Példa bemenet: <code>„xxxHello hallo elektor kalandorxxxx”</code> és az <code>„x”</code> karakter
<p>Példa kimenet: <code>„Hello hallo elektor kalandor”</code>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

void sztring_trim(char *str, char mit) {
   int eleje, pos, i;

   eleje=0;
   while (str[eleje]==mit)
      eleje++;
   pos=0;
   for (i=eleje; str[i]!=mit &amp;&amp; str[i]!='\0'; i++)
      str[pos++]=str[i];
   str[pos]='\0';
}

int main(void) {
   char szoveg[]=&quot;xxxHello hallo elektor kalandorxxxx&quot;;

   sztring_trim(szoveg, 'x');
   printf(&quot;[%s]\n&quot;, szoveg);

   return 0;
}</pre>
</div>
</div>








<h3>Bevezető és lezáró karakterek</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely paraméterként átvesz egy cél sztringet, továbbá egy forrás sztringet,
egy karaktert és egy darabszámot! Másolja át a cél sztringbe a forrást úgy, hogy elé és mögé a
megadott karakterből a megadott darabszámút tegye. Ezen kívül a szóközöket is cserélje ki a
megadott karakterre.
<p>Írj főprogramot, amelyben egy példával bemutatod a függvény használatát! A beépített
sztringkezelő függvények <em>nem</em> használhatóak.
<p>Példa bemenet: <code>„Hello hallo elektor kalandor”</code>, továbbá az <code>„x”</code> karakter és 3
<p>Példa kimenet: <code>„xxxHelloxhalloxelektorxkalandorxxx”</code>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

void strelemoge(char *ide, char *mit, char kar, int db) {
   int pos, x;

   pos=0;
   for (x=0; x&lt;db; ++x)
      ide[pos++]=kar;

   for (x=0; mit[x]!='\0'; ++x)
      ide[pos++] = mit[x]==' ' ? kar : mit[x];

   for (x=0; x&lt;db; ++x)
      ide[pos++]=kar;

   ide[pos]='\0';
}

int main(void) {
   char novelt[30];

   strelemoge(novelt, &quot;Hello hallo elektor kalandor&quot;, 'x', 3);
   printf(&quot;[%s]\n&quot;, novelt);

   return 0;
}</pre>
</div>
</div>


<h3>Második szó, utolsó szó</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amely paraméterként kap egy sztringet! A sztring szöveget tartalmaz, melynek
szavait szóközök választják el egymástól (minden szó, ami nem szóköz). A függvény adja vissza
címével átvett változókban a sztring második szavának indexét, visszatérési
értékként (return-nel) pedig a sztring utolsó szavának címét! A paraméterként kapott sztringről
biztosan tudjuk, hogy legalább két szóból áll, a szavakat pontosan egy szóköz választja el
egymástól, és a sztring első és utolsó karaktere nem szóköz.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
char *szavak(char *sztring, int *masodik) {
    int i, utolso=0;
    *masodik=0;
    for (i=0; sztring[i]!='\0'; i++) {
        if (sztring[i]==' ') {
            utolso=i;
            if (*masodik==0)
                *masodik = i+1;
        }
    }
    return sztring + utolso;
}</pre>
</div>
</div>




<h3>„The” kezdetű címek"</h3>

<p>Könyvek, filmet címeit úgy szokás rendezni, hogy a címek elején lévő névelőket (pl. angolul a
„The”, magyarul az „A” és „Az”) a rendezésben nem vesszük figyelembe. Írj egy olyan módosított
<code>strcmp_the()</code> függvényt, amely paramétere és visszatérési értéke az eredeti <code>strcmp()</code>-éhez
hasonló, de az összehasonlításnál figyelmen kívül hagyja a „The” kezdetet!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<p>A legegyszerűbb megoldás az alábbi. Megvizsgáljuk mindkét sztringet. Ha valamelyik a „The&nbsp;” részsztringgel
kezdődik, az annak megfelelő pointert 4-gyel növeljük, tehát négy karakterrel hátrébb léptetjük.
Az így kapott sztringeket adjuk az eredeti <code>strcmp()</code>-nek. A két pointer növelését
azért tehetjük meg, mert azok a saját függvényünknek lokális változói, amelyet módosíthatunk.</p>

<pre class="brush: c "  >
/* Sztring összehasonlító függvény, ami nem veszi figyelembe
 * a szting elején lévő &quot;The &quot; előtagot */
int strcmp_the(char *egyik, char *masik) {
    if (strncmp(egyik, &quot;The &quot;, 4)==0)
        egyik+=4;
    if (strncmp(masik, &quot;The &quot;, 4)==0)
        masik+=4;
    return strcmp(egyik, masik);
}</pre>
</div>
</div>




<h3>IP cím</h3>
<div class="sticky">Vizsga volt</div>

<p>Írj egy olyan szabványos ANSI C függvényt, amely paraméterként kap egy sztringet, mely egy IP
címet tartalmaz a szokásos alakban: négy darab 0 és 255 közötti szám pontokkal elválasztva. A
függvény állítsa elő az IP cím 32 bites reprezentációját! A visszatérési értéke legyen egy
<code>unsigned</code> érték, amelynek legalsó bájtja az IP cím utolsó részének megfelelő értéket
tartalmazza, a második az IP cím utolsó előtti részét és így tovább. Feltesszük, hogy az
unsigned típus az adott architektúrán legalább 32 bites. Ha a bemenet például "0.0.2.33", akkor
a kimenet: 545.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<p>Barátunk a <code>scanf()</code>. Itt <em>egyáltalán</em> nem kell karakterenkénti
feldolgozást, és semmi hasonlót csinálni. A <code> scanf&nbsp;%d</code> be fog olvasni egy
számot, és a pontnál meg fog állni, mivel a pont nem lehet része egy egész számnak. A
formátumsztringbe pedig ha elhelyezünk egy pontot, akkor a scanf azt fogja várni, hogy a
bemeneten ott is legyen az a pont; beolvassa és eldobja. És hát, mivel nem a standard bemenetről
olvasunk, hanem sztringből, <code>sscanf()</code> lesz a függvényünk. Vigyázni kell, hogy a
&lt;&lt; műveleteket zárójelezni kell az összeadásnál – itt inkább bitenkénti vagy kapcsolatot
használtam (az eredmény egyébként ugyanaz lenne).</p>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

unsigned str_to_ip(char *str) {
    unsigned a, b, c, d;

    sscanf(str, &quot;%u.%u.%u.%u&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
    return a&lt;&lt;24 | b&lt;&lt;16 | c&lt;&lt;8 | d;
}

int main(void) {
    printf(&quot;%u\n&quot;, str_to_ip(&quot;0.0.2.33&quot;));
    return 0;
}</pre>

</div>
</div>




<h3>Caesar kódolás</h3>

<p>A gyakorlaton volt egy olyan példa, amelyik karaktereket képes bekódolni a&rarr;b, b&rarr;c,
c&rarr;d stb kódolással. Írj egy függvényt, amelyiknek megadható a kódolandó karakter, és a&rarr;d
kódolást használ. Javítsd úgy az órán tárgyalt függvényt, hogy csak a kisbetűket kódolja, más
karaktereket hagyjon változatlanul. Figyelj arra is, hogy a programkódban ne legyenek mágikus
értékek (pl. 26, mint az abc betűinek száma).</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

/* Ez bekodol egy karaktert, a kulcs szerint. */
char kodol(char mit, char kulcs) {
    char delta = kulcs-'a';
    if (mit&gt;='a' &amp;&amp; mit&lt;='z') {
        /* eltolas */
        mit = mit+delta;
        /* tulcsuszott a z-n? */
        if (mit &gt; 'z')
            /* akkor vissza kell menni annyit, hogy ujra az abecen
               belul legyunk. az 'annyit' erteke 'z'-'a'+1 lepes,
               nem pedig 'z'-'a'! az utobbi a ket karakter kozotti
               tavolsag, az elso pedig az a szam, amely az osszes
               letezo betuk szamat mutatja! */
            mit = mit-('z'-'a'+1);
    }
    return mit;
}

char dekodol(char mit, char kulcs) {
    char delta = kulcs-'a';
    if (mit&gt;='a' &amp;&amp; mit&lt;='z') {
        mit = mit-delta;
        if (mit &lt; 'a')
            mit = mit+('z'-'a'+1);
    }
    return mit;
}


int main(void) {
    char szoveg[]=&quot;hello, world!&quot;;
    int i;

    /* az abc kiirasa */
    for (i='a'; i&lt;='z'; ++i)
        printf(&quot;%c&quot;, i);
    printf(&quot;\n&quot;);
    for (i='a'; i&lt;='z'; ++i)
        printf(&quot;%c&quot;, kodol(i, 'd'));
    printf(&quot;\n&quot;);

    /* szoveg kodolasa */
    for (i=0; szoveg[i]!=0; ++i)
        szoveg[i]=kodol(szoveg[i], 'd');
    printf(&quot;[%s]\n&quot;, szoveg);

    /* szoveg dekodolasa */
    for (i=0; szoveg[i]!=0; ++i)
        szoveg[i]=dekodol(szoveg[i], 'd');
    printf(&quot;[%s]\n&quot;, szoveg);

    return 0;
}</pre>
</div>
</div>








</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<a id="feladatallapotgep" class="namer"></a>
<div class="slideheader">
<h2><span class="oldalszam">3</span>Állapotgépek</h2>
</div>

<h3>Sztringek belseje I.</h3>
<p>A négy állapotos C kommentszűrő program (lásd a laborfeladatot) nem működik tökéletesen.
Ugyanis ez a kód nem tartalmaz kommentet:</p>
<pre class="brush: c "  >
printf(&quot;/* ez nem komment. */\n&quot;);</pre>
<p>Javítsd ki úgy az állapotgéped, hogy kezelje ezt is!</p>




<h3>Sztringek belseje II.</h3>
<p>Hol van vége egy sztringnek? Nem az indító idézőjel utáni következő idézőjel
karakternél:</p>
<pre class="brush: c "  >
printf(&quot;A program azt irja ki, hogy \&quot;Hello, /* nem komment */ vilag\&quot;.\n&quot;);</pre>
<p>Fejleszd tovább az előző feladat állapotgépét eszerint!</p>




<h3>Multifilter</h3>

<p>Írd át a kommentszűró programot úgy, hogy ne csak a <code>/*</code> és <code>*/</code>
karakterpárokra működjön, hanem tetszőleges karakterpárokra! Pl. a Pascal nyelvben a kommenteket
<code>(*</code> és <code>*)</code> karakterekkel is lehetett jelölni. A kezdő- és végpárokat a
felhasználó egy konfigurációs fájlban (multifilter.ini) adhassa meg a programnak! A program
ellenőrizze, hogy létezik-e a fájl, és ha nem, adjon hibajelzést, majd lépjen ki! (Ha sikerült
megnyitnia a fájlt, abban négy karakternek kell lennie; a nyitó kombinációnak, két karakter, és
a záró kombinációnak, újabb két karakter. C-hez a fájlban <code>/**/</code> lenne, Pascalhoz
<code>(**)</code>.)</p>




<h3>Kettős mássalhangzók</h3>

<p>Készíts kettős mássalhangzó számláló programot!
<p>a.) Írj programot, mely a billentyűzetről érkező karaktereket figyeli,
és megszámolja a beírt szövegben található "ly" és "sz" kettős mássalhangzójú
betűk számát. A szöveget nem tárolhatja el a program, csak a találatok számát.
A szöveg beírása és a számlálás a fájl vége jellel véget ér,
ekkor a program írja ki tételesen az összeszámlált mennyiségeket.
<p>b.) Az előbbi programot egészítsd ki azzal, hogy a "zs" betűket is számolja,
de vigyázz: egy leütött karaktert csak egyetlen kettős mássalhangzójú betűhöz számold,
méghozzá az elsőhöz (pl. "egészség": 1 db "sz", 0 db "zs")!



<h3>Mondatszámláló</h3>
<p>Adja meg egy tetszőleges, standard bemenetről érkező szövegről, hogy
hány mondat van benne. Mondatnak tekintünk minden olyan karaktersorozatot,
amelyik nagybetűvel kezdődik, ponttal, kérdőjellel vagy felkiáltójellel
végződik.</p>



<h3>HTML formátum</h3>
<p>Írj programot, amelyik HTML formátumú fájlból eltávolítja a szedés jelöléseit, vagyis a
&lt;…&gt; szerű karaktersorozatokat, ezzel többé-kevésbé olvashatóvá téve azt normál szövegként.
(Például &lt;br&gt;, &lt;title&gt;).</p>



<h3>Szavak</h3>
<p>Írj olyan programot, amely külön-külön sorokban nyomtatja ki a bemenetére érkező szavakat!</p>

<h3>Szmájli számláló I.</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj állapotgépes programot, amely a szabványos bemenetről olvasott szövegben megszámolja a
szomorú :( és a vidám :) szmájlikat. A számlálás után kiírja, hogy a szöveg vidám, szomorú vagy
közömbös, azaz több, kevesebb vagy ugyanannyi :) volt, mint :(.</p>
<p>Tervezd meg az állapotgépet állapot- és tevékenységtáblával, utána írd meg a programot! A
programra csak akkor jár pont, ha állapotgépes és a leírt állapottáblát valósítja meg.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<table>
<thead>
<tr><th><th> : <th> (<th> ) <th> többi
</thead>
<tr><th>alap <td> &rarr;kp <td> - <td> - <td> -
<tr><th>kp <td> - <td> szom++, &rarr;alap <td> vid++, &rarr;alap <td> &rarr;alap
</table>
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
   enum Allapot { alap, kp } all;
   int szom, vid, c;

   all=alap;
   szom=vid=0;

   while ((c=getchar())!=EOF) {
      switch (all) {
         case alap:
            if (c==':') all=kp;
            break;
         case kp:
            if (c==')')      vid++;
            else if (c=='(') szom++;
            if (c!=':') all=alap;
            break;
      }
   }

   if (vid&gt;szom) printf(&quot;vidam&quot;);
   else if (szom&lt;vid) printf(&quot;szomoru&quot;);
   else printf(&quot;kozombos&quot;);

   return 0;
}</pre>

</div>
</div>








<h3>Szmájli számláló II.</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj állapotgépes programot, amely a szabványos bemenetről olvasott szövegben megszámolja a
szomorú :( és a vidám :) szmájlikat. A számlálás után kiírja, hogy a szöveg vidám, szomorú vagy
közömbös, azaz több, kevesebb vagy ugyanannyi :) volt, mint :(. A szmájlik zárójelenként egynek
számítanak, vagyis :))) három vidámat, :(( két szomorút jelent.</p>
<p>Tervezd meg az állapotgépet állapot- és tevékenységtáblával, utána írd meg a programot! A
programra csak akkor jár pont, ha állapotgépes és a leírt állapottáblát valósítja meg.</p>
<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<table>
<thead>
<tr><th><th> : <th> (<th> ) <th> többi
</thead>
<tr><th>alap <td> &rarr;kp <td> - <td> - <td> -
<tr><th>kp <td> - <td> szom++ <td> vid++ <td> &rarr;alap
</table>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
  enum Allapot { alap, kp } all;
  int szom, vid, c;

  all=alap;
  szom=vid=0;

  while ((c=getchar())!=EOF) {
    switch (all) {
      case alap:
        if (c==':') all=kp;
        break;
      case kp:
        if (c==')')   vid++;
        else if (c=='(') szom++;
        else if (c!=':') all=alap;
        break;
    }
  }

  if (vid&gt;szom) printf(&quot;vidam&quot;);
  else if (szom&lt;vid) printf(&quot;szomoru&quot;);
  else printf(&quot;kozombos&quot;);

  return 0;
}</pre>

</div>
</div>



<h3>Sz és zs számláló</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj állapotgépes programot, amely a szabványos bemenetről olvasott szövegben megszámolja az
„sz” és a „zs” betűket! (Hosszú ssz és zzs is egynek számítanak, azokkal külön nem kell
foglalkozni.) A számlálás után írd ki a szabványos kimenetre mindkettő darabszámát!</p>
<p>Tervezd meg az állapotgépet állapot- és tevékenységtáblával, utána írd meg a programot! A
programra csak akkor jár pont, ha állapotgépes és a leírt állapottáblát valósítja meg.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<table>
<thead>
<tr> <th> <th> s <th> z <th> többi
</thead>
<tr> <th>alap <td> &rarr;svolt <td> &rarr;zvolt <td> -
<tr> <th>svolt <td> - <td> sz++, &rarr;alap <td> &rarr;alap
<tr> <th>zvolt <td> zs++, &rarr;alap <td> - <td> &rarr;alap
</table>
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
  enum Allapot { alap, svolt, zvolt } all;
  int c, sz, zs;

  all=alap;
  sz=zs=0;

  while ((c=getchar())!=EOF) {
    switch (all) {
      case alap:
        if (c=='s') all=svolt;
        else if (c=='z') all=zvolt;
        break;
      case svolt:
        if (c=='z') sz++;
        if (c!='s') all=alap;
        break;
      case zvolt:
        if (c=='s') zs++;
        if (c!='z') all=alap;
        break;
    }
  }

  printf(&quot;sz: %d, zs: %d\n&quot;, sz, zs);

  return 0;
}</pre>

</div>
</div>

<h3>Dzs számláló</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj állapotgépes programot, amely a szabványos bemenetről olvasott szövegben megszámolja a
„dzs” betűket! (Hosszú ddzs egynek számít, nem kell külön foglalkozni vele.) A számlálás után
írd ki a szabványos kimenetre a darabszámot!</p>
<p>Tervezd meg az állapotgépet állapot- és tevékenységtáblával, utána írd meg a programot! A
programra csak akkor jár pont, ha állapotgépes és a leírt állapottáblát valósítja meg.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<table>
<thead>
<tr><th> <th> d <th> z <th> s <th> többi
</thead>
<tr><th> alap <td> &rarr;dvolt <td> - <td> - <td> -
<tr><th>dvolt <td> - <td> &rarr;dzvolt <td> &rarr;alap <td> &rarr;alap
<tr><th> dzvolt <td> &rarr;dvolt <td> &rarr;alap <td> dzs++, &rarr;alap <td> &rarr;alap
</table>
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
  enum Allapot { alap, dvolt, dzvolt } all;
  int c, dzs;

  all=alap;
  dzs=0;

  while ((c=getchar())!=EOF) {
    switch (all) {
      case alap:
        if (c=='d') all=dvolt;
        break;
      case dvolt:
        if (c=='d') ;
        else if (c=='z') all=dzvolt;
        else all=alap;
        break;
      case dzvolt:
        if (c=='s') dzs++;
        if (c=='d') all=dvolt;
        else all=alap;
        break;
    }
  }

  printf(&quot;dzs: %d\n&quot;, dzs);

  return 0;
}</pre>

</div>
</div>




<h3>C++ komment</h3>
<div class="sticky">Kis ZH volt</div>
<p>A feladat a szabványos bemenetről érkező szövegben (fájl vége jelig) megszámolni, hogy hány
C++ komment van benne, és a darabszámot kiírni. A C++ komment két / (per) jellel kezdődik, és a
sor végéig tart, pl.:
<pre>printf("Hello"); // Üdvözlet</pre>
Ha C++ kommenten belül van „//” karakterpár, az nem növeli a kommentek számát. Készíts
állapotgépes modellt állapottábla és tevékenységtábla megadásával, majd valósítsd meg C program
formájában!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int c, szaml = 0;
    enum Allapot { kod, pervolt, komment } all = kod;
    all = kod;
    while ((c = getchar()) != EOF) {
        switch (all) {
            case kod:
                if (c == '/')
                    all = pervolt;
                break;
            case pervolt:
                if (c == '/') {
                    szaml++;
                    all = komment;
                } else
                    all = kod;
            case komment:
                if (c == '\n')
                    all = kod;
                break;
        }
    }
    printf(&quot;%d darab komment&quot;, szaml);
    return 0;
}</pre>
</div>
</div>


<h3>Haskell komment</h3>
<div class="sticky">Kis ZH volt</div>
<p>A feladat a szabványos bemenetről érkező Haskell nyelvű programkódban megszámolni, hogy hány
komment van benne, és a darabszámot kiírni. A szöveg végét fájl vége jelzi. A Haskell komment
két - (mínusz) jellel kezdődik, és a sor végéig tart, pl.:
<pre>lesser = filter (&lt; p) xs -- kivalogatja a p-nel kisebbeket</pre>
Ha a kommenten belül van „--” karakterpár, az nem növeli a kommentek számát. Készíts
állapotgépes modellt állapottábla és tevékenységtábla megadásával, majd valósítsd meg C program
formájában!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    int c, szaml = 0;
    enum Allapot { kod, minuszvolt, komment } all = kod;
    all = kod;
    while ((c = getchar()) != EOF) {
        switch (all) {
            case kod:
                if (c == '-')
                    all = minuszvolt;
                break;
            case minuszvolt:
                if (c == '-') {
                    szaml++;
                    all = komment;
                } else
                    all = kod;
            case komment:
                if (c == '\n')
                    all = kod;
                break;
        }
    }
    printf(&quot;%d darab komment&quot;, szaml);
    return 0;
}</pre>
</div>
</div>



<h3>Üres sorok száma</h3>
<div class="sticky">Kis ZH volt</div>
<p>A feladat a szabványos bemenetről érkező szövegben (fájl vége jelig) megszámolni, hogy hány
üres sor van benne. A szöveget a szabványos kimenetre ki is kell írni változatlanul, majd a
szöveg után az üres sorok darabszámát. Üres sornak számít az, amiben nincs karakter, de az is,
amiben csak szóközök vannak. Készíts állapotgépes modellt állapottábla és tevékenységtábla
megadásával, majd valósítsd meg C program formájában!</p>


<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    enum Allapot { soreleje, sorbelseje } all = soreleje;
    int c, szaml = 0;
    while ((c = getchar()) != EOF) {
        putchar(c);
        switch (all) {
            case soreleje:
                if (c == '\n')
                    szaml++;
                else if (c != ' ')
                    all = sorbelseje;
                break;
            case sorbelseje:
                if (c == '\n')
                    all = soreleje;
                break;
        }
    }
    printf(&quot;%d ures sor volt.&quot;, szaml);
    return 0;
}</pre>
</div>
</div>



<h3>C sztring feldolgozása</h3>
<div class="sticky">Kis ZH volt</div>
<p>A feladat a szabványos bemenetről érkező C sztring feldolgozása: a szövegben szereplő \n, \t
és \" karakterpárokat a megfelelő karakterrel (újsor, tabulátor, idézőjel) helyettesíteni, és úgy
írni a szabványos kimenetre. (Egyéb \+karakter párok nem szerepelnek a sztringben, kezelésük
tetszőleges.) Készíts állapotgépes modellt állapottábla és tevékenységtábla megadásával, majd
valósítsd meg C program formájában! Pl. be:</p>
<pre>
hello \n    \"világ\"
</pre>
<p>ki:</p>
<pre>
hello
    "világ"!
</pre>


<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    enum Allapot { alap, visszaper } all = alap;
    int c;
    while ((c = getchar()) != EOF) {
        switch (all) {
            case alap:
                if (c == '\\')
                    all = visszaper;
                else
                    putchar(c);
                break;
            case visszaper:
                switch (c) {
                    case 'n':
                        putchar('\n');
                        break;
                    case 't':
                        putchar('\t');
                        break;
                    case '&quot;':
                        putchar('&quot;');
                        break;
                }
                all = alap;
                break;
        }
    }
    return 0;
}</pre>
</div>
</div>



<h3>A1llapotge1p</h3>

<p>A számítástechnika hőskorában nem lehetett magyar nyelvű
billentyűzetet kapni, sőt az operációs rendszerek még nem
támogatták a magyar nyelvű billentyűzetkiosztást sem.
Magyar nyelvű, ékezetes szövegeket azonban akkor is kellett
írni. Az egyik szövegfeldolgozó program úgy oldotta meg a problémát,
hogy az adott, ékezet nélküli magánhangzó után tett 1-es, 2-es és
3-as számjegyekkel jelezte a különféle ékezeteket. Az 1-es
jelezte a hosszú magánhangzót (pl. á = a1), a 2-es a két pontot
(pl. ö = o2), és a 3-as a csak a magyar nyelvben előforduló
hosszú ő és ű betű jelölésére szolgált (pl. ő = o3).</p>

<p>Írj állapotgépes programot, amely egy ilyen módon kódolt
szöveget átalakít rendes, ékezetes szöveggé!</p>

<p>Gondolkodtató részfeladatok:</p>

<ul>
    <li>Oldd meg, hogy hibás bemeneti kombinációkra hibajelzést
        adjon a program! Pl. az a2 kombináció hibás, mivel az ä betűt
        jelentené, amely viszont a magyar nyelvben nem használatos.
    <li>Érdemes minden magánhangzónak külön állapotot létrehozni?
        Ne felejtsd el, hogy összesen tíz állapotra vonatkozik ez a
        kérdés, hiszen nem csak az a, e, i, o és u karakterek után
        jelentenek mást az 1, 2 és 3 számjegyek, hanem az A, E, I, O és
        U karakterek után is. Lehetne valahogy paraméterezni az állapotokat?
</ul>






<h3>C++ kommentszűrő</h3>

<p>A C++ nyelvben a kommentek a <code>//</code> karakterekkel kezdődnek, és a sor végéig tartanak.
(Természetesen az egy <code>/</code> továbbra is osztást jelent.) Ezt a fajta kommentet olyan
kényelmesnek találta mindenki, hogy szép lassan a C-be is beépítették: a nyelv 1999-es, C99
szabványa már ismeri azt.</p>

<p>Írj programot, amelyik a szabványos bemenetén érkező, <code>//</code>-es kommenteket tartalmazó
forráskódból kiszűri a kommenteket! Figyelj arra, hogy ettől a program tördelése ne változzon meg:
ami eredetileg két sorba volt törve, az a kimeneten is így szerepeljen.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<table>
    <thead>
    <tr><th><th>/<th>\n<th>egyéb
    </thead>
    <tr><th>alap<td>&rarr;per<td>ki: c<td>ki: c
    <tr><th>per<td>komment<td>ki: /, \n<br>&rarr;alap<td>ki: /, c<br>&rarr;alap
    <tr><th>komment<td>-<td>ki: \n<br>&rarr;alap<td>-
</table>
</div>
</div>





<h3>C++ komment &rarr; C komment</h3>

<p>Egy C99 szabvány szerinti, <code>//</code>-es kommenteket is tartalmazó forráskódot szeretnénk
lefordítani egy nagyon régi C fordítóval, amely csak a <code>/*</code>-os kommenteket ismeri.
Alakítsd át úgy az előző kommentszűrődet, hogy a kitörlés helyett tartsa meg a <code>//</code>-es
kommenteket, de alakítsa át azokat <code>/*</code>-os formára!</p>

<p>Pl. ha a bemenete ilyen:</p>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    printf(&quot;Helló világ!\n&quot;);   // Üdvözlet
    return 0;
}</pre>

<p>Akkor a kimenete legyen ilyen:</p>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    printf(&quot;Helló világ!\n&quot;);   /* Üdvözlet */
    return 0;
}</pre>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<p>A megtalált komment elejénél kiír egy <code>/*</code> karaktersorozatot. A komment belsejében minden
karaktert kiír (ahogy máskor is). A komment végén, az újsor a karakternél pedig kiírja a bezáró
<code>*/</code>-ot, és persze az újsort is (hogy a forráskód tördelése ne változzon).</p>

<table>
    <thead>
    <tr><th><th>/<th>\n<th>egyéb
    </thead>
    <tr><th>alap<td>&rarr;per<td>ki: c<td>ki: c
    <tr><th>per<td>ki: /*<br>&rarr;komment<td>ki: /, \n<br>&rarr;alap<td>ki: /, c<br>&rarr;alap
    <tr><th>komment<td>ki: c<td>ki: */\n<br>&rarr;alap<td>ki: c
</table>

</div>
</div>



<h3>Kommentszűrő táblázattal</h3>

<p>Dolgozd át a fenti kommentszűrő programot úgy, hogy a program kódjában
is táblázatos állapotgép szerepeljen: <a href="ea06.html#tablazatos">lásd az előadásanyagot</a>.</p>
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="f06.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="index.html"><img src="modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="index.html">főoldal</a> · <a href="elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
