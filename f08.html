<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: 8. hét: dinamikus memóriakezelés</title>
<meta property="og:title" content="InfoC :: 8. hét: dinamikus memóriakezelés">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="Gyakorlófeladatok a 8. előadás anyagához kapcsolódóan.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="Gyakorlófeladatok a 8. előadás anyagához kapcsolódóan.">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="modulz/logo_touch.png">
<link rel="image_src" href="modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<script>infoc.onloads.push(function(){ h3toid(); });
</script>
<link rel="stylesheet" href="modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="modulz/style/localfonts.css@v10.css">
<script src="modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="index.html">InfoC</a></div>
<ul>
<li class="al "><a href="f08.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="index.html">Kezdőlap</a>
<li><a href="nhf.html">Nagy házi feladat</a>
<li><a href="elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="f08.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="f08.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="ea01.html">1. hét: bevezetés</a>
<li><a href="ea02.html">2. hét: algoritmusok</a>
<li><a href="ea03.html">3. hét: tételek, tömbök</a>
<li><a href="ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="ea09.html">9. hét: láncolt listák</a>
<li><a href="ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="ea12.html">12. hét: bináris fák</a>
<li><a href="ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="f08.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="gy02.html">2. hét: algoritmizálás</a>
<li><a href="gy03.html">3. hét: egyszerű programok</a>
<li><a href="gy04.html">4. hét: tételek és tömbök</a>
<li><a href="gy05.html">5. hét: függvények</a>
<li><a href="gy06.html">6. hét: származtatott típusok</a>
<li><a href="gy07.html">7. hét: mutatók használata</a>
<li><a href="gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="gy11.html">11. hét: láncolt listák I.</a>
<li><a href="gy12.html">12. hét: láncolt listák II.</a>
<li><a href="gy13.html">13. hét: bináris fák</a>
<li><a href="gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="f08.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="lab01.html">1. hét: operációs rendszer</a>
<li><a href="lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="lab03.html">3. hét: egyszerű programok</a>
<li><a href="lab04.html">4. hét: tömbök</a>
<li><a href="lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="lab11.html">11. hét: láncolt listák</a>
<li><a href="lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="lab13.html">13. hét: bináris fák</a>
<li><a href="lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="f08.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="f01.html">1. hét: egyszerű programok</a>
<li><a href="f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="f09.html">9. hét: láncolt listák</a>
<li><a href="f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="f08.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="jegyzet.html">Jegyzet és puska</a>
<li><a href="fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="stilus.html">Kódolási stílus</a>
<li><a href="tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="debugmalloc.html">Debugmalloc</a>
<li><a href="mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="f08.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="f08.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="orak.html">SVG óra galéria</a>
<li><a href="angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="f08.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="turing.html">Mit tud a számítógép?</a>
<li><a href="bf.html">BF</a>
<li><a href="bitturmix.html">Bitturmix</a>
<li><a href="labirintus.html">Labirintusok</a>
<li><a href="tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="f08.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="karakterkodolas.html">Karakterkódolások</a>
<li><a href="strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="internet.html">Internet</a>
</ul>

<li class="al "><a href="f08.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="sdl.html">SDL grafika</a>
<li><a href="sdl_telepito.html">SDL telepítés</a>
<li><a href="fa.html">Fák rajzolása</a>
<li><a href="lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="f08.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="mondatelemzo.html">Mondatelemző</a>
<li><a href="kifejezesek.html">Kifejezések</a>
<li><a href="derivalas.html">Deriválás</a>
<li><a href="ast_epit.html">AST: szintaxisfák</a>
<li><a href="ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<a id="feladatdinamikus" class="namer"></a>
<h1 class="eloadascim">8. hét: dinamikus memóriakezelés</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán, Nagy Gergely, Pohl László · <i class="ido"></i> 2015.02.18 · Frissítve: 2015.02.15</p>
<p class="kivonat">Gyakorlófeladatok a 8. előadás anyagához kapcsolódóan.</p>
</div>


<p>Ezen az oldalon rengeteg feladat található a gyakorláshoz. Egy részük megoldással együtt, míg 
a többi anélkül. A gyakorlófeladatok megoldásához elvileg elegendő az az ismeretanyag, amely az előadáson 
szerepelt. Természetesen a megoldás kitalálásához szükség lehet arra a rálátásra és 
tapasztalatra, amit a gyakorlatok és a laborok adnak. A feladatok témakörök szerinti 
csoportosítása viszont ettől függetlenül az előadást követi.</p>

<p>Felhívjuk a figyelmed arra, hogy a megoldások olvasgatása lényegében nulla 
tapasztalatot és gyakorlatot ad, így az eredményes számonkérésekhez nem tud hozzásegíteni! A 
megoldásokat akkor nézd csak meg, ha a saját megoldás elkészítése közben elakadsz.
Lásd <a href="tanacsok.html">itt</a>.</p>

<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="f08.html#1">Dinamikusan foglalt tömbök</a>
<li><a href="f08.html#2">Több dimenziós tömbök</a>
<li><a href="f08.html#3">Dinamikusan foglalt struktúrák</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>Dinamikusan foglalt tömbök</h2>
</div>

<h3>Miért hibás?</h3>

<p>Miért nem írhatunk ilyet C-ben? Mondj legalább két okot, ami miatt ez lehetetlen!</p>

<pre class="brush: cbub "  >
struct Hibas {
    int db;
    double szamok[db];  // HIBÁS
};</pre>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<ul>
    <li>Egy struktúra mérete fordítási idejű konstans kell legyen. Ezért nem lehet a struktúrában
        olyan tömb, amelynek méretét változóval adjuk meg.
    <li>Ha megadhatnánk változóval, még akkor is memóriaszemét lenne a <code>db</code>, amikor
        egy <code>struct Hibas</code> típusú változót hozunk létre – tehát akkor mekkora lenne a tömb?
</ul>
</div>
</div>

<h3>Dinamikusan foglalt sztring</h3>
<p>Készíts függvényt, amely megkap egy stringre mutató pointert és 
visszatér egy újonnan foglalt string címével, amely a paraméterstring 
kisbetűs elemeit tartalmazza az eredeti sorrendben. Az új string számára 
pontosan annyi helyet foglaljon, amennyire szükség van!</p>

<h3>Dinamikus squeeze</h3>
<div class="sticky">Kis ZH volt</div>
<p>Írj függvényt, amelyik két sztringet vár paraméterként. Az első sztring egy feldolgozandó 
szöveget tartalmaz, a második pedig mindenféle karaktereket. A függvény feladata, hogy 
visszatérjen egy olyan dinamikusan foglalt sztringgel, amely úgy keletkezik, hogy az elsőből 
kihagy minden olyan karaktert, amelyik a másodikban szerepel. Pl. ha a bemenet <code>"almale"
</code> és <code>"aeoiu"</code>, a kimenet <code>"lml"</code> (elhagyta a magánhangzókat). 
Pontosan annyi memóriát foglalj, amennyire szükség van! Írj programrészt, amelyben bemutatod a 
függvény használatát. A <code>string.h</code> függvényei használhatóak.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Tipp</a></h4>
<div class="megjelenik csik">
<p>Forgasd ki az <code>strchr</code>-t: mintha a <code>karakterek</code> tömb egy halmaz lenne,
megpróbálsz megkeresni egy karaktert. Ha meglesz, nem <code>NULL</code> pointerrel tér vissza.
Persze nem muszáj így csinálni, egy „van-e benne” ciklus megteszi.</p>
</div>
</div>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<pre class="brush: c "  >
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char *szur(char *be, char *karakterek) {
    int ujhossz;
    int i;
    int cel;
    char *uj;

    ujhossz=0;
    /* vegigmegyunk az eredetin */
    for (i=0; be[i]!=0; i++)
        /* ha NEM talalhato...
         * azt strchr NULL-t ad, ha nincs benne az a karakter. */
        if (!strchr(karakterek, be[i]))
            ujhossz++;

    uj=(char *) malloc(ujhossz+1);
    cel=0;
    for (i=0; be[i]!=0; i++)
        /* ha NEM talalhato...
         * azt strchr NULL-t ad, ha nincs benne az a karakter. */
        if (!strchr(karakterek, be[i]))
            uj[cel++]=be[i];
    /* 0 a sztring vegere */
    uj[cel]=0;
    return uj;
}

int main(void) {
    char *szurt;

    szurt=szur(&quot;kortefa&quot;, &quot;aeiou&quot;);
    printf(&quot;[%s]\n&quot;, szurt);
    free(szurt);

    return 0;
}</pre>

</div>
</div>




<h3>Dinamikus trim()</h3>
<div class="sticky">Kis ZH volt</div>
<p>
Írj függvényt, amelyik egy paraméterként kapott sztring
elejéről és végéről eltávolítja a szóköz karaktereket
(a többi maradjon)! A bemeneti, paraméterben kapott sztringet
ne változtassa meg; a visszatérési értéke legyen egy dinamikusan
foglalt tömb, amelyik az új sztringet tartalmazza.
Egy bájttal se foglalj több dinamikus memóriát, mint amennyi
szükséges! Pl. ha a bemenet <code>"&nbsp;&nbsp;helló, mizu?&nbsp;&nbsp;"</code>,
akkor a kimenet <code>"helló, mizu?"</code> legyen. Írj
programrészt, amelyben bemutatod a függvény használatát.
A <code>string.h</code> függvényei használhatóak.
</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<img src="f08/kzh-strtrim.svg" alt="A szóközök eltávolítása a sztring elejéről és végéről" class="kozep" style="width: 24em;">
<p>Ennek az szokott lenni a neve, hogy <code>strstrip</code> vagy <code>trim</code>.</p>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char *strtrim(const char *forras) {
    int eleje, vege;
    char *uj;
    int f, c;

    /* az elejen atugorjuk a spaceket, az elso nem
     * space karakterig. ami amugy 0 is lehet. */
    eleje=0;
    while (forras[eleje]==' ')
        eleje++;

    /* ezzel pedig eloszor tenyleg elmegyunk a vegeig */
    vege=0;
    while (forras[vege]!=0)
        vege++;
    vege--; /* ez az utolso karakter indexe */
    /* aztan visszajovunk a spaceknel is. */
    while (vege&gt;0 &amp;&amp; forras[vege]==' ')
        vege--;
    /* a kovetkezo vege++-szal a veget beallitom az utolso
     * utani karakterre. ezt igy szokas csinalni: eleje
     * az elso karakterre mutat, vege az utolso UTANIRA.
     * a tomboknel ugyanez van: 100 elemu tomb, 0 az eleje,
     * 99 a vege, vagyis a 100-as indexu az utolso utani.
     * &quot;  hello, mizu?  &quot;
     *    ^eleje      ^vege
     */
    vege++;

    /* vege&lt;eleje akkor tortenhet, ha a sztring csak spaceket
     * tartalmazott. mert akkor az eleje indexszel a vegen
     * allunk (strlen(forras)-1), es a vege indexszel az elejen (0). */
    if (vege&lt;eleje)
        vege=eleje;

    /* ennyi karakter kell; +1, a lezaro 0 miatt */
        /* itt pl jol jon, hogy vege az utolso utani karakter, mert
         * vege-eleje a masolando sztring hosszat adja, nem eggyel
         * kevesebbet. */
    uj=(char *) malloc(vege-eleje+1);

    /* masolom a karaktereket. egyutt futo ciklusvaltozok!
     * itt is jo, hogy a vege az utolso utanira mutat, mert a
     * szokasos &lt; osszehasonlitast hasznalom. */
    for (f=eleje, c=0; f&lt;vege; f++, c++)
        uj[c]=forras[f];
    uj[c]=0;        /* lezaro 0 */

    return uj;
}

int main(void) {
    char *uj;

    uj=strtrim(&quot;  hello, mizu?  &quot;);
    printf(&quot;[%s]\n&quot;, uj);
    free(uj);

    return 0;
}</pre>
</div>
</div>
















<h3>Dinamikus strjoinv()</h3>
<div class="sticky">Kis ZH volt</div>

<p>Írj egy függvényt, amelyik paraméterként kapott sztringeket fűz össze, közéjük a megadott 
karaktert téve elválasztónak! A függvény első paramétere a bemenő sztringek tömbje, amelynek 
legutolsó tagja egy null pointer (az jelzi a végét), a második paraméter pedig az elválasztó 
karakter. Visszatérési értéke legyen egy dinamikusan foglalt sztring, amelyik éppen akkora, hogy 
belefér az eredmény. Pl. bemenetek: <code>{ "alma", "korte", "narancs", NULL }</code> és
<code>';'</code>, kimenet: <code>"alma;korte;narancs"</code>. Írj programrészt, amelyben bemutatod a 
függvény használatát. A <code>string.h</code> függvényei használhatóak.</p>


<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<img src="f08/kzh-sztringtomb.svg" alt="Az strjoinv() függvény működése" class="kozep" style="width: 28em;">
<p>Ez is klasszikus feladat, <code>strjoinv</code> vagy <code>implode</code> néven.
Lent a kódban az egykarakteres <code>elv[]</code> sztring
pedig gyakorlatilag <code>sprintf("elv", "%c", elvalaszto)</code>.
Azért csináltam, hogy az elválasztót is lehessen <code>strcat()</code>-olni.
Gyakorlatilag a karakterből <code>';'</code> sztring lesz <code>";"</code>.</p>

<pre class="brush: c "  >
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char *osszerak(char **sztringek, char elvalaszto) {
    int hossz, i;
    char elv[2], *uj;

    hossz=0;
    for (i=0; sztringek[i]!=NULL; ++i)
        /* az i. sztring hossza, es utana az elvalaszto char */
        hossz+=strlen(sztringek[i])+1;

    /* +1 a lezaro 0, -1 hogy nincs utolso elvalaszto... szoval most pont jo */

    uj=(char *) malloc(hossz);
    strcpy(uj, &quot;&quot;);

    /* ez egy egykarakteres sztring */
    elv[0]=elvalaszto;
    elv[1]=0;

    for (i=0; sztringek[i]!=NULL; ++i) {
        strcat(uj, sztringek[i]);
        if (sztringek[i+1]!=NULL)
            /* ha lesz meg, akkor teszek elvalasztot */
            strcat(uj, elv);
    }

    return uj;
}

int main(void) {
    char *sztringek[]={&quot;alma&quot;, &quot;korte&quot;, &quot;narancs&quot;, NULL};
    char *uj;

    uj=osszerak(sztringek, ';');
    printf(&quot;[%s]\n&quot;, uj);
    free(uj);

    return 0;
}</pre>

</div>
</div>




<h3>Dinamikus sztring</h3>
<div class="sticky">Kis ZH volt</div>
<p>Definiálj egy olyan DinSztring struktúrát, amely egy tetszőlegesen hosszú sztring karaktereit 
tárolja dinamikus tömbben, és annak hosszát is megjegyzi (a tömb nincsen nullával lezárva)!</p>
<p>Írj függvényt, amely átvesz paraméterként egy ilyen sztringet, és úgy módosítja a tartalmát, 
hogy abból eltűnnek a szóközök! Pl. „egy ilyen sztring”-ből „egyilyensztring” lesz. A foglalt 
tömbnek mindig pont akkorának kell lennie, amennyi a karakterek tárolásához szükséges. A 
szükséges fejlécfájlokat jelezd!</p>
<p>Írj rövid programrészt, amelyben definiálsz egy ilyen változót, és azzal a feltételezéssel, 
hogy már tartalmaz valamit, szóközteleníted.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

typedef struct DinSztring {
    int meret;
    char *betuk;
} DinSztring;

void spacetelenit(DinSztring *ds) {
    int i, j, kell;
    char *uj;
    
    kell=0;
    for (i=0; i&lt;ds-&gt;meret; ++i)
        if (ds-&gt;betuk[i]!=' ')
            ++kell;
    uj = (char*) malloc(kell*sizeof(char));
    j=0;
    for (i=0; i&lt;ds-&gt;meret; ++i)
        if (ds-&gt;betuk[i]!=' ')
            uj[j++] = ds-&gt;betuk[i];
    
    free(ds-&gt;betuk);
    ds-&gt;betuk = uj;
    ds-&gt;meret = kell;
}

int main(void) {
    DinSztring szoveg;  /* a mainbol csak ez a sor kellett */
    
    szoveg.meret = strlen(&quot;ez egy szoveg&quot;);
    szoveg.betuk = (char*) malloc(sizeof(char)*szoveg.meret);
    strncpy(szoveg.betuk, &quot;ez egy szoveg&quot;, szoveg.meret);
    
    spacetelenit(&amp;szoveg);  /* es ez a sor */
    
    int i;
    for (i=0; i&lt;szoveg.meret; ++i)
        putchar(szoveg.betuk[i]);
    free(szoveg.betuk);
    
    return 0;
}</pre>
</div>
</div>




<h3>Dinamikus sztring II.</h3>
<div class="sticky">Kis ZH volt</div>
<p>Definiálj egy olyan DinSztring struktúrát, amely egy tetszőlegesen hosszú sztring karaktereit 
tárolja dinamikus tömbben, és annak hosszát is megjegyzi (a tömb nincsen nullával lezárva)!</p>
<p>Írj függvényt, amely átvesz paraméterként egy ilyen sztringet, és madárnyelvesíti a sztringet: 
minden magánhangzó után betesz egy v betűt, és újra a magánhangzót (mavadávárnyelv). Ehhez 
tételezd fel, hogy van egy maganhangzo() függvény, amely igazat ad vissza magánhangzó 
karakterekre. A foglalt tömbnek pont akkorának kell lennie, amennyi a karakterek tárolásához 
szükséges. A szükséges fejlécfájlokat jelezd!</p>
<p>Írj rövid programrészt, amelyben definiálsz egy ilyen DinSztring változót, és azzal a 
feltételezéssel, hogy már tartalmaz valamit, madárnyelvesíted.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

typedef struct DinSztring {
    int meret;
    char *betuk;
} DinSztring;

/* ez a fuggveny nem kellett */
int maganhangzo(char c) {
    return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';
}

void madar(DinSztring *ds) {
    int i, j, kell;
    char *uj;
    
    kell=0;
    for (i=0; i&lt;ds-&gt;meret; ++i)
        kell += maganhangzo(ds-&gt;betuk[i]) ? 3 : 1;
    
    uj = (char*) malloc(kell*sizeof(char));
    
    j=0;
    for (i=0; i&lt;ds-&gt;meret; ++i) {
        uj[j++] = ds-&gt;betuk[i];
        if (maganhangzo(ds-&gt;betuk[i])) {
            uj[j++] = 'v';
            uj[j++] = ds-&gt;betuk[i];
        }
    }
    
    free(ds-&gt;betuk);
    ds-&gt;betuk = uj;
    ds-&gt;meret = kell;
}

int main(void) {
    DinSztring szoveg;  /* a mainbol csak ez a sor kellett */
    
    szoveg.meret = strlen(&quot;ez egy szoveg&quot;);
    szoveg.betuk = (char*) malloc(sizeof(char)*szoveg.meret);
    strncpy(szoveg.betuk, &quot;ez egy szoveg&quot;, szoveg.meret);
    
    madar(&amp;szoveg);  /* es ez a sor */
    
    int i;
    for (i=0; i&lt;szoveg.meret; ++i)
        putchar(szoveg.betuk[i]);
    free(szoveg.betuk);
    
    return 0;
}</pre>
</div>
</div>


<h3>Dinamikus halmaz</h3>
<div class="sticky">Kis ZH volt</div>
<p>Definiálj egy olyan Halmaz struktúrát, amely egy elemszámot, és a halmaz elemeit (egész 
típusúak) képes tárolni egy dinamikus tömbben!</p>
<p>Írj függvényt, amely paraméterként kap egy ilyen halmazt, és egy számot. Távolítsa el a függvény 
a halmazból azokat a számokat, amelyek kisebbek a paraméterben kapottnál! A lefoglalt tömbnek 
mindig pont akkorának kell lennie, mint amennyi elem van. A szükséges fejlécfájlokat jelezd!</p>
<p>Írj rövid programrészt, amelyben definiálsz egy halmaz változót, és azzal a feltételezéssel, 
hogy már vannak benne adatok, kiveszed belőle a 20-nál kisebbeket!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Halmaz {
    int meret;
    double *szamok;
} Halmaz;

void kisebbeket_kivesz(Halmaz *h, double minel) {
    int i, j, kell;
    double *uj;
    
    kell = 0;
    for (i=0; i&lt;h-&gt;meret; ++i)
        if (!(h-&gt;szamok[i]&lt;minel))
            ++kell;
    
    uj = (double*) malloc(sizeof(double)*kell);
    j = 0;
    for (i=0; i&lt;h-&gt;meret; ++i)
        if (!(h-&gt;szamok[i]&lt;minel))
            uj[j++] = h-&gt;szamok[i];
    
    free(h-&gt;szamok);
    h-&gt;szamok = uj;
    h-&gt;meret = kell;
}

int main(void) {
    Halmaz h;  /* a mainbol csak ez a sor kellett */
    int i;
    
    h.meret = 5;
    h.szamok = (double*) malloc(sizeof(double)*5);
    for (i=0; i&lt;5; ++i)
        h.szamok[i]=i*15;
    
    kisebbeket_kivesz(&amp;h, 20);  /* es ez a sor */

    for (i=0; i&lt;h.meret; ++i)
        printf(&quot;%g &quot;, h.szamok[i]);
    free(h.szamok);
    
    return 0;
}</pre>
</div>
</div>

<h3>Dinamikus tömb</h3>
<div class="sticky">Kis ZH volt</div>
<p>Definiálj olyan DinTomb struktúrát, amely egész típusú számokat (tetszőlegesen sokat)
képes tárolni egy dinamikus tömbben, és melléjük eltárolja a darabszámukat is!</p>
<p>Írj függvényt, amely paraméterként kap egy ilyen DinTomb-ot, és kiszűri (eldobja) belőle a 
negatív számokat! Pl. ha az eredeti tartalom 3, 5, -1, 0, -3, 7, akkor a 
szűrés után a 3, 5, 0, 7 számok kell, hogy benne legyenek. A foglalt tömbnek 
pontosan akkorának kell lennie, amekkorában a számok éppen elférnek. A szükséges fejlécfájlokat 
jelezd!</p>
<p>Írj rövid programrészt, amelyben definiálsz egy DinTomb változót, és azzal a feltételezéssel,
hogy már vannak benne számok, kiszűröd belőle a negatívakat!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct DinTomb {
    int meret;
    int *szamok;
} DinTomb;

void negativakat_kivesz(DinTomb *h) {
    int i, j, kell;
    int *uj;
    
    kell = 0;
    for (i=0; i&lt;h-&gt;meret; ++i)
        if (!(h-&gt;szamok[i]&lt;0))
            ++kell;
    
    uj = (int*) malloc(sizeof(int)*kell);
    j = 0;
    for (i=0; i&lt;h-&gt;meret; ++i)
        if (!(h-&gt;szamok[i]&lt;0))
            uj[j++] = h-&gt;szamok[i];
    
    free(h-&gt;szamok);
    h-&gt;szamok = uj;
    h-&gt;meret = kell;
}

int main(void) {
    DinTomb h;  /* a mainbol csak ez a sor kellett */
    int i;
    
    h.meret = 5;
    h.szamok = (int*) malloc(sizeof(int)*5);
    for (i=0; i&lt;5; ++i)
        h.szamok[i]=i*15-30;
    
    negativakat_kivesz(&amp;h);  /* es ez a sor */

    for (i=0; i&lt;h.meret; ++i)
        printf(&quot;%d &quot;, h.szamok[i]);
    free(h.szamok);
    
    return 0;
}</pre>
</div>
</div>


<h3>Adatok a 7 bites csatornán</h3>

<div class="sticky">Vizsga volt</div>

<p>Adott egy tömbünk, 8 bites <code>unsigned char</code> elemekből. Ezt kellene egy olyan 
csatornán átküldenünk, amely csak 7 bites átvitelt támogat. Ezért a tömböt egy sztringgé 
alakítjuk. Ha a benne lévő bájt 32 és 127 közötti (zárt intervallum), azt egy az egyben 
megjelenítjük a sztringben; ha ezen kívüli, <code>\</code> bevezető után a nyolcas 
számrendszerbeli jelöljük (mindig 3 számjeggyel, így pl. a sortörésből <code>\012</code> lesz, 
mert 10 az ASCII kódja). A backslash karaktert a sztringben úgy jelöljük, ahogy azt C-ben szokás 
(<code>"\\"</code>).</p>

<p>Írj egy függvényt, amelynek bemeneti paraméterei a tömb és annak mérete; visszatérési értéke 
egy dinamikusan foglalt sztring, amelyik a kódolt szöveget tartalmazza. Pontosan annyi memóriát 
foglalj, amennyire szükség van!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char *strescape(unsigned char *input, int meret) {
    int i;
    int ujhossz, idx;
    char *uj;

    ujhossz=0;
    for (i=0; i&lt;meret; i++)
        if (input[i]&lt;32 || input[i]&gt;=128)
            ujhossz+=4; /* ez ilyen lesz, mint pl \012, szoval 4 betu */
        else if (input[i]=='\\')
            ujhossz+=2; /* mert ezt \\ formaban jeloljuk majd */
        else
            /* ha nem az a tartomany, akkor siman megy a char -&gt; 1 betu */
            ujhossz+=1;

    uj=(char *) malloc((ujhossz+1)*sizeof(char));
    idx=0;
    for (i=0; i&lt;meret; i++)
        if (input[i]&lt;32 || input[i]&gt;=128) {
            uj[idx++]='\\';
            uj[idx++]='0'+input[i]/8/8;
            uj[idx++]='0'+input[i]/8%8;
            uj[idx++]='0'+input[i]%8;
        }
        else if (input[i]=='\\') {
            uj[idx++]='\\';
            uj[idx++]='\\';
        }
        else
            uj[idx++]=input[i];
    uj[idx]=0; /* lezaro 0 */

    return uj;
}

int main(void) {
    unsigned char tmb[]={'h', 'e', 'l', '\n', 'l', 'o',
                         '\\', '!', 012, 0377, '3'};
    char *uj=strescape(tmb, sizeof(tmb));
    printf(&quot;[%s]\n&quot;, uj);
    free(uj);
    return 0;
}</pre>

</div>
</div>



<h3>Adatok a 7 bites csatornán – visszafelé</h3>

<p>Írd meg azt a programot, amely az előző feladat által előállított kimenetből visszaállítja
annak bemenetét!</p>



</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>Több dimenziós tömbök</h2>
</div>

<h3>Tó mélysége</h3>

<p>Egy tóra négyzethálót fektetünk, és minden rácspontban megmérjük a víz 
mélységét, amit egy n×m méretű kétdimenziós valós tömbben tárolunk. A 
négyzetháló szélső rácspontjai a szárazföldön vannak. Készíts programot, 
mely meghatározza a leggyorsabban mélyülő helyet.</p>


<h3>SMS</h3>

<div class="sticky">Vizsga volt</div>

<p>Írj sms-billentyűlenyomásokat dekódoló függvényt! Az adott telefonon a következő gombok 
megfelelő számú lenyomásával a keletkező karakterek:

0: space
1: .,!
2: abc
3: def
4: ghi
5: jkl
6: mno
7: pqrs
8: tuv
9: wxyz.

Definiálj struktúrát, amelyik azt tárolja, egy adott gombot hányszor nyomtak le. A függvényed 
dekódoljon egy ilyen struktúrákból álló tömböt, és az eredményt egy paraméterként kapott 
stringben adja vissza!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

struct lenyomas {
    int mit, hanyszor;
};

void dekodol(char eredmeny[], struct lenyomas be[]) {
    /* ez egy két dimenziós tömb. az első dimenzió az, hogy melyik gomb
     * lett megnyomva (0-9), a második pedig egy karaktertömb, amelyben
     * az annyiadik indexen (-1) van egy karakter, ahányszor az adott gombot
     * meg kell nyomni. */
    char betuk[][5] = {&quot; &quot;, &quot;.,!&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
    int db;

    for (db = 0; be[db].mit != -1; db++)
        eredmeny[db] = betuk[be[db].mit][be[db].hanyszor-1];
    eredmeny[db] = '\0';
}

int main(void) {
    struct lenyomas bevitel[] = {
        {4, 2},
        {3, 2},
        {5, 3},
        {5, 3},
        {6, 3},
        {1, 3},
        {-1, 0},        /* lezáró elem */
    };
    char eredmeny[161]; /* max 160 karakteres egy sms */

    dekodol(eredmeny, bevitel);
    printf(&quot;%s\n&quot;, eredmeny);

    return 0;
}</pre>
</div>
</div>









<h3>Jégtömbök</h3>

<pre class="screenshot sorsurit1 float">
[........]
[..####..]
[..#####.]
[..#####.]
[...####.]
[...###..]
[..###...]
[........]
</pre>

<pre class="screenshot sorsurit1 float" style="clear: none;">
[        ]
[  1221  ]
[  23321 ]
[  14432 ]
[   4321 ]
[   321  ]
[  121   ]
[        ]
</pre>


<p>Jégtömböket írunk le egy táblázat segítségével. A kereszttel jelölt pontok jelölik a jégtömbbe 
tartozó pozíciókat. Ha a jégtömbre meleg levegőt fújunk, akkor a szélén olvad­ni kezd, s a 
keletkezett víz elfolyik. Az olvadás szabálya: egy időegység alatt abban a mező­ben levő jég 
olvad el (s tűnik el a táblázatból), amelynek 4 oldal-szomszédja közül legalább 2 levegő volt. 
(Ilyenek az ábrán 1-es számmal jelölt pontok.) Ezután keletkezhetnek újabb ilyen tulajdonságú 
pontok (az ábrán 2-vel jelöljük őket), amelyek a 2. időegységben olvadnak el és így tovább.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int olvaszt(char *tomb, int szel, int mag) {
    char *olvadhat_e;
    int olvadt;
    int x, y;
    
    olvadhat_e=malloc(szel*mag);
    for (y=0; y&lt;mag; y++) {
        for (x=0; x&lt;szel; x++) {
            int db;
            
            db=0;
            /* barhol: sze'len vagyunk vagy ures a szomszed, az jo. */
            if (x&gt;0 &amp;&amp; !tomb[(x-1)+y*szel]) db++;
            if (y&gt;0 &amp;&amp; !tomb[x+(y-1)*szel]) db++;
            if (x&lt;szel-1 &amp;&amp; !tomb[x+1+y*szel]) db++;
            if (y&lt;mag-1 &amp;&amp; !tomb[x+(y+1)*szel]) db++;
            olvadhat_e[x+y*szel]=db&gt;=2;
        }
    }
    
    olvadt=0;
    for (y=0; y&lt;mag; y++)
        for (x=0; x&lt;szel; x++)
            if (olvadhat_e[x+y*szel])
                if (tomb[x+y*szel]) {
                    olvadt++;
                    tomb[x+y*szel]=0;   /* elolvadt */
                }
    
    free(olvadhat_e);
    
    return olvadt;  /* ennyi olvadt el */
}

void kiir(char *tomb, int szel, int mag) {
    int x, y;
    
    for (y=0; y&lt;mag; y++) {
        printf(&quot;[&quot;);
        for (x=0; x&lt;szel; x++)
            printf(&quot;%c&quot;, tomb[y*szel+x]?'#':'.');
        printf(&quot;]\n&quot;);
    }
    printf(&quot;\n&quot;);
}

int main(void) {
    int szel=8;
    int mag=8;
    int x, y;
    char tomb[szel*mag];
    int kor;
    
    for (x=0; x&lt;szel; x++)
        for (y=0; y&lt;mag; y++)
            tomb[szel*y+x]=0;
    
    for (x=0; x&lt;szel*mag; x++)
        tomb[rand()%(szel-2)+1+szel*(rand()%(mag-2)+1)]=1;

    kiir(tomb, szel, mag);
    kor=0;
    while (olvaszt(tomb, szel, mag)&gt;0) {
        ++kor;
        kiir(tomb, szel, mag);
    }
    
    printf(&quot;%d körben olvadt.\n&quot;, kor);
    return 0;
}</pre>
</div>
</div>





</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>Dinamikusan foglalt struktúrák</h2>
</div>

<h3>Dinamikusan foglalt struktúra</h3>

<p>A gyakorlat halmaz struktúrájához hasonlóan csináld meg azt, hogy a labor 
sztring struktúrája is dinamikusan legyen foglalva, ne csak a tárolt adat! A <em>
létrehozó</em> függvény itt is térjen vissza a lefoglalt struktúrára mutató 
pointerrel. Sztring használatához így nem struktúrát, hanem pointert kell majd 
definiálni:</p>

<pre class="brush: c "  >
DinSztring *sz;

sz=dinsztring_letrehoz(&quot;hello, vilag&quot;);
dinsztring_kiir(sz);
dinsztring_felszabadit(sz);</pre>

<p>Természetesen a felszabadításnak ilyenkor a struktúrát és fel kell 
szabadítania majd.</p>


<h3>Sztring létrehozása másolatként</h3>

<p>Írj függvényt, amely paraméterként kap egy <code>DinSztring</code>-et,
és <em>létrehoz</em> egy másikat, amely másolata annak. Ez is az
újra mutató pointerrel térjen vissza, mint az előbbi. Mi a különbség
eközött, és az értékadás között? Használható a fent megírt értékadás
függvény a dinamikusan foglalt struktúrák esetében?</p>

<h3>Beszúrás</h3>

<p>Írj függvényt, amely egy <code>DinSztring</code>-be egy adott helyen
beszúrja a másik tartalmát. Pl. a „hellóvilág” szövegbe az ötödik indexnél
beszúrt sztring:</p>

<table class="tomb">
   <tr>
      <td>0
      <td>1
      <td>2
      <td>3
      <td>4
      <td class="piros">5
      <td>6
      <td>7
      <td>8
      <td>9
      <td>10
      <td>11
   
   <tr>
      <td>h
      <td>e
      <td>l
      <td>l
      <td>o
      <td class="piros">,
      <td class="piros">&nbsp;
      <td>v
      <td>i
      <td>l
      <td>a
      <td>g
   
</table>

<h3>További, nagyobb feladat: a <code>malloc()</code>–<code>free()</code> hívások számának csökkentése</h3>

<p>A fenti megoldásban elég gyakran hívódik a <code>malloc()</code> és <code>free()</code>
függvény. Akár egy karakter hozzáfűzése miatt is másolódik a sztring. Alakítsd át
a sztringkezelő függvényeket ezért úgy, hogy mindig egy kicsivel több memóriát
foglaljanak, mint amennyi szükséges. Így pedig csak akkor foglaljanak újra, ha az is betelik.
Ehhez vegyél fel a struktúrába egy új integert (kapacitás), amely a lefoglalt terület nagyságát
tárolja. Természetesen méret&le;kapacitás minden esetben, hiszen a tárolt szöveg
nem lehet nagyobb a lefoglalt területnél. Az összes függvényt
ehhez újra kell írni, hogy figyelembe vegyék a kapacitás adattagot is.
</p>

<p>A függvények kidolgozása előtt találj ki egy stratégiát: hogyan 
viszonyuljon a kapacitás a szöveg hosszához. Vagyis ha növelni kell, akkor 
mennyivel nőjön a terület nagysága; ha pedig feleslegesen nagy a terület, 
akkor mennyivel csökkenjen. Itt kompromisszumra van szükség: ha nagy a szabadon 
tartott terület, akkor ritkán kell újrafoglalni, de sok az elpocsékolt 
memória. Ezt a stratégiát építsd be egy függvénybe (pl. olyan módon, hogy ez
egy függvényként jelenik meg, amely megadja, mekkora a foglalt terület a sztring
hossza szerint). Ez a függvény a sztring modulnak egy „láthatatlan” része
legyen, a sztring modul használói elől legyen elrejtve!</p>
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="f08.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="index.html"><img src="modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="index.html">főoldal</a> · <a href="elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
