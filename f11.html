<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: 11. hét: parancssor, fájlkezelés, modulok</title>
<meta property="og:title" content="InfoC :: 11. hét: parancssor, fájlkezelés, modulok">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="Gyakorlófeladatok a 11. előadás anyagához kapcsolódóan.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="Gyakorlófeladatok a 11. előadás anyagához kapcsolódóan.">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="modulz/logo_touch.png">
<link rel="image_src" href="modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<script>infoc.onloads.push(function(){ h3toid(); });
</script>
<link rel="stylesheet" href="modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="modulz/style/localfonts.css@v10.css">
<script src="modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="index.html">InfoC</a></div>
<ul>
<li class="al "><a href="f11.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="index.html">Kezdőlap</a>
<li><a href="nhf.html">Nagy házi feladat</a>
<li><a href="elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="f11.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="f11.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="ea01.html">1. hét: bevezetés</a>
<li><a href="ea02.html">2. hét: algoritmusok</a>
<li><a href="ea03.html">3. hét: tételek, tömbök</a>
<li><a href="ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="ea09.html">9. hét: láncolt listák</a>
<li><a href="ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="ea12.html">12. hét: bináris fák</a>
<li><a href="ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="f11.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="gy02.html">2. hét: algoritmizálás</a>
<li><a href="gy03.html">3. hét: egyszerű programok</a>
<li><a href="gy04.html">4. hét: tételek és tömbök</a>
<li><a href="gy05.html">5. hét: függvények</a>
<li><a href="gy06.html">6. hét: származtatott típusok</a>
<li><a href="gy07.html">7. hét: mutatók használata</a>
<li><a href="gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="gy11.html">11. hét: láncolt listák I.</a>
<li><a href="gy12.html">12. hét: láncolt listák II.</a>
<li><a href="gy13.html">13. hét: bináris fák</a>
<li><a href="gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="f11.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="lab01.html">1. hét: operációs rendszer</a>
<li><a href="lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="lab03.html">3. hét: egyszerű programok</a>
<li><a href="lab04.html">4. hét: tömbök</a>
<li><a href="lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="lab11.html">11. hét: láncolt listák</a>
<li><a href="lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="lab13.html">13. hét: bináris fák</a>
<li><a href="lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="f11.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="f01.html">1. hét: egyszerű programok</a>
<li><a href="f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="f09.html">9. hét: láncolt listák</a>
<li><a href="f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="f11.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="jegyzet.html">Jegyzet és puska</a>
<li><a href="fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="stilus.html">Kódolási stílus</a>
<li><a href="tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="debugmalloc.html">Debugmalloc</a>
<li><a href="mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="f11.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="f11.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="orak.html">SVG óra galéria</a>
<li><a href="angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="f11.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="turing.html">Mit tud a számítógép?</a>
<li><a href="bf.html">BF</a>
<li><a href="bitturmix.html">Bitturmix</a>
<li><a href="labirintus.html">Labirintusok</a>
<li><a href="tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="f11.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="karakterkodolas.html">Karakterkódolások</a>
<li><a href="strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="internet.html">Internet</a>
</ul>

<li class="al "><a href="f11.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="sdl.html">SDL grafika</a>
<li><a href="sdl_telepito.html">SDL telepítés</a>
<li><a href="fa.html">Fák rajzolása</a>
<li><a href="lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="f11.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="mondatelemzo.html">Mondatelemző</a>
<li><a href="kifejezesek.html">Kifejezések</a>
<li><a href="derivalas.html">Deriválás</a>
<li><a href="ast_epit.html">AST: szintaxisfák</a>
<li><a href="ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<a id="feladatfajlkezeles" class="namer"></a>
<h1 class="eloadascim">11. hét: parancssor, fájlkezelés, modulok</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán, Nagy Gergely, Pohl László · <i class="ido"></i> 2015.02.18 · Frissítve: 2015.02.15</p>
<p class="kivonat">Gyakorlófeladatok a 11. előadás anyagához kapcsolódóan.</p>
</div>


<p>Ezen az oldalon rengeteg feladat található a gyakorláshoz. Egy részük megoldással együtt, míg 
a többi anélkül. A gyakorlófeladatok megoldásához elvileg elegendő az az ismeretanyag, amely az előadáson 
szerepelt. Természetesen a megoldás kitalálásához szükség lehet arra a rálátásra és 
tapasztalatra, amit a gyakorlatok és a laborok adnak. A feladatok témakörök szerinti 
csoportosítása viszont ettől függetlenül az előadást követi.</p>

<p>Felhívjuk a figyelmed arra, hogy a megoldások olvasgatása lényegében nulla 
tapasztalatot és gyakorlatot ad, így az eredményes számonkérésekhez nem tud hozzásegíteni! A 
megoldásokat akkor nézd csak meg, ha a saját megoldás elkészítése közben elakadsz.
Lásd <a href="tanacsok.html">itt</a>.</p>


<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="f11.html#1">Parancssori argumentumok</a>
<li><a href="f11.html#2">Szöveges fájlok</a>
<li><a href="f11.html#3">Bináris fájlok</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>Parancssori argumentumok</h2>
</div>

<h3>Argumentumok kiírása</h3>
<div class="sticky">Beugró volt</div>
<p>Írj programot, amely számozva kiírja a parancssori argumentumait a képernyőre!</p>
<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
    int i;
    
    /* argv[0] a program neve, és argv[argc]=NULL.
     * ezért 1-től argc-1-ig kell mennie a ciklusnak. */
    for (i = 1; i &lt; argc; ++i)
        printf(&quot;%d. %s\n&quot;, i, argv[i]);
    
    return 0;
}</pre>
</div>
</div>




<h3>Az argumentumok száma</h3>
<div class="sticky">Beugró volt</div>
<p>Tegyük fel, hogy írni kell egy programot, amely két parancssori argumentumot vár:
egy bemeneti és egy kimeneti fájl nevét. Írj rövid programot, amely ellenőrzi, hogy
pontosan két parancssori argumentumot kapott-e! Írjon a program hibaüzenetet
a képernyőre, ha nem!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
    /* a buktato: argv[0], vagyis a nulladik parancssori argumentum
     * a program neve. ez beleszamit a kapott argumentumok szamaba,
     * ezert pontosan 2 argumentum eseten argc erteke 3 lesz! */
    if (argc == 3)
        printf(&quot;Ket parancssori argumentumot kaptam.\n&quot;);
    else
        printf(&quot;Hiba: nem pontosan ket argumentumot kaptam!\n&quot;);
    
    return 0;
}</pre>
</div>
</div>




<h3>Mini számológép</h3>
<p>Írj programot, amely parancssori argumentumként három valamit vár:
az első és a harmadik egy szám, a középső pedig a +, -, *, / műveleti
jelek egyike! Írja ki a program a képernyőre az elvégzett művelet
eredményét, vagy egy hibaüzenetet, ha az argumentumok bármilyen szempontból
nem elfogadhatóak!</p>

<pre class="screenshot">
frank@hal9000:~$ szamologep 1 / 2
Az eredmeny: 0.5

frank@hal9000:~$ szamologep b + 2
Az elso es a harmadik argumentum legyen szam!

frank@hal9000:~$ szamologep 1 +xyz 2
A masodik argumentum egy muveleti jel legyen!
</pre>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[]) {
    double a, b, e;
    
    if (argc != 4) {
        printf(&quot;Harom argumentum kell: ket szam, es kozte egy muveleti jel!\n&quot;);
        return 1;
    }
    
    /* az argumentumokat sztringkent (!) kapjuk, ezekbol
     * az sscanf-fel kiolvashato a szamertek. */
    if (sscanf(argv[1], &quot;%lf&quot;, &amp;a) != 1
        || sscanf(argv[3], &quot;%lf&quot;, &amp;b) != 1) {
        printf(&quot;Az elso es a harmadik argumentum legyen szam!\n&quot;);
        return 1;
    }
    
    if (strlen(argv[2]) != 1) {
        printf(&quot;A masodik argumentum egy muveleti jel legyen!\n&quot;);
        return 1;
    }
    /* argv[2] a masodik parameter, argv[2][0] annak legelso karaktere. */
    if (argv[2][0] != '+' &amp;&amp; argv[2][0] != '-'
        &amp;&amp; argv[2][0] != '*' &amp;&amp; argv[2][0] != '/') {
        printf(&quot;A masodik argumentum egy muveleti jel legyen!\n&quot;);
        return 1;
    }
    
    switch (argv[2][0]) {
        case '+': e = a+b; break;
        case '-': e = a-b; break;
        case '*': e = a*b; break;
        case '/': e = a/b; break;
        default: /* lehetetlen */ break;
    }
    
    printf(&quot;Az eredmeny: %g\n&quot;, e);
    return 0;
}</pre>
</div>
</div>






<h3>Mátrix négyzetre emelése</h3>

<p>Írj egy programot, amelyik a parancssori paramétereiben vesz át egy négyzet alakú 
mátrixot, és megszorozza azt saját magával! Az eredményt mátrix formában jelenítse meg!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>A következő dolgokra kell figyelni:</p>
<ul>
    <li>A <code>main</code> két paramétere <code>int argc</code> és <code>char *argv[]</code>.
    Az utóbbi a paramétereket tartalmazza sztring formájában, az előbbi pedig a paraméterek
    száma +1. <code>argv[0]</code> a program neve, innen adódik a +1 – erre figyelni
    kell, amikor indexeljük a tömböt, illetve <code>argc</code>-t vizsgáljuk. Ha 1 paraméter
    van, <code>argc</code> értéke 2 lesz!
    <li>Mivel <code>char *argv[]</code> sztringeket tartalmaz, konvertálni kell azokat szám
    formába. Lent nem teszem, de az <code>sscanf</code> függvény visszatérési értéke
    lehetővé tenné ennek ellenőrzését.
</ul>

<p>A memória foglalásoknál meg kell nézni, hogy sikeresek-e. A foglaláshoz lent egy külön 
függvény van, ahol ez jól látszik. A feladat megoldása egyébként elég egyszerű; inkább a lexikai 
tudásból igényel sokat, parancssori argumentumok kezelése stb.</p>

<pre class="brush: c "  >
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

double **foglal(int meret) {
    int y;
    double **tomb;

    tomb=(double **) malloc(meret*sizeof(double *));
    if (!tomb) {
        fprintf(stderr, &quot;Memoriafoglalasi hiba\n&quot;);
        exit(0);        /* jobb hijan kiugrunk a programbol */
    }
    for (y=0; y&lt;meret; ++y) {
        tomb[y]=(double *) malloc(meret*sizeof(double));
        if (!tomb[y]) {
            fprintf(stderr, &quot;Memoriafoglalasi hiba\n&quot;);
            exit(0);
        }
    }

    return tomb;
}

void felszabadit(double **tomb, int meret) {
    int y;

    for (y=0; y&lt;meret; ++y)
        free(tomb[y]);
    free(tomb);
}

int main(int argc, char *argv[]) {
    int meret;
    int x, y;
    double **be, **ki;

    meret=sqrt(argc-1);
    /* nezzuk, hogy negyzetszam-e */
    if (meret*meret!=argc-1) {
        fprintf(stderr, &quot;Nem negyzetszam a parameterek szama!\n&quot;);
        exit(0);
    }

    be=foglal(meret);
    ki=foglal(meret);

    /* beolvasas */
    for (y=0; y&lt;meret; ++y)
        for (x=0; x&lt;meret; ++x)
            sscanf(argv[y*meret+x+1], &quot;%lf&quot;, &amp;be[y][x]);

    // negyzet kiszamitasa - ez a feladat lenyege
    for (y=0; y&lt;meret; ++y)
        for (x=0; x&lt;meret; ++x) {
            double osszeg=0;
            int i;

            for (i=0; i&lt;meret; ++i)
                osszeg+=be[y][i]*be[i][x];

            ki[y][x]=osszeg;
        }

    /* kiiras */
    for (y=0; y&lt;meret; ++y) {
        for (x=0; x&lt;meret; ++x)
            printf(&quot;%8.4lf &quot;, ki[y][x]);
        printf(&quot;\n&quot;);
    }

    felszabadit(be, meret);
    felszabadit(ki, meret);

    return 0;
}</pre>

</div>
</div>






</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>Szöveges fájlok</h2>
</div>

<h3>Fájl beolvasása</h3>
<p>Készíts programot, mely az „adat1.txt” fájl tartalmát beolvassa és kiírja a képernyőre!</p>

<h3>Fájl írása</h3>
<p>Készíts programot, mely bekéri a felhasználó nevét, és azt az „adat1.txt” fájlba eltárolja! 
(Ha már létezett a file korábban, írja felül.)</p>

<h3>Hányszor indult?</h3>
<p>Készíts programot, mely induláskor írja ki a képernyőre, hogy hanyadszorra indítják. Az 
indítások számát tárolja az "indit.ini" fájlban. (Ha a file még nem létezik, akkor ez az első 
indítás, ha már létezik, akkor olvassa ki belőle az eddigi indítások számát, adjon hozzá egyet, 
azt írja ki a képernyőre, és tárolja vissza a fájlba.)</p>

<h3>Kisbetűk</h3>
<p>Készíts programot, amely egy megadott fájlt átolvasva kiírja, hogy az angol ABC kisbetűi 
közül melyik hányszor szerepel benne.</p>

<h3>Köbméter</h3>
<p>Egy tóra négyzetrácsot fektetünk, a négyzetrács egyes pontjaiban a tó mélységét tároljuk. 
0-val jelöljük a szárazföldet, negatív számmal a mélységet méterben. Készíts programot, amelyik 
egy ilyen, fájlban adott „térkép” alapján téglatest módszerrel becsli a tó térfogatát. Az egyes 
mérési pontok távolságát kérdezze meg a program a felhasználótól. A fájl első sorában a táblázat 
szélessége és magassága (egész számok), a többi sorokban a táblázat egyes sorai; valós számok 
szóközzel elválasztva.</p>

<h3>Szövegfájl titkosítása</h3>
<p>Készítsünk egy programot, amelyik egy szövegfájlt titkosít. A titkosítás egyszerű: minden 
betű helyett az ABC-ben következőt használjuk, 'z' helyett pedig 'a'-t.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Ez szinte ugyanaz, mint a félév eleji változat, amelyik a billentyűzetről olvasott. Fájlból 
olvasni, fájlba írni semmivel nem nehezebb: minden függvény neve elé még egy f betű kerül (<code>
printf-fprintf</code>, <code>scanf-fscanf</code>), és első paraméter a fájl, amin dolgozni 
kell.</p>
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

char kodol(char c) {
    /* ez a ketto specialis, mert &quot;tulpordul&quot; */
    if (c=='z') return 'a';
    if (c=='Z') return 'A';
    /* tobbi kodolando */
    if ((c&gt;='a' &amp;&amp; c&lt;'z')
        || (c&gt;='A' &amp;&amp; c&lt;'Z'))
            return c+1;

    /* ha nem ezek, marad valtozatlanul */
    return c;
}

int main(void) {
    FILE *be, *ki;
    int c;

    be = fopen(&quot;eredeti.txt&quot;, &quot;rt&quot;);
    if (be == NULL) {
        perror(&quot;eredeti.txt megnyitása&quot;);
        return 1;
    }
    ki = fopen(&quot;kodolt.txt&quot;, &quot;wt&quot;);
    if (ki == NULL) {
        perror(&quot;kodolt.txt megnyitása&quot;);
        return 2;
    }

    /* egyesevel a karakterek */
    while ((c = fgetc(be)) != EOF)
        fputc(kodol(c), ki);

    fclose(be);
    fclose(ki);
    return 0;
}</pre>
</div>
</div>



<h3>Minimumkeresés fájlból, formátumsztringek</h3>
<p>Egy meteorológiai állomás által rögzített hőmérsékleti értékeket fájlban kapjuk. A fájl első 
sorában a mérés napja van, <code>év, szóköz, hónap, szóköz, nap</code> formátumban. A fájl többi 
sora <code>óra, kettőspont, perc, szóköz, hőmérséklet</code> (valós szám) formátumban. Olvassuk 
be a fájlt, és keressük meg, mikor volt a legmelegebb aznap. Írjuk ki az ehhez tartozó órát és 
percet, illetve a hőmérsékletet, <code>2009.09.17.&nbsp;12:08&nbsp;+14.1</code> formátumban.</p>

<p>Példa bemenet:</p>
<pre>
2009 09 17
12:45 11.1
12:59 14.3
04:34 -5
</pre>

<p>Példa kimenet, amely a fenti bemenetre generálódik:</p>
<pre>
2009.09.17. 12:59 +14.3
</pre>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    typedef struct Datum {
        int ev, honap, nap;
    } Datum;
    typedef struct Meres {
        int ora, perc;
        double fok;
    } Meres;

    FILE *fbe;
    int elso;
    Datum d;
    Meres beolv, max;

    /* fussunk neki */
    fbe = fopen(&quot;eredmenyek.txt&quot;, &quot;rt&quot;);
    if (!fbe) {
        perror(&quot;eredmenyek.txt: nem sikerult megnyitni a fajlt&quot;);
        return 1;
    }

    fscanf(fbe, &quot;%d %d %d&quot;, &amp;d.ev, &amp;d.honap, &amp;d.nap);
    /* a maximumkeresesnel az elso megkulonbozteteset
       itt segedvaltozoval oldottam meg */
    elso=1;
    while (fscanf(fbe, &quot;%d:%d %lf&quot;, &amp;beolv.ora, &amp;beolv.perc, &amp;beolv.fok)==3) {
        if (elso || beolv.fok&gt;max.fok)
            max=beolv;
        elso=0;
    }
    /* ennyi */
    fclose(fbe);

    /* eredmeny kiirasa, formatumsztring */
    printf(&quot;%d.%02d.%02d. %02d:%02d %+g\n&quot;,
           d.ev, d.honap, d.nap,
           max.ora, max.perc, max.fok);

    return 0;
}</pre>
</div>
</div>





<h3>Névsor</h3>
<p>Egy fájl hallgatók vizsgajegyeit tartalmazza, Neptun-kód, szóköz, jegy, szóköz, név 
formátumban soronként. Ha a hallgató nem kapott aláírást, a jegy helyén egy mínusz szerepel. 
Készíts programot, amely statisztikát ír ki a vizsgáról. Például:</p>

<pre>
AABB12 5 Tehetséges Béla
CC43EF 4 Pedál Tibi
BBCC34 - Lógós Feri
XYYXY1 4 Ezoterikus János
</pre>

<p>Kimenet:</p>

<pre>
Jeles: 1 fő
Jó: 2 fő
Nem kapott aláírást: 1 fő
</pre>





<h3>Egyszerű preprocesszor</h3>

<p>Írj programot, amely egy egyszerű C preprocesszorként működik. Beolvas egy C forráskódú 
programot, és a <code>#define</code> sorokat értelmezi, illetve a megadott szavakat cseréli. 
(Paraméteres makrókat nem kell felismernie.) Példa bemenet:

<pre>
#define YES 1
#define NO 0
fuggveny(a, YES);
</pre>
<p>Kimenet:</p>
<pre>
fuggveny(b, 1);
</pre>

<p>Az alábbi egyszerűsítésekkel élhetsz. Elegendő, ha a program maximum 100 makrót tud 
megtanulni. A makrók neve legfeljebb 30 betűs, a tartalmuk legfeljebb 200 betűs lehet. A sorok 
maximális hossza 1000 lehet, viszont egy sorban egy makró szerepelhet többször is! 
Feltételezheted, hogy a forráskódban nincsenek sztringek.</p>




<h3>Kommentszűrő szövegfájlból</h3>
<p>Írd át a laboron elkészített kommentszűró állapotgép programodat úgy, hogy parancssori 
paraméterként vegye át a forrás- és célfájl nevét! Nyissa meg a fájlokat szöveges módban, és 
fájlkezelő függvényekkel olvassa és írja a bemenetet és kimenetet! A munka végén ne felejtsd 
bezárni a fájlokat! A kommentektől megszabadított forráskód a kimeneti fájlba, a kommentek 
statisztikáját (komment karakterek, összes karakterek, százalék) pedig a szabványos kimenetre 
írja a program!</p>

<p class="megjegyzes">A szabványos bemenetről olvasó, kimenetre író <code>getchar()</code> és <code>putchar()</code>
függvényeknek van fájlos párja is: ezek neve <code>fgetc()</code> és <code>fputc()</code>.</p>





</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>Bináris fájlok</h2>
</div>

<h3>Bináris fájlból C forráskód</h3>
<p>Gyakran praktikus, ha a programjaink bizonyos adatokat nem fájlból olvasnak, hanem a 
lefordított program eleve tartalmazza azokat. Készíts programot, amely bináris fájlt beolvasva 
C-s tömböt készít abból. Például ha egy 8 bájtos bináris fájl a 98, 21, 17, 58, 255, 0, 7, 1 
bájtokat tartalmazza, a program által létrehozott szövegfájl így néz ki:</p>
<pre>
unsigned char adat[] = {
  98, 21, 17, 58, 255, 0, 7, 1,
};
const int adat_len=8;
</pre>
<p>Figyelj arra, hogy a kimeneti fájl tartalmazzon sortöréseket is, vagyis a vesszővel 
elválasztott számok ne nyúljanak túl a 80 karakteres képernyőn! (A C a tömbök kezdeti értékének 
megadásakor megengedi, hogy az utolsó adat után is szerepeljen vessző. A fenti példa is 
ilyen.)</p>




<h3>Fájlok összehasonlítása</h3>
<p>Írj olyan programot, amely két bináris fájlt hasonlít össze, és kiírja az eltérések helyét, 
továbbá az első és második fájlban található különböző bájtokat! Például:
<pre>
poz.  f1 f2
0456  00 12
0ef3  fe fb
</pre>
<p>A nem egyforma méretű fájlokat el se kezdje összehasonlítani!</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Az <code>fread()</code> függvénnyel tudunk a fájlból olvasni, és figyelni kell a 
<code>"b"</code> betűre a fájl megnyitásánál.</p>

<p>A fájl méretét megadó függvény a C-ben nincs. Helyette azt csinálhatjuk, hogy a végére 
ugrunk (<code>fseek()</code>), és lekérdezzük a pozíciót (<code>ftell()</code>).</p>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

/* kulturalt fuggveny: a fajlbol elugrik mashova,
   de vissza is ugrik oda, ahol eredetileg volt */
long meret(FILE *fp) {
    long pos, meret;

    pos=ftell(fp);
    /* 0 bajt a vegehez kepest, az pont a vege */
    fseek(fp, 0, SEEK_END);
    meret=ftell(fp);
    fseek(fp, pos, SEEK_SET);
    return meret;
}

int main(int argc, char *argv[]) {
    FILE *f1, *f2;
    unsigned char buf1[512], buf2[512];
    size_t beolv, pos;

    if (argc!=3) {
        fprintf(stderr, &quot;Ket fajlnevet kerek!\n&quot;);
        return -1;
    }

    f1 = fopen(argv[1], &quot;rb&quot;);
    if (f1==NULL) {
        perror(argv[1]);
        return 1;
    }
    f2 = fopen(argv[2], &quot;rb&quot;);
    if (f2==NULL) {
        perror(argv[2]);
        fclose(f1);     /* nagyon kis rendesek vagyunk */
        return 2;
    }

    if (meret(f1) != meret(f2)) {
        fprintf(stderr, &quot;Nem egyforma meretuek!\n&quot;);
        fclose(f1);
        fclose(f2);
        return 3;
    }

    pos=0;
    /* amig sikerul az elso fajlbol olvasni */
    while ((beolv=fread(buf1, 1, sizeof(buf1), f1))&gt;0) {
        int i;
        /* ennek is mennie kell */
        fread(buf2, 1, sizeof(buf2), f2);

        /* csak annyit hasonlitunk, amennyit beolvastunk! */
        for (i=0; i&lt;beolv; i++) {
            if (buf1[i]!=buf2[i])
                /* pos: eddig feldolgozott bajtok,
                   +i: a most vizsgalt bajt */
                printf(&quot;%08x %02x %02x\n&quot;, pos+i, buf1[i], buf2[i]);
        }

        pos+=beolv;
    }

    fclose(f1);
    fclose(f2);

    return 0;
}</pre>
</div>
</div>





<h3>RLE betömörítés</h3>

<p>Az RLE (run length encoding) az egyik legegyszerűbb tömörítési algoritmus. Lényege, hogy az 
egymás után következő egyforma bájtokat elég csak egyszer eltárolni, és megjelölni, hogy hányszor
szerepeltek. Ha pedig nem egyforma bájtok követik egymást, azokat simán átmásolja az RLE.</p>

<p> A tömörített adatunkban 0xbf karakterrel jelöljük az ilyen többszörözést. A 0xbf utáni első 
karakter az ismétlendő bájt, az azutáni pedig az ismétlések száma!</p>

<p>Írj programot, amelyik egy megadott fájlt betömörítve egy másik fájlba ír! Figyelj arra, 
hogy ha az eredeti fájlban 0xbf szerepel, azt nem szabad egyszerűen átmásolni, mert akkor a 
kitömörítő algoritmus ismétlés megjelölésének próbálná értelmezni.</p>




<h3>RLE kitömörítés</h3>

<p>Írd meg a fenti program kitömörítő párját.</p>




<h3>RLE tömörítő</h3>

<p>Dolgozd össze az előző két feladat megoldását egy komplett parancssori alkalmazássá! Az 
alkalmazással lehessen betömöríteni és kitömöríteni is fájlokat! Az elvégzendő műveletet az első 
parancssori paraméter, a két fájlnevet (bemenet és kimenet) pedig a második parancssori paraméter
adja meg!</p>

<pre class="screenshot">
C:\> rle betomorit input.dat output.rle

C:\> rle kitomorit output.rle input.dat
</pre>
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="f11.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="index.html"><img src="modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="index.html">főoldal</a> · <a href="elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
