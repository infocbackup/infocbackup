<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Gyakorlat, 8. hét: rekurzió, állapotgép</title>
<meta property="og:title" content="InfoC :: Gyakorlat, 8. hét: rekurzió, állapotgép">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="Rekurzív algoritmusok: rekurzió tervezése, triviális esetek és visszavezetések. Állapotgépek: állapot- és tevékenységtáblák tervezése, megvalósítása C programban.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="Rekurzív algoritmusok: rekurzió tervezése, triviális esetek és visszavezetések. Állapotgépek: állapot- és tevékenységtáblák tervezése, megvalósítása C programban.">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="modulz/logo_touch.png">
<link rel="image_src" href="modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="modulz/style/localfonts.css@v10.css">
<script src="modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="index.html">InfoC</a></div>
<ul>
<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="index.html">Kezdőlap</a>
<li><a href="nhf.html">Nagy házi feladat</a>
<li><a href="elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="ea01.html">1. hét: bevezetés</a>
<li><a href="ea02.html">2. hét: algoritmusok</a>
<li><a href="ea03.html">3. hét: tételek, tömbök</a>
<li><a href="ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="ea09.html">9. hét: láncolt listák</a>
<li><a href="ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="ea12.html">12. hét: bináris fák</a>
<li><a href="ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="gy02.html">2. hét: algoritmizálás</a>
<li><a href="gy03.html">3. hét: egyszerű programok</a>
<li><a href="gy04.html">4. hét: tételek és tömbök</a>
<li><a href="gy05.html">5. hét: függvények</a>
<li><a href="gy06.html">6. hét: származtatott típusok</a>
<li><a href="gy07.html">7. hét: mutatók használata</a>
<li><a href="gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="gy11.html">11. hét: láncolt listák I.</a>
<li><a href="gy12.html">12. hét: láncolt listák II.</a>
<li><a href="gy13.html">13. hét: bináris fák</a>
<li><a href="gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="lab01.html">1. hét: operációs rendszer</a>
<li><a href="lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="lab03.html">3. hét: egyszerű programok</a>
<li><a href="lab04.html">4. hét: tömbök</a>
<li><a href="lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="lab11.html">11. hét: láncolt listák</a>
<li><a href="lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="lab13.html">13. hét: bináris fák</a>
<li><a href="lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="f01.html">1. hét: egyszerű programok</a>
<li><a href="f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="f09.html">9. hét: láncolt listák</a>
<li><a href="f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="jegyzet.html">Jegyzet és puska</a>
<li><a href="fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="stilus.html">Kódolási stílus</a>
<li><a href="tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="debugmalloc.html">Debugmalloc</a>
<li><a href="mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="orak.html">SVG óra galéria</a>
<li><a href="angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="turing.html">Mit tud a számítógép?</a>
<li><a href="bf.html">BF</a>
<li><a href="bitturmix.html">Bitturmix</a>
<li><a href="labirintus.html">Labirintusok</a>
<li><a href="tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="karakterkodolas.html">Karakterkódolások</a>
<li><a href="strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="internet.html">Internet</a>
</ul>

<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="sdl.html">SDL grafika</a>
<li><a href="sdl_telepito.html">SDL telepítés</a>
<li><a href="fa.html">Fák rajzolása</a>
<li><a href="lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="gy08.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="mondatelemzo.html">Mondatelemző</a>
<li><a href="kifejezesek.html">Kifejezések</a>
<li><a href="derivalas.html">Deriválás</a>
<li><a href="ast_epit.html">AST: szintaxisfák</a>
<li><a href="ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<h1 class="eloadascim">Gyakorlat, 8. hét: rekurzió, állapotgép</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán · <i class="ido"></i> 2015.02.18 · Frissítve: 2015.02.15</p>
<p class="kivonat">Rekurzív algoritmusok: rekurzió tervezése, triviális esetek és visszavezetések. Állapotgépek: állapot- és tevékenységtáblák tervezése, megvalósítása C programban.</p>
</div>


<h3>A rekurzióhoz</h3>

<p>Rekurzív algoritmusoknál két dolgot kell meggondolnunk:</p>
<ul>
    <li>A triviális eseteket, amelyeknél a megoldás magától értetődik.
        (Pl. üres sztring hossza nulla.)
    <li>Nem triviális esetben azt, hogy hogyan tudjuk a kapott problémát
        visszavezetni egyszerűbb problémákra.
        (Pl. nem üres sztring hossza 1 + a sztring hossza a második
        betűtől kezdve.)
</ul>
<p>Az előbbi a báziskritérium, az utóbbi pedig az egyszerűsítési lépés a
rekurzióban, amellyel minden rekurzív függvényhívásnál a báziskritérium felé
haladunk. Keressük meg ezeket az alábbi problémáknál!</p>

<h3>Az állapotgépekhez</h3>

<p>A feladatok megoldásának lényege az, hogy az állapotátmeneti 
táblát és a tevékenyságtáblát megalkotjuk: <em>az állapotgépet megtervezzük.</em> 
Ha ez megvan, akkor onnantól a kódolás már mechanikus. Egy olyan feladatnál, ahol 
több állapotátmenet is van, nem lehet csak úgy nekiugrani a kódolásnak! Ha a 
táblázat megalkotása után fejből írunk valami kódot, nem a tábla alapján, annak 
sincs semmi értelme. Az is értelmetlen, ha a kettőt fordított sorrendben 
csináljuk meg…</p>

<p>A tervezés után az állapotgépet mindenképpen le kell tisztázni egy 
állapottáblával. A gráfot nézve ugyan jobban lehet mélázgatni az 
állapotátmeneteken, a táblázat sokkal áttekinthetőbb, és biztosítja azt is, hogy 
semelyik átmenetet sem hagytuk ki. A kódolás során pedig kifejezetten jobb abból 
dolgozni.</p>

<p>Felkészülés a gyakorlatra:</p>
<ul>
    <li>Az <a href="ea07.html#earekurzio">rekurzióról szóló előadás</a> anyagának megértése.
    <li>Az <a href="ea06.html#eaallapotgep">állapotgépekről szóló előadás</a> anyagának megértése.
    <li>A <a href="gy07.html#gyakpointerek">pointerekről és cím szerinti paraméterátadásról szóló gyakorlat</a> átismétlése.
    <li>A <a href="lab01.html#labparancssor">parancssorról tanultak</a> átismétlése.
</ul>







<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="gy08.html#1">„Hejesírásreform”</a>
<li><a href="gy08.html#2">Rekurzió bemelegítő</a>
<li><a href="gy08.html#3">Alakzat kitöltése</a>
<li><a href="gy08.html#4">Anagrammák</a>
<li><a href="gy08.html#5">Pénzváltás</a>
<li><a href="gy08.html#6">Zárójeles szöveg</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<a id="gyakallapotgepek" class="namer"></a>
<div class="slideheader">
<h2><span class="oldalszam">1</span>„Hejesírásreform”</h2>
</div>
<p>Írjunk programot, amelyik megreformálja a helyesírást: cseréljen minden ly karakterpárt j 
betűre, minden lly karakterhármast jj párra! Kis/nagybetűkkel most ne foglalkozzunk; illetve 
tekintsünk el attól az esettől, amikor egy összetett szó közepén az első tag l-lel végződik, a 
második y-nal vagy ly-nal kezdődik.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<table>
    <thead>
    <tr><th><th>l<th>y<th>egyéb
    </thead>
    <tr><th>alap<td>&rarr;lbetű<td>ki: c<td>ki: c
    <tr><th>lbetű<td>&rarr;hosszú_ll<td>ki: "j"<br>&rarr;alap<td>ki: "l", c<br>&rarr;alap
    <tr><th>hosszú_ll<td>ki: "l"<td>ki: "jj"<br>&rarr;alap<td>ki: "ll", c<br>&rarr;alap
</table>

<p>A kiírásokat itt jól meg kell gondolni. Alapállapotban mindent kiírunk, kivétel az l betűt, 
mert az lehet egy későbbi ly része. lbetű állapotban bejövő y esetén kiírjuk a j-t; viszont 
bejövő egyéb karakter esetén az előző l-t is ki kell írni, és a mostanit is (ilyen szó: 
„előző”). hosszú_ll esetén pedig, ha bármi más jön, akkor az előző ll-t is ki kell írni (ilyen 
szó: „hallgat”).</p>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

int main(void) {
    enum allapot {
        alap,
        lbetu,
        hosszu_ll
    } all;
    int c;          /* ennek kell intnek lennie! */

    all = alap;
    while ((c = getchar()) != EOF) {
        switch (all) {
            case alap:
                if (c == 'l')
                    all = lbetu;
                else
                    putchar(c);
                break;
            case lbetu:
                switch (c) {
                    case 'l':
                        all = hosszu_ll;
                        break;
                    case 'y':
                        putchar('j');
                        all = alap;
                        break;
                    default:
                        printf(&quot;l%c&quot;, c);
                        all = alap;
                        break;
                }
                break;
            case hosszu_ll:
                switch (c) {
                    case 'l':
                        putchar('l');
                        break;
                    case 'y':
                        printf(&quot;jj&quot;);
                        all = alap;
                        break;
                    default:
                        printf(&quot;ll%c&quot;, c);
                        all = alap;
                        break;
                }
                break;
        }
    }

    return 0;
}</pre>

<div class="megjegyzes">
<p>A szövegfájloknál bevett szokás az, hogy a fájl legutolsó karaktere mindig egy újsor (\n) 
karakter. Ezt azonban sajnos nem mindenhol tartják be (és nem minden szövegszerkesztő tesz így).
</p>

<p>Ha a fájl utolsó szava „hell”, és utána még van egy újsor karakter, akkor minden kiíródik 
helyesen. Ha azonban az az újsor karakter hiányzik, akkor a fenti program sem működik 
tökéletesen (az amúgy tulajdonképp hibásnak tekinthető (!) fájlra). Ezt úgy tudjuk kezelni, ha az 
állapotgép ciklusa után megvizsgáljuk az állapotváltozót. Az <code>lbetu</code> és a <code>
hosszu_ll</code> állapotok azt jelentik, hogy a fájl l/ll karakter(ek)re végződött, lezáró újsor 
nélkül. Ezeket kiírhatjuk az állapotgép ciklusából kilépés után:</p>

<pre class="brush: c "  >
/* lehet, hogy vannak &quot;beragadt&quot; l betuk */
switch (all) {
   case alap: break;
   case lbetu: printf(&quot;l&quot;); break;
   case hosszu_ll: printf(&quot;ll&quot;); break;
}</pre>
</div>

</div>
</div>



</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<a id="gyakrekurzio" class="namer"></a>
<div class="slideheader">
<h2><span class="oldalszam">2</span>Rekurzió bemelegítő</h2>
</div>

<p>Mi a különbség az alábbi két függvény között?</p>

<div class="columns">
<div>
<pre class="brush: c "  >
void sztringet_kiir(char *szoveg) {
    if (szoveg[0] == '\0')
        return;
    putchar(szoveg[0]);
    printf(&quot;%s&quot;, szoveg + 1);
}</pre>
</div>
<div>
<pre class="brush: c "  >
void sztringet_kiir(char *szoveg) {
    if (szoveg[0] == '\0')
        return;
    putchar(szoveg[0]);
    sztringet_kiir(szoveg + 1);
}</pre>
</div>
</div>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">
<p>Semmi.</p>
</div>
</div>





</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>Alakzat kitöltése</h2>
</div>
<p> Adott egy két dimenziós tömb, amelyik egy képet reprezentál. A képen egy adott színnel el
van kerítve egy terület – vagyis meg van rajzolva egy alakzat. Színezzük ki ennek az alakzatnak
a belsejét! Az alakzat lehet konkáv is, abban az esetben is be kell menni minden zugba! </p>

<pre class="brush: c sorsurit1"  >
char z4qqq[20][32] = {
    &quot;                               &quot;,
    &quot;            xx   xx            &quot;,
    &quot;       xxxx x xxx x xxxx       &quot;,
    &quot;      xx  x x     x x  xx      &quot;,
    &quot;    xxx  xx x     x xx  xxx    &quot;,
    &quot;  xxx    x  x     x  x    xxx  &quot;,
    &quot;  x      x  x     x  x      x  &quot;,
    &quot; xx       xx       xx       xx &quot;,
    &quot; x                           x &quot;,
    &quot; x                           x &quot;,
    &quot; x                           x &quot;,
    &quot; x                           x &quot;,
    &quot; x                           x &quot;,
    &quot; xx    xx             xx    xx &quot;,
    &quot;  x   x  x xx     xx x  x   x  &quot;,
    &quot;  xxx  x x x x   x x x x  xxx  &quot;,
    &quot;    xx x xxx xx xx xxx x xx    &quot;,
    &quot;     xxx      x x      xxx     &quot;,
    &quot;              xxx              &quot;,
    &quot;                               &quot;
};</pre>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<p> A rekurzió nélkül lehetetlennek tűnő feladat rekurzív megoldása végtelenül
egyszerű. A függvény először megvizsgálja, hogy olyan pozíciót kapott-e, ahova
szabad lépni, és amit ki kell festeni. Ha nem szóköz (kifestendő képpont) van az
adott helyen, vagy talán olyan pozícióról van szó, ami kilóg a képről, akkor
egyből vissza is tér. Ha viszont kifestendő a pont, akkor kifesti, és kifesti a
szomszédait is. A szomszédoknál ugyanez a feladat: az aktuális pontot kifesteni,
és mind a négy irányba megpróbálni menni. Ha a festés ilyen módon végül egy
zsákutcában elakad, a függvények visszatérnek – és a próbálkozás megy tovább a
másik három lehetséges irányba. Zsákutca pedig a saját maga által kifestett
pontok miatt is keletkezhet, hiszen onnantól kezdve, hogy egy pontot kifest az
algoritmus, az ugyanolyan falnak számít, mint az eredeti alakzat körvonalai.</p>

<div class="kozep" style="max-width: 75%">
<iframe width="420" height="315" src="http://www.youtube.com/embed/hgrgPe77BKU" frameborder="0" allowfullscreen class="arnyek"></iframe>
<br>
A kifestő működése. A videóban minden függvényhívás <em>elején</em> pirosra festi
a program az adott helyet; és miután az összes irányból visszatértek
a hívott függvények, csak akkor kékre. Ezen is, és a bejelölt útvonalon
is látszik az, hogy melyek
a befejezetlen, nem teljesen lefutott függvénytörzsek.
</div>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;

void kifest(char kep[20][32], int y, int x) {
    if (y &lt; 0 || x &lt; 0 || y &gt;=20 || x &gt;= 31)
        return;
    if (kep[y][x] != ' ')
        return;
    kep[y][x] = '.';
    kifest(kep, y-1, x);
    kifest(kep, y+1, x);
    kifest(kep, y, x-1);
    kifest(kep, y, x+1);
}

int main(void) {
   /* IDE KELL BERAKNI A RAJZOT */
   int y;

   kifest(z4qqq, 10, 10);
   for (y=0; y&lt;20; ++y)
      puts(z4qqq[y]);

   return 0;
}</pre>

</div>
</div>




</div>
</section>
<section id="4">
<div class="slide" id="slide_4">
<div class="slideheader">
<h2><span class="oldalszam">4</span>Anagrammák</h2>
</div>
<p>Írjuk ki egy szónak az összes anagrammáját! Pl. abc anagrammái: abc acb bac bca cab cba.</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<p>A megoldás lényege, hogy egy-egy betűpárt megcserél, és a fennmaradó részeket is permutálja.
A start változóban azt kapja a függvény, hogy hányadik karaktertől kezdve kell kezdeni a
permutálást. Ha ez megegyezik a sztring hosszával, akkor már nem permutál (hiszen már nincs
mit), hanem egyszerűen kiírja az aktuális állapotot. Ez a báziskritérium, így lesz vége a
rekurzió „mélységének” – a rekurziónál mindig kell lennie egy feltételnek, amikor többé már nem
hívja meg magát a függvény. Minden hívásnál közelít efelé a bázis felé, hiszen mindig egyre
rövidebb fennmaradó sztringrészletet permutál.</p>

<p>Tegyük fel, hogy kezdetben a sztring „abcd”. Ennek úgy néznek ki az anagrammái, hogy azok
kezdődhetnek a-val, b-vel, c-vel és d-vel. Az a-val kezdődőek: „abcd”, „abdc”, „acbd”, … ezek
végülis egy fix „a”, és utána a „bcd” sztring anagrammái, az összes lehetséges sorrendben. A
b-vel kezdődőek: „bacd”, „badc”, „bcad”, …, vagyis egy „b” betű, és az „acd” sztring anagrammái.
Itt van ebben a rekurzió: az „abcd” sztring anagrammái azok kezdődnek az „abcd” sztring
valamelyik (egyik) karakterével, és utána fennmaradó karakterek (de már csak három betűs
sztring) anagrammái kellenek.</p>

<p>A permutáló függvény ezt úgy valósítja meg, hogy a kapott sztring mindegyik karakterét
berakja az első helyre (vagyis mindegyik karakterét megcseréli az elsővel), és utána képezi a
fennmaradó rész anagrammáit. Ha nincs fennmaradó rész, akkor pedig kiírja az <em>addigra már
összekevert</em> sztringet. Pl. a kiindulási sztring „abcd”, akkor:</p>

<ul>
<li>először az a[bcd]-ket írja ki (csere nélkül)
<li>utána meg cserékkel: b[acd] (i=1), c[abd] (i=2), d[abc] (i=3), és mindenhol a [] részre rekurzívan hívódik.
</ul>

<p>
Az összes hívás az első mélységben így, ahol a [] jelenti a további rekurzív hívásokat:
</p>
<ul>
<li>a[bcd] (nincs csere)
<li>b[acd] (a&harr;b)
<li>c[bad] (a&harr;c)
<li>d[bca] (a&harr;d)
</ul>

<p>A rekurzió itt azért is jó, hogy miután visszajöttünk a fennmaradó rész anagrammáinak
képzéséből, akkor emlékezzünk rá, hogy melyik karaktereket kell visszacserélni (ez lokális
változó, eltárolódik a veremben).</p>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/* megcsereli az adott indexu karaktereket */
void betucserel(char* str, int a, int b) {
    char t = str[a];
    str[a] = str[b];
    str[b] = t;
}

void permutal(char* str, int start) {
    int hossz = strlen(str);

    if (start == hossz-1)
        printf(&quot;%s &quot;, str);    /* ha mar nincs mit permutalni */
    else {
        int i;

        /* permutaljuk a string hatralevo reszet, tovabba minden
         * karaktert megcserelunk a startadikkal, es ugy is
         * permutalunk. az elso esetet, amikor i=start lenne, kulon
         * is lehet hivni, mivel olyankor nem kell csere. */
        permutal(str, start+1);

        for (i = start+1; i &lt; hossz; ++i) {
            betucserel(str, start, i);    /* csere */
            permutal(str, start+1);
            betucserel(str, start, i);    /* visszacsere */
        }
    }
}

int main(void) {
    char s[] = &quot;abcd&quot;;
    permutal(s, 0);
    printf(&quot;\n&quot;);

    return 0;
}</pre>

<p>A fenti megoldás nem veszi figyelembe azt, ha egyforma
betűk vannak a sztringben, és azokat is cseréli. Pl. az „abba” sztringnek
többször is megjelennek ugyanazon permutációi. Ehhez a cserék előtt
meg kell vizsgálnunk azt, hogy a cserélendő karakter szerepelt-e már
a cserések között. Mert ha igen, akkor azt a lépést nem kell újra
elvégezni, hanem ki kell hagyni:</p>
<pre class="brush: c "  >
permutal(str, start+1);

for (i = start+1; i &lt; hossz; ++i) {
   int k, kell_csere;

   kell_csere = 1;
   for (k = start; k&lt;i; ++k)           /* volt mar ez a betu? */
      if (str[k] == str[i])
         kell_csere = 0;

   if (kell_csere) {
      betucserel(str, start, i);    /* csere */
      permutal(str, start+1);
      betucserel(str, start, i);    /* visszacsere */
   }
}</pre>

</div>
</div>









</div>
</section>
<section id="5">
<div class="slide" id="slide_5">
<div class="slideheader">
<h2><span class="oldalszam">5</span>Pénzváltás</h2>
</div>

<p>Adott egy zsák 5, 10, 20 és 50 forintos érménk. Hányféleképpen
lehet ezekkel kifizetni 100 forintot?</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<p>A probléma könnyen megoldható rekurzívan. Tekintsünk pl. egy 20 forintost! Két
lehetőségünk van: ha a 20 forintos része a megoldásnak (vagyis adunk egy 20-ast),
akkor a maradék 100-20=80 forintot még valahányféleképpen (x) ki lehet fizetni. A
másik lehetőség, ha azt mondjuk, hogy nem adunk 20-ast, és a 100 forint
kifizetését a többi érmével oldjuk meg (y lehetőség). A megoldás ezek összege:
x+y.</p>

<p>Így közeledünk a rekurzióban a báziskritérium felé: vagy az összeg csökken,
vagy a felhasználható érmefajtákat csökkentjük. Figyelembe kell még vennünk három
extrém esetet. Ezek lesznek a báziskritériumok:</p>

<ol>
    <li>Ha 0 forintot kell kifizetnünk, azt egyféleképpen tehetjük:
        nem adunk pénzt.
    <li>Ha 0-nál többet kell fizetnünk, de nincs semmilyen fajta
        érménk, akkor nulla lehetőség.
    <li>Ha negatív összeget kell fizetnünk, azt sem tudjuk megtenni:
        nulla lehetőség.
</ol>

<p>Az utóbbi feltételt az algoritmus egyszerűségéhez használjuk ki.
Jelentése: ha 5 forintot kell kifizetni, és megpróbáljuk egy 20-assal, akkor
még -15 forintot kellene – de ez nem megoldás.</p>

<pre class="brush: cbub "  >
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int penzvalto(int mennyit, int *fajtak, int hanyadiktol) {
    /* báziskritérium */
    if (mennyit == 0) // 1. pont
        return 1;
    if (fajtak[hanyadiktol] == -1 || mennyit &lt; 0) // 2, 3. pont
        return 0;

    /* egyszerűsítés */
    return penzvalto(mennyit-fajtak[hanyadiktol], fajtak, hanyadiktol)
           + penzvalto(mennyit, fajtak, hanyadiktol+1);
}

int main(void) {
    int fajtak[] = {5, 10, 20, 50, -1};

    printf(&quot;Összesen: %d lehetőség\n&quot;, penzvalto(100, fajtak, 0));

    return 0;
}</pre>

<p>Az érmék névértékeit egy tömbbe tettük, amely egy lezáró -1-et is tartalmaz (a
római számos példákhoz hasonlóan). A függvény ezt a tömböt kapja, és egy indexet,
hogy hányadik elemtől kell a tömböt figyelembe vegye. Az utolsó sorában ezt
növeli, és úgy hívja meg magát – így maradnak ki a tömb eleji érmék a rekurzív
hívásban, és így fogy el végül a tömb, amikor
<code>fajtak[hanyadiktol]==-1</code>. Ez megoldható lenne pointer aritmetikával
is: <code>fajtak+1</code> a tömb belsejébe mutat (a hátsó részére), és így
fogyhat el a tömb.</p>

</div>
</div>







</div>
</section>
<section id="6">
<div class="slide" id="slide_6">
<div class="slideheader">
<h2><span class="oldalszam">6</span>Zárójeles szöveg</h2>
</div>

<p>Feladat: írjunk állapotgépes programot, amelyik egy adott szövegből eltávolítja a 
(zárójelezett részeket). Előfordulhat, hogy a zárójelek tetszőleges mélységben egymásba vannak 
ágyazva (például így, mint ez a (zárójeles) szó).</p>

<div class="tovabb ">
<h4><a onclick="tovabb_megnyit_bezar(this);">Megoldás</a></h4>
<div class="megjelenik csik">

<p>Nem lehet megoldani véges számú állapotot tartalmazó állapotgéppel. Minden bezáró 
zárójel „)” esetén tudni kellene, hogy hány be nem zárt zárójel van még; ez annyiféle „(” utáni 
állapotot feltételez. A feladat szövege szerint pedig ezekből tetszőlegesen sok lehetne.</p>

</div>
</div>
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="gy08.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="index.html"><img src="modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="index.html">főoldal</a> · <a href="elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
