<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Minta nagy házi</title>
<meta property="og:title" content="InfoC :: Minta nagy házi">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="A minta nagyházi, amely egy plágiumkereső program. Pontosított specifikáció, végleges program és dokumentációja.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="A minta nagyházi, amely egy plágiumkereső program. Pontosított specifikáció, végleges program és dokumentációja.">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="modulz/logo_touch.png">
<link rel="image_src" href="modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="modulz/style/localfonts.css@v10.css">
<script src="modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="index.html">InfoC</a></div>
<ul>
<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="index.html">Kezdőlap</a>
<li><a href="nhf.html">Nagy házi feladat</a>
<li><a href="elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="ea01.html">1. hét: bevezetés</a>
<li><a href="ea02.html">2. hét: algoritmusok</a>
<li><a href="ea03.html">3. hét: tételek, tömbök</a>
<li><a href="ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="ea09.html">9. hét: láncolt listák</a>
<li><a href="ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="ea12.html">12. hét: bináris fák</a>
<li><a href="ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="gy02.html">2. hét: algoritmizálás</a>
<li><a href="gy03.html">3. hét: egyszerű programok</a>
<li><a href="gy04.html">4. hét: tételek és tömbök</a>
<li><a href="gy05.html">5. hét: függvények</a>
<li><a href="gy06.html">6. hét: származtatott típusok</a>
<li><a href="gy07.html">7. hét: mutatók használata</a>
<li><a href="gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="gy11.html">11. hét: láncolt listák I.</a>
<li><a href="gy12.html">12. hét: láncolt listák II.</a>
<li><a href="gy13.html">13. hét: bináris fák</a>
<li><a href="gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="lab01.html">1. hét: operációs rendszer</a>
<li><a href="lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="lab03.html">3. hét: egyszerű programok</a>
<li><a href="lab04.html">4. hét: tömbök</a>
<li><a href="lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="lab11.html">11. hét: láncolt listák</a>
<li><a href="lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="lab13.html">13. hét: bináris fák</a>
<li><a href="lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="f01.html">1. hét: egyszerű programok</a>
<li><a href="f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="f09.html">9. hét: láncolt listák</a>
<li><a href="f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="jegyzet.html">Jegyzet és puska</a>
<li><a href="fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="stilus.html">Kódolási stílus</a>
<li><a href="tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="debugmalloc.html">Debugmalloc</a>
<li><a href="mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="orak.html">SVG óra galéria</a>
<li><a href="angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="turing.html">Mit tud a számítógép?</a>
<li><a href="bf.html">BF</a>
<li><a href="bitturmix.html">Bitturmix</a>
<li><a href="labirintus.html">Labirintusok</a>
<li><a href="tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="karakterkodolas.html">Karakterkódolások</a>
<li><a href="strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="internet.html">Internet</a>
</ul>

<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="sdl.html">SDL grafika</a>
<li><a href="sdl_telepito.html">SDL telepítés</a>
<li><a href="fa.html">Fák rajzolása</a>
<li><a href="lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="mintanhf.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="mondatelemzo.html">Mondatelemző</a>
<li><a href="kifejezesek.html">Kifejezések</a>
<li><a href="derivalas.html">Deriválás</a>
<li><a href="ast_epit.html">AST: szintaxisfák</a>
<li><a href="ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<h1 class="eloadascim">Minta nagy házi</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán · <i class="ido"></i> 2015.02.18 · Frissítve: 2015.02.15</p>
<p class="kivonat">A minta nagyházi, amely egy plágiumkereső program. Pontosított specifikáció, végleges program és dokumentációja.</p>
</div>

<p>Ez az oldal egy nagy házi nehézségű feladat megoldását tartalmazza. Ehhez hasonlóan kell 
kinézzen a nagy házi megoldása és a hozzá tartozó dokumentáció.</p>

<p>A feladatkiírás rész tulajdonképpen egy ötletet tartalmaz. Ez egy röviden leírt elképzelés 
arról, hogy a programnak mit kell tudnia. A lenti formában beadható lenne az „NHF 1.” 
részfeladathoz. Az ezt követő pontosított specifikáció minta ahhoz, hogy az „NHF 2.” 
részfeladathoz mit kell beadni. A többi rész már a végleges megoldást mutatja be, amilyet az 
„NHF 4.” részfeladathoz be kell adni. (Az „NHF 3.” részfeladatot a laborvezetővel kell 
egyeztetni.)</p>

<p>A nagy háziban a kódra és a dokumentációra egy ilyen részletességgel és igényességgel 
kidolgozott megoldásra egyértelműen ötös jegy jár.</p>






<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="mintanhf.html#1">NHF 1. – Feladatkiírás</a>
<li><a href="mintanhf.html#2">NHF 2. – Pontosított specifikáció</a>
<li><a href="mintanhf.html#3">NHF 4. részfeladat – Programozói dokumentáció</a>
<li><a href="mintanhf.html#4">NHF 4. részfeladat – Tesztelési dokumentáció</a>
<li><a href="mintanhf.html#5">NHF 4. részfeladat – Felhasználói dokumentáció</a>
<li><a href="mintanhf.html#6">NHF 4. részfeladat – Forráskód</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>NHF 1. – Feladatkiírás</h2>
</div>

<blockquote>
<p>Valahogy így nézhet ki az a kezdeti feladatkiírás, amely a honlapról származik vagy egy 
hozott feladat. Ez az, amit a feladat kiválasztásaként elfogad a laborvezető.</p>
</blockquote>

<p>Készíts programot, amely plágium detektálására használható! Olvasson be a program 
szövegfájlokat, és keresse meg közülük azokat a párokat, amelyek leginkább hasonlítanak 
egymásra! A programot parancssori felületről lehessen vezérelni, és meg lehessen neki adni azt 
is, hogy melyik szövegnek ki a szerzője. A kimenetben a hasonlóságok szerzőnév szerint 
szerepeljenek. Találj ki valamilyen módszert, amellyel a hasonlóság vizsgálható!</p>





</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>NHF 2. – Pontosított specifikáció</h2>
</div>

<blockquote> <p>A pontosított specifikáció részletesen bemutatja azt, hogy <em>mit</em> fog 
tudni a program: milyen bemenetekkel rendelkezik, milyen kimeneteket állít elő, hogyan kell majd 
kezelni. Ebbe beletartozik a program által kezelt fájlok leírása is.</p>
<p>A pontosított specifikáció olyan írásmű, amelyet az iparban a program megrendelője és a 
programozó közösen állítanak össze. A megrendelőt azonban általában nem érdekli, hogyan működik 
a program; sőt ha nem ért a programozáshoz, akkor nem is érti a program belső felépítését. A 
specifikáció ezért semmiképp nem annak leírása, hogy <em>hogyan</em> fog működni a program – az 
már a megvalósítás része!</p>
<p>Ennek az írásnak nem kell pont ugyanígy kinéznie, ugyanilyen felépítéssel rendelkeznie, mint az
itt bemutatottnak. A plágiumkereső egy nem interaktív program (azaz indítása után már nem
vezérelhető, hanem kiszámolja, amit kell, és befejeződik), tehát logikus a specifikációban
arra helyezni a nagy hangsúlyt, hogy milyen bemenő adatokból milyen kimenő adatokat állít
elő. Egy játéknál a pontosított specifikáció inkább a szabályokat rögzítené, és azt mutatná
be, nagyjából hogyan fog kinézni a program. Miket lehet választani a menüből, hogyan fog kinézni
játék közben a pálya, mely gombokkal lehet irányítani a játékost stb.</p> </blockquote>

<h3>A program célja</h3>

<p>A feladat egy olyan program készítése, amely szövegfájlok (dolgozatok) között hasonlóakat 
keres. Az összehasonlítás módszerét a program fejlesztése ki kell majd találni. Az összehasonlítás
eredménye minden szövegpárra egy százalékos mutató, amelynek annál magasabbnak kell lennie, minél
jobban hasonlít egymásra a két szöveg. Az összehasonlított szövegeket hasonlóság szerint sorba
rendezve könnyen felfedezhető a plágium.</p>

<h3>A program használata</h3>

<p>A felhasználónak a program használatához össze kell gyűjtenie az összehasonlítandó szövegeket
(.txt fájlok formájában), továbbá írnia kell egy vezérlőfájlt. A vezérlőfájl mutatja meg
a program számára, hogy melyik fájlokban találja meg az összehasonlítandó szövegeket, és hogy
melyik szövegnek ki a szerzője. Ezeket a vezérlőfájl soronként, szóközzel elválasztva
tartalmazza:</p>

<pre>fájlnév szerző_neve</pre>

<p>A fájlnévben nem lehet szóköz, mert a szerző névtől egy szóköz választja el.
Az utóbbi azonban több tagból is állhat. Pl.:</p>
<pre>
148.txt Csizma Dia
56.txt Olajos Alajos
</pre>

<p>Az így hivatkozott szövegfájlok tetszőleges folyó szöveget tartalmazhatnak. A program
minden indításával egy vezérlőfájlt tud feldolgozni. Indításkor a vezérlőfájlt
(és esetleg egy táblázatfájl nevét) parancssori paraméterként kell megadni a programnak:</p>

<pre>
plagium &lt;vezérlőfájl&gt; [táblázatfájl]
</pre>

<p>A második paraméter nem kötelező – ha adott, akkor abba kerül az Excel által is 
olvasható táblázat, amúgy pedig csak a szabványos kimenetre az első húsz hasonlóság adata.</p>

<h3>A futás eredménye</h3>

<p>A program az összehasonlított dolgozatokat csökkenő hasonlóság szerint listázza a szabványos 
kimenetére. A hasonlóságot százalékban adja meg, ahol 100% a teljesen egyforma dolgozatokat 
jelenti, 0% pedig a teljesen különbözőeket. A kimenet két formátumban jelenik meg. A
szabványos kimeneten az első húsz legnagyobb hasonlóság adata jelenik meg, gyors 
áttekintést adva a futási eredményről. A formátum:</p>

<pre>
név (fájlnév) ↔ név (fájlnév), százalék%
Remek Elek (32.txt) ↔ Csizma Dia (148.txt), 64.58%</pre>

<p>A másik kimenet fájlba íródik, és lényegében ugyanezek az adatok szerepelnek, de az összes 
dolgozatpárra. Az egyes mezőket pontosvessző választja el:</p>

<pre>
százalék;név1;fájlnév1;név2;fájlnév2
64.58;Remek Elek;32.txt;Csizma Dia;148.txt
</pre>

<p>Egy ilyen formátumú fájlt bármelyik táblázatkezelő program meg tud nyitni.</p>





</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>NHF 4. részfeladat – Programozói dokumentáció</h2>
</div>

<blockquote>
<p>A programozói dokumentáció célja az, hogy a program belső felépítését, működését
bemutassa. A jó programozói dokumentáció egyik fő ismérve az, hogy azt elolvasva
egy másik programozó hamar képet kap a program felépítéséről, és segítségével
könnyen eligazodik az addig számára ismeretlen forráskódban. Ennek megfelelően
legalább az alábbi részeket kell tartalmazza:</p>
<ul>
    <li>A megvalósított módszerek áttekintő magyarázata. (Jelen esetben ez azt a nem triviális
        eljárást mutatja be, amellyel a program összehasonlít két szöveget.)
    <li>A program adatszerkezeteinek magyarázata. (Milyen adat hol tárolódik, és
        miért.)
    <li>A program moduljainak és függvényeinek magyarázata. (Forrásfájlok, függvények,
        globális változók. Mi az egyes modulok és függvények feladata, és hogyan
        kell azokat használni.)
</ul>
</blockquote>

<h3>A dolgozatok összehasonlítása</h3>

<p>A plagizált szövegek általában úgy keletkeznek, hogy a plágiumot elkövető szerző egy kiinduló 
szöveget több-kevesebb helyen <em>átfogalmaz.</em> A szöveg értelme meg kell maradjon, ezért a 
változtatás tagmondatok, szövegrészek cseréjéből, továbbá különböző töltelékszavak és szinonímák 
beillesztéséből áll.</p>

<p>A szövegek egyes szavait vizsgálva általában nem vonhatunk le automatikusan következtetést a 
plágiumra. Például bármelyik programozói dokumentáció jogosan tartalmazhatja a „ciklus”, „tömb”, 
„algoritmus” szavakat, ettől azok még teljesen különböző szövegek lehetnek. Azonban a két-, 
három- vagy többszavas sorozatok (kifejezések) egyezése plágiumra utalhat.</p>

<pre class="float">
A program
program módszerének
módszerének lényege
lényege az
az hogy
hogy a
a beolvasott
</pre>

<p>A megírt program módszerének lényege az, hogy a beolvasott dolgozatokat szavakra bontja, és a 
szövegek <em>szópárjait</em> próbálja megtalálni a másik szövegekben. A szópárok vizsgálata 
azért elegendő, mert egy hármas szókapcsolat két egyező szópárként is felfogható, négyes 
kapcsolatok három párként, és így tovább.</p>

<p>A program számára egy szöveg <em>szópárok halmazaként</em> jelenik meg. Egy összehasonlítás a 
<em>halmazok metszését</em> jelenti. Minél nagyobb a metszet halmaz a szöveg teljes 
terjedelméhez képest, annál erősebb a plágium gyanúja.</p>

<p>Az így definiált hasonlóság érdekessége, hogy nem szimmetrikus. Tegyük fel, hogy „A” 
dolgozat teljes egészében tartalmazza „B” dolgozatot, csak a végén szerepel még egy összefoglaló 
rész is. Ebben az esetben „B”-re azt mondhatjuk, hogy a benne lévő szöveg 100%-ban megtalálható 
„A”-ban, az „A” dolgozat szövege viszont nem 100%-ban „B”-ből származik. Ezért két hasonlóságot 
kell meghatározni minden szövegpárhoz. A program kiszámolja mindkét értéket, és a kettő 
maximumát veszi figyelembe.</p>


<h3>Adatszerkezetek választása</h3>

<p>A program működésének két fő szereplője van. Egyik szereplő a <em>dolgozat,</em> amelynek 
tulajdonságai a szerző neve, a szövegfájl neve és a kifejezések halmaza. Másik szereplő pedig a 
<em>hasonlóság,</em> amely két dolgozatot köt össze: azt tárolja, hogy a két hivatkozott 
dolgozat milyen arányban hasonlít egymásra. Ezeket az adatokat a programnak tárolnia kell, 
amihez adatszerkezetet kell választani.</p>

<p>A dolgozatok egy egyszerű, rendezetlen láncolt listában tárolhatóak, 
amelyben nincsenek strázsa elemek sem. A láncolt lista a vezérlőfájl beolvasásakor könnyen 
bővíthető. Rendezettséget ebben nem szükséges fenntartani, mert az eredményeket nem a dolgozatok 
adatai, hanem a hasonlóságok alapján kell megjeleníteni. Egy dolgozat adatait tároló struktúra:</p>

<pre class="brush: c "  >
typedef struct Dolgozat {
    char fajlnev[33];
    char nev[45];
    Halmaz *kifejezesek;

    struct Dolgozat *kov;   /* láncolt listához */
} Dolgozat;</pre>

<p>A hasonlóságok egy dinamikus tömbben tárolhatóak. A meghatározásuk már 
azután történik, hogy az összes dolgozatot beolvastuk, és addigra azok száma ismert. N dolgozat 
esetén N×(N-1)/2 hasonlóságot kell tárolni, mivel mindegyik dolgozatot össze kell hasonlítani 
minden másikkal. A tömböt végül rendezni kell majd a hasonlóság szerint, de ez is csak akkor fog 
történni, amikor már az összes párt megvizsgálta a program, vagyis csak egyetlen egyszer, a 
futás végén. A hasonlóságot tároló struktúra tartalmaz két pointert is, amely alapján visszafelé 
is követhető, melyik dolgozatokra vonatkozik:</p>

<pre class="brush: c "  >
typedef struct Hasonlosag {
    Dolgozat *d1, *d2;
    double mennyire_d1, mennyire_d2;
} Hasonlosag;</pre>

<p>Mivel minden dolgozatot össze kell hasonlítani az összes többivel, és eközben két halmaz 
metszetét kell képezni, a futás sebességét erősen befolyásolja az, hogy a halmazhoz 
milyen adatszerkezetet használunk. A halmaz reprezentációja a következő adatszerkezetekkel 
történhet:</p>

<table>
    <thead>
        <tr><th>reprezentáció<th>beszúrás<th>eleme-e?<th>metszet
    </thead>

    <tr><td>rendezetlen lista<td>O(n)<td>O(n)<td>O(n<sup>2</sup>)
    <tr><td>bináris fa<td>O(log n)<td>O(log n)<td>O(n×log n)
    <tr><td>rendezett lista<td>O(n/2)<td>O(n/2)<td>O(n)
</table>

<p>Rendezetlen lista használata esetén a metszet képzéséhez O(n<sup>2</sup>) összehasonlításra 
van szükségünk, mivel az egyik halmaz minden eleménél meg kell vizsgálnunk, szerepel-e az a 
másik halmazban. A bináris fával reprezentált halmazok esetén ez O(n×log n) lépésre redukálódik, 
mivel egy adott elemről O(log n) lépésben meg tudjuk mondani, hogy szerepel-e a fában, de ezt 
még mindig meg kell tennünk az összes vizsgálandó elem esetén. A rendezett listán mindez O(n) 
lépésből elvégezhető az összefésülés algoritmusát használva. Bár az „eleme-e?” művelet és a 
beszúrás is lassabb a bináris fáénál, mégis érdemes ezt választani. A beszúrás műveletét csak a 
dolgozatok beolvasásakor használjuk (dolgozatonként annyiszor, ahány szót tartalmaz a szöveg), a 
metszet képzését viszont dolgozat páronként el kell végezni. A konkrét „eleme-e?” 
műveletre egyáltalán nincs is szükségünk a programban. Ebből következően a szavak halmazához egy 
rendezett láncolt lista adatszerkezetet kell választani:</p>

<pre class="brush: c "  >
typedef struct Halmaz {
    char szo[2*SZOHOSSZ+1];
    struct Halmaz *kov;   /* láncolt listához */
} Halmaz;</pre>

<p>A szó hossza, azaz a sztring maximális mérete a programban fix, ahhoz nem használunk dinamikus tömböt.</p>

<h3>A program működését vezérlő fő függvények</h3>

<dl>
    <dt><code>int vezerlofajl_beolvas(char *vezerlofajl, Dolgozat **pdolgozatok)</code></dt>
        <dd>Beolvassa a vezérlőfájlt, és létrehozza a dolgozatok listáját. Első paramétere
        a vezérlőfájl neve, második paramétere pedig egy pointer cím szerint, amely
        a lista elejét fogja tartalmazni. Ez a pointer eredendően <code>NULL</code>
        értékű kell legyen. 
        Igaz értékkel tér vissza, ha rendben volt a vezérlőfájl, egyébként pedig
        hamissal. (Hamis visszatérési érték esetén a visszaadott lista hiányos, de nem
        tartalmaz érvénytelen pointereket.)
        A dolgozatok szövegét a függvény nem olvassa be.
        </dd>
    <dt><code>int dolgozatok_beolvas(Dolgozat *dolgozatok)</code></dt>
        <dd>Beolvassa a szövegeket, és felépíti a halmazokat. A paramétere a lista, amely
        a dolgozat struktúrákat tartalmazza, és benne a fájlok neveit is. A függvény a
        lista láncolását nem módosítja, hanem
        a halmazok jönnek létre minden listaelemben. Igaz értékkel tér vissza, ha
        rendben volt az összes fájl beolvasása, amúgy hamissal. (Hamis visszatérési
        érték esetén csak a dolgozatok egy része tartalmazza a beolvasott szavakat.)
        </dd>
    <dt><code>void hasonlit_osszes(Dolgozat *dolgozatok, Hasonlosag hasonlosagok[])</code></dt>
        <dd>Páronként összehasonlítja az összes szöveget, és előállítja a hasonlóság adatokat.
        Bemenő adata a dolgozatok listája, a kimenő adat pedig a feltöltött hasonlóság tömb.
        A tömböt nem a függvény foglalja le, hanem az a hívó feladata; a tömb mérete n×(n-1)/2
        kell legyen, ahol n a dolgozatok lista hossza.</dd>
    <dt><code>Hasonlosag hasonlit(Dolgozat *d1, Dolgozat *d2)</code></dt>
        <dd>Két dolgozatot hasonlít össze (d1, d2). Az ebből keletkező <code>Hasonlosag</code>
        struktúrával tér vissza, amelyben minden mezőt kitölt.</dd>
    <dt><code>int osszkep_szerint(void const *egyik, void const *masik)</code></dt>
        <dd>Összehasonlító függvény, amely a <code>qsort()</code>-tal használható. Csökkenő
        hasonlóság szerint rendezhető vele sorba egy hasonlóság adatokat tartalmazó tömb.
        A párokra meghatározott hasonlóságok közül a nagyobbikat veszi figyelembe.</dd>
</dl>





<h3>A <code>Dolgozat</code> típus lényeges függvényei és szerepük</h3>

<p>A <code>Dolgozat</code> struktúrákból láncolt lista építhető. A <code>NULL</code>
pointer megfelel egy üres dolgozat listának.</p>

<dl>
    <dt><code>Dolgozat *uj_dolgozat(char *fajlnev, char *nev)</code></dt>
        <dd>Ez a függvény létrehoz egy dinamikusan foglalt dolgozat struktúrát, üres
        halmazzal.</dd>
    <dt><code>void dolgozatok_felszabadit(Dolgozat *dolgozatok)</code></dt>
        <dd>Felszabadítja a dolgozatokból álló listát (és a hozzájuk tartozó halmazokat is).</dd>
    <dt><code>int dolgozatok_meret(Dolgozat* dolgozatok)</code></dt>
        <dd>Megszámolja a dolgozatokat tartalmazó lista hosszát, és visszatér vele.</dd>
</dl>






<h3>A <code>Halmaz</code> típus függvényei és használatuk</h3>

<p>A <code>Halmaz</code> struktúra a láncolt listákhoz hasonlóan használható:
egy pointert kell hozzá létrehozni. Az üres halmazt a <code>NULL</code>
pointer reprezentálja.</p>

<dl>
    <dt><code>void halmaz_betesz(Halmaz **phalmaz, char *szo)</code></dt>
        <dd>Betesz egy szót a halmazba (ha nincs még benne). Módosíthatja a
        mutatót, ezért cím szerint veszi át.</dd>
    <dt><code>int halmaz_metszet_meret(Halmaz *h1, Halmaz *h2)</code></dt>
        <dd>Megadja két halmaz metszetének méretét.</dd>
    <dt><code>int halmaz_meret(Halmaz *h)</code></dt>
        <dd>Megadja a halmaz méretét.</dd>
    <dt><code>void halmaz_felszabadit(Halmaz *h)</code></dt>
        <dd>Felszabadítja a halmazt.</dd>
</dl>




<h3>A halmazok előállítása, a halmaz metszése és az elemszám használata</h3>

<p>A program működésének leglényegesebb részei a kifejezések halmazának előállítása, a 
halmazok metszése, és az elemszámok viszonyítása a halmazok teljes méretéhez. 
Ezekhez a program az alábbi algoritmusokat alkalmazza.</p>

<pre class="brush: c "  >
/* DOLGOZAT BEOLVASÁSA */
char szo[SZOHOSSZ], elozoszo[SZOHOSSZ]=&quot;&quot;;

while (szot_beolvas(fp, szo)) {
    char kifejezes[2*SZOHOSSZ+1];

    /* kifejezés = előző szó + mostani szó */
    strcpy(kifejezes, elozoszo);
    strcat(kifejezes, szo);
    halmaz_betesz(&amp;iter-&gt;kifejezesek, kifejezes);

    /* következő iterációhoz */
    strcpy(elozoszo, szo);
}</pre>

<p>A fenti programrész a <code>dolgozatok_beolvas()</code> függvény része. Ez a beolvasás közben 
mindig emlékszik az előző beolvasott szóra. Azt és az aktuálisan beolvasott szót 
összefűzi a <code>kifejezes</code> nevű sztringbe, és az kerül a halmazba. Szóközt nem 
tesz a szavak közé, hiszen a halmaz nem kell értelmes kifejezéseket tartalmazzon, elég ha 
egyforma sztringek keletkeznek. Az összefűzés miatt a kifejezés hossza maximum kétszer akkora 
lehet, mint egy önálló szó hossza – ezért tartalmaz a <code>Halmaz</code> struktúra is a 
szóhossz duplája méretű sztringet.</p>

<pre class="brush: c "  >
/* KÉT HALMAZ METSZETÉNEK ELEMSZÁMA */
int halmaz_metszet_meret(Halmaz *h1, Halmaz *h2) {
    int db=0;

    /* ha bármelyik null, nincs több összehasonlítandó */
    while (h1!=NULL &amp;&amp; h2!=NULL) {
        int er = strcmp(h1-&gt;szo, h2-&gt;szo);

        if (er &lt; 0)      /* h1 kisebb - az a pointer lép */
            h1=h1-&gt;kov;
        else if (er &gt; 0) /* h2 kisebb - akkor az */
            h2=h2-&gt;kov;
        else {           /* ha az elején egyformák, akkor +1 db */
            db++;
            h1=h1-&gt;kov;
            h2=h2-&gt;kov;
        }
    }
    return db;
}</pre>

<p>Ez a függvény adja meg két halmaz metszetének elemszámát. Az algoritmus
működése kifejezetten arra épül, hogy a halmazok rendezett listában tárolódnak.
A <code>h1</code> és <code>h2</code> pointereket (amelyek lokális változói
a függvénynek), végiglépteti a listákon:</p>
<ul>
    <li>A ciklus addig fut, amíg valamelyik pointer <code>NULL</code> nem lesz.
        Ha bármelyik <code>NULL</code> lett, akkor nem lesz több egyező elem.
    <li>
        <pre class="float">h1 &rarr; 1 3 4 6 7<br>h2 &rarr; 3 4 5 6 8</pre>
        Ha a <code>h1</code> lista elején kisebb elem van, mint <code>h2</code> elején, akkor <code>h1</code>
        pointert léptetni lehet. Ilyenkor <code>h2</code> listában az az elem biztosan nem
        szerepel. Ha szerepelne, akkor az az éppen látott, nagyobb elem előtt
        kellene legyen a listában.
        Jobb oldalt látható erre egy példa. A <code>h1</code> pointer az 1-esre mutat, <code>h2</code> a 3-asra. Ha a <code>h2</code>
        listában lenne 1-es, akkor az a 3-as előtt kellene legyen – ezért biztos,
        hogy nem szerepel abban, és az 1-est ki lehet hagyni <code>h1</code> léptetése által.
        
    <li>Ugyanez a helyzet fordított esetben.
    <li>Végül pedig, ha a listák elején két egyforma elem van, akkor az része a metszetnek
        is. Ilyenkor a darabszámot növelni kell eggyel, és mindkét pointert léptetni
        a listák következő elemeire.
</ul>

<pre class="brush: c "  >
/* DOLGOZATOK HASONLÍTÁSA */
Hasonlosag hasonlit(Dolgozat *d1, Dolgozat *d2) {
    Hasonlosag h;
    int meret = halmaz_metszet_meret(d1-&gt;kifejezesek, d2-&gt;kifejezesek);

    h.d1=d1;
    h.d2=d2;
    h.mennyire_d1 = meret / (double) halmaz_meret(d1-&gt;kifejezesek);
    h.mennyire_d2 = meret / (double) halmaz_meret(d2-&gt;kifejezesek);

    return h;
}</pre>

<p>Ez a függvény számítja ki a fentiek alapján a szövegek hasonlóságát.
Mivel a halmazműveletek adottak, már csak egy egyszerű osztásról van
szó (amelyben figyelni kell, hogy ne egész osztást végezzünk).







</div>
</section>
<section id="4">
<div class="slide" id="slide_4">
<div class="slideheader">
<h2><span class="oldalszam">4</span>NHF 4. részfeladat – Tesztelési dokumentáció</h2>
</div>

<blockquote>
<p>A tesztelési dokumentáció azt írja le, hogy a program hogyan, milyen körülmények 
között, milyen bemenetekkel lett kipróbálva, és hogy helyesen működött-e. A program összes 
funkcióját tesztelni kell. A plágiumkeresőnél ez annak tesztelését jelenti, hogy sikeresen 
megtalálja-e a hasonló szövegeket, de könnyedén értelmezhető egy játéknál is: működik-e a lépés, 
kezeli-e a játék a falnak ütközést, nem fagy-e le, ha hiányzik a dicsőséglistát tároló fájl és 
így tovább.</p>
<p>Ebbe a dokumentációba nem feltétlenül kell képernyőképeket (screenshotokat) 
tenni a programról, mert nem az a célja, hogy a tesztelés tényét bizonyítsa! Sokkal fontosabb az 
eredmények helyességének ellenőrzése és szöveges magyarázata. Itt, a példában is a program
üzenetei szövegként szerepelnek, nem képként.</p>
</blockquote>

<h3>Tesztek terve</h3>
<ul>
    <li>Indítás, parancssori argumentumok tesztelése
        <ul>
            <li>Indítás argumentumok nélkül
            <li>Indítás túl sok argumentummal
            <li>Szabályos indítás
        </ul>
    
    <li>Vezérlőfájlok, bemeneti fájlok beolvasásának tesztelése
        <ul>
            <li>Nem létező vezérlőfájl
            <li>Üres vezérlőfájl
            <li>Hibás vezérlőfájl
            <li>Hiányzó szövegfájl
            <li>Üres szövegfájl
            <li>Helyes bemeneti fájlok
        </ul>
    
    <li>Program futási eredményének vizsgálata
</ul>



<h3>Indítás, parancssori argumentumok tesztelése</h3>
<ul>
<li>Paraméter nélkül és túl sok paraméterrel: a program kiírja a használat módját. Ez nincs specifikálva, de elvárható, helyes működés.
<pre class="screenshot">
$  ./plagium 
Plagiumdetektor

Hasznalat: ./plagium <vezerlofajl> [kimenetifajl]

A vezerlofajl formatuma soronkent:
  fajlnev szerzo_neve
A fajlnev nem tartalmazhat szokozoket, a szerzo neve viszont igen.
</pre>
</ul>

<h3>Vezérlőfájlok, bemeneti fájlok beolvasásának tesztelése</h3>
<ul>
<li>Hiányzó vezérlőfájl: a program jelzi a hibát. Helyes.
<pre class="screenshot">
$ ./plagium asdasdasd
Nem lehet megnyitni a vezérlőfájlt: asdasdasd
</pre>

<li>Üres vezérlőfájl: a program nem jelzi a hibát, csak furcsa, üres kimenetet produkál.
A specifikáció nem kért semmit, ezért elfogadható, de jobb lenne egy hibaüzenet.
<pre class="screenshot">
$ ./plagium ures.ctr 
0 fajl, 0 kifejezes beolvasva.
A halmazok osszesen 0 elemuek.

20 legerosebb hasonlosag:
</pre>

<li>Hibás vezérlőfájl (hiányzó szerzőnév): a program jelzi a hibát. Helyes.
<pre class="screenshot">
$ ./plagium input.ctr 
Hiba a vezérlőfájl olvasása közben: input.ctr
</pre>

<li>Hiányzó szövegfájl: a program jelzi a hibát. Helyes.
<pre class="screenshot">
$ ./plagium input.ctr 
Nem lehet beolvasni a(z) 111.txt fajlt!
</pre>

<li>Üres szövegfájl: a program NAN (not-a-number) kimenetet ad, talán nullával osztás miatt. A 
specifikáció nem írta, ilyenkor a programnak mi lenne a feladata, de jobb lenne egy könnyen 
értelmezhető hibajelzés. Elfogadható.

<pre class="screenshot">
$ ./plagium ures.ctr 
2 fajl, 416 kifejezes beolvasva.
A halmazok osszesen 386 elemuek.

20 legerosebb hasonlosag:
Aloe Vera (884.txt) ↔ Üres Juzer (ures.txt), -nan%
</pre>
</ul>

<h3>Program futási eredményének vizsgálata</h3>
<ul>
<li>A programot áramkörszimulációs laboratórium mérési jegyzőkönyveken teszteltem, valós adatokon,
a feltöltött <code>input.ctr</code> vezérlőfájllal. A program által hasonlónak jelölt szövegek 
tényleges hasonlóságát beleolvasással ellenőriztem.

<div class="columns">
<div>
<blockquote>
<p>A mérés során egy nem túl bonyolult áramkörivalósítottunk meg a Mentor Graphics ICStudio
tervező programjában, valamint szimulációval ellenőriztük a tervezett elem működőképességét és
funkcióját. A feladat egy D tároló elkészítése és szimulációja volt. <em>[Bekő&nbsp;Tóni]</em></p>
</blockquote>
</div>
<div>
<blockquote>
<p>A mérés célja egy minimális bonyolultságú, de működőképes áramköri elem megvalósítása a
Mentor Graphics ICStudio tervezőprogramjában, valamint szimulációval ellenőrizni a tervezett elem
működőképességét, funkcióját. A feladat egy transzfer gate-es D tároló megvalósítása volt. <em>[Csizma&nbsp;Dia]</em></p>
</blockquote>
</div>
</div>
<div class="kozep">Hasonlóság: 81%</div>

<div class="columns">
<div>
<blockquote>
<p>Az A oldalon 6db inverter van, ami okozza 6 db késleltetést, B oldalon pedig 1 db inverter, az
pedig 1 késleltetést okozza, a kimeneten összesen 6-1= 5 késleltetéssel fog meg jelenni a jelünk.
A oldalon az inverterek száma páros így gyakorlatilag csak késleltetés hatása van, B oldalon
pedig páratlan számú inverter van, így van késleltetés meg bemenet negálás is. <em>[Tülk&nbsp;Ödön]</em></p>
</blockquote>
</div>
<div>
<blockquote>
<p>Az A oldalon 6 db invetert taltarmaz, tehát 6 db késleltetés keletkezik. A B oldalon csak
1 invertert van, ezért 1db késleltetést okoz.A kimeneten összesen 6-1=5 késleltettés megjelenik.
Mivel az A oldalon az inverter száma páros , ezért csak késleltetés hatás van(A=IN), de
a B oldalon az inverter száma pedig páratlan , tehát a késleltetés hatáson kívül a
bemenet inverte is (B=/IN). <em>[Pará&nbsp;Zoltán]</em></p>
</blockquote>
</div>
</div>
<div class="kozep">Hasonlóság: 43%</div>

A kiszámolt hasonlóságok a többi vizsgált dokumentumpárt is jól jellemzik.

<li>A program szabványos kimenetre írt, csökkenő hasonlóság szerint rendezett párokat
tartalmazó eredménye helyes formátumú:
<pre class="screenshot">
$ ./plagium input.ctr 
48 fajl, 21049 kifejezes beolvasva.
A halmazok osszesen 18602 elemuek.

20 legerosebb hasonlosag:
Vík Endre (535.txt) ↔ Riz Ottó (488.txt), 70.12%
Aloe Vera (884.txt) ↔ Fül Elek (152.txt), 67.33%
Nemoda Buda Jenő (882.txt) ↔ Köröm Virág (848.txt), 67.32%
Aloe Vera (884.txt) ↔ Napo Zoltán (512.txt), 48.08%
...
</pre>


<li>Táblázatfájlt megadva is a specifikált formátumot állítja elő a program; az adatok
egyeznek a szabványos kimenetre írtakkal. Helyesen működik ez is.

<pre class="screenshot">
70.12;Vík Endre;535.txt;Riz Ottó;488.txt
67.33;Aloe Vera;884.txt;Fül Elek;152.txt
67.32;Nemoda Buda Jenő;882.txt;Köröm Virág;848.txt
48.08;Aloe Vera;884.txt;Napo Zoltán;512.txt
...
</pre>

<li>A legnagyobb adathalmaz, amelyen tesztelés történt, 251 mérési jegyzőkönyvet tartalmazott. Az 
összehasonlításához mindössze 1,1 másodperc kellett. A program által kiírt statisztika szerint 
összesen 124675 szópár keletkezett a szavakból, a jegyzőkönyvek halmazainak összegzett mérete 
pedig 108398.
</ul>


</div>
</section>
<section id="5">
<div class="slide" id="slide_5">
<div class="slideheader">
<h2><span class="oldalszam">5</span>NHF 4. részfeladat – Felhasználói dokumentáció</h2>
</div>

<blockquote>
<p>A felhasználói dokumentáció, ahogy a neve is mutatja, már nem programozóknak
szól, hanem azoknak, akik a programot használni fogják. Itt kell bemutatni azt,
hogy mit tud a program, és hogy hogyan kell az egyes funkcióit aktiválni és használni.</p>
</blockquote>

<p>A <code>plagium</code> program arra való, hogy szöveges fájlok közt megkeressük az egymáshoz 
hasonlókat. Az összehasonlítás azon alapszik, hogy a beolvasott szövegekben szereplő kétszavas 
kifejezéseket hasonlítja össze páronként az összes szövegben. Az összehasonlítások után az egyes 
szövegpárokat a program csökkenő hasonlóság szerinti sorba rendezi, és a szabványos kimeneten 
megjeleníti a legerősebben hasonlító párokat. Az összes hasonlóság adata egy olyan fájlba is 
kiíratható, amelyben a mezőket pontosvessző választja el, és így az táblázatkezelővel (pl. 
Excel) megnyitható.</p>

<p>A program parancsorból indítható:</p>
<pre>plagium &lt;vezérlőfájl&gt; [kimenet.csv]</pre>
<p>Az első paramétere egy vezérlőfájlt ad meg, amely az összehasonlítandó szövegfájlok neveit, 
és azok szerzőinek neveit tartalmazza. A második paraméter opcionális; ha az szerepel, akkor a 
megadott nevű fájlba írja az összehasonlítások adatait.</p>

<p>A vezérlőfájl formátuma a következő kell legyen:</p>

<pre>fájlnév szerző_neve</pre>

<p>A fájlnévben nem lehet szóköz, a névtől viszont egy szóköz választja el. A szerző neve 
azonban több tagból is állhat. Pl.:</p>

<pre>
148.txt Csizma Dia
56.txt Olajos Alajos
</pre>

<p>A képernyőn megjelenő kimenet a legnagyobb hasonlóságokat mutatja az alábbi formátumban:</p>

<pre>Remek Elek (32.txt) ↔ Csizma Dia (148.txt), 64.58%</pre>

<p>A kiírt eredményfájl formátuma egy példával:</p>
<pre>
százalék;név1;fájlnév1;név2;fájlnév2
64.58;Remek Elek;32.txt;Csizma Dia;148.txt
</pre>




</div>
</section>
<section id="6">
<div class="slide" id="slide_6">
<div class="slideheader">
<h2><span class="oldalszam">6</span>NHF 4. részfeladat – Forráskód</h2>
</div>


<p>A program teljes forráskódja és a tesztadatok letölthetőek innen:
<a href="mintanhf/mintanhf.zip">mintanhf.zip</a>.</p>
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="mintanhf.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="index.html"><img src="modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="index.html">főoldal</a> · <a href="elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
