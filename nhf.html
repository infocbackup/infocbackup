<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Nagy házi feladat – tudnivalók és feladatlista</title>
<meta property="og:title" content="InfoC :: Nagy házi feladat – tudnivalók és feladatlista">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="A nagy házi feladat követelményei és a választható feladatok listája.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="A nagy házi feladat követelményei és a választható feladatok listája.">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="modulz/logo_touch.png">
<link rel="image_src" href="modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<script>infoc.onloads.push(function(){ var melyik = true; setInterval(function() {     melyik = !melyik;     $('plagium1id').style.display =  melyik ? "block":"none";     $('plagium2id').style.display = !melyik ? "block":"none"; }, 3000); });
</script>
<link rel="stylesheet" href="modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="modulz/style/localfonts.css@v10.css">
<script src="modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="index.html">InfoC</a></div>
<ul>
<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="index.html">Kezdőlap</a>
<li><a href="nhf.html">Nagy házi feladat</a>
<li><a href="elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="ea01.html">1. hét: bevezetés</a>
<li><a href="ea02.html">2. hét: algoritmusok</a>
<li><a href="ea03.html">3. hét: tételek, tömbök</a>
<li><a href="ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="ea09.html">9. hét: láncolt listák</a>
<li><a href="ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="ea12.html">12. hét: bináris fák</a>
<li><a href="ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="gy02.html">2. hét: algoritmizálás</a>
<li><a href="gy03.html">3. hét: egyszerű programok</a>
<li><a href="gy04.html">4. hét: tételek és tömbök</a>
<li><a href="gy05.html">5. hét: függvények</a>
<li><a href="gy06.html">6. hét: származtatott típusok</a>
<li><a href="gy07.html">7. hét: mutatók használata</a>
<li><a href="gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="gy11.html">11. hét: láncolt listák I.</a>
<li><a href="gy12.html">12. hét: láncolt listák II.</a>
<li><a href="gy13.html">13. hét: bináris fák</a>
<li><a href="gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="lab01.html">1. hét: operációs rendszer</a>
<li><a href="lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="lab03.html">3. hét: egyszerű programok</a>
<li><a href="lab04.html">4. hét: tömbök</a>
<li><a href="lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="lab11.html">11. hét: láncolt listák</a>
<li><a href="lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="lab13.html">13. hét: bináris fák</a>
<li><a href="lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="f01.html">1. hét: egyszerű programok</a>
<li><a href="f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="f09.html">9. hét: láncolt listák</a>
<li><a href="f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="jegyzet.html">Jegyzet és puska</a>
<li><a href="fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="stilus.html">Kódolási stílus</a>
<li><a href="tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="debugmalloc.html">Debugmalloc</a>
<li><a href="mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="orak.html">SVG óra galéria</a>
<li><a href="angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="turing.html">Mit tud a számítógép?</a>
<li><a href="bf.html">BF</a>
<li><a href="bitturmix.html">Bitturmix</a>
<li><a href="labirintus.html">Labirintusok</a>
<li><a href="tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="karakterkodolas.html">Karakterkódolások</a>
<li><a href="strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="internet.html">Internet</a>
</ul>

<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="sdl.html">SDL grafika</a>
<li><a href="sdl_telepito.html">SDL telepítés</a>
<li><a href="fa.html">Fák rajzolása</a>
<li><a href="lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="nhf.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="mondatelemzo.html">Mondatelemző</a>
<li><a href="kifejezesek.html">Kifejezések</a>
<li><a href="derivalas.html">Deriválás</a>
<li><a href="ast_epit.html">AST: szintaxisfák</a>
<li><a href="ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<h1 class="eloadascim">Nagy házi feladat – tudnivalók és feladatlista</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán, Nagy Gergely · <i class="ido"></i> 2015.02.18 · Frissítve: 2015.02.15</p>
<p class="kivonat">A nagy házi feladat követelményei és a választható feladatok listája.</p>
</div>

<p>A tárgyban kötelező egy nagy házi feladat megoldása. A feladat szabadon 
választott. Lehet a lenti listából is választani, vagy azokhoz hasonló nehézségű, 
az elvárásoknak megfelelő saját problémák is megoldhatóak. (Egyetlen kivétel a 
plágiumkereső – azt nem szabad választani, mert az a minta házi.) A választást 
mindenképpen jóvá kell hagyja a laborvezető.</p>

<p>Pro tip: olyan feladatot válassz, amely számodra is izgalmas! Egy hozzád közel 
álló, számodra érdekes feladaton sokkal hasznosabb és mellesleg könnyebb is 
dolgozni, még akkor is, ha programozási szempontból összetettebb.</p>


<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="nhf.html#1">Követelmények</a>
<li><a href="nhf.html#2">Segédlet – grafikus, szöveges képernyő és memóriakezelés</a>
<li><a href="nhf.html#3">Matematikai jellegű programok</a>
<li><a href="nhf.html#4">Játékok</a>
<li><a href="nhf.html#5">„Számítástechnika, algoritmusok” feladatok</a>
<li><a href="nhf.html#6">Nyilvántartás jellegű programok</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>Követelmények</h2>
</div>
<p>A nagy házi feladat a következő követelményeknek kell megfeleljen:</p>
<ul>
    <li>Kb. <em>500 soros</em> C program, amely a C nyelv lehetőségeit kihasználja: strukturált felépítés, több modulra bontás, dinamikus memóriakezelés, fájlkezelés.
    <li>A feladatválasztást a laborvezető <em>jóvá kell hagyja.</em>
    <li><em>Dinamikus memóriakezelés</em> kötelező, programozási komplexitásban legalább a két dimenziós dinamikus tömb. (Olyan feladat nem választható, amelyhez még ennél is primitívebb memóriakezelést kíván csak.)
    <li>A program mellé el kell készüljön a programozói, a tesztelési és a felhasználói dokumentáció.
    <li>A kész megoldás és a dokumentáció <em>bemutatása</em> csak személyesen történhet, legkésőbb az utolsó
    oktatási hét végéig.
</ul>
<p>A fentiek között <em>logikai és</em> kapcsolat értendő: ha bármelyik hiányzik, a házi feladat nem elfogadható.</p>



<h3>A nagy házi részfeladatai</h3>
<p>A hetek során az alábbi részfeladatokat kell megoldani. Az egyes részfeladatok
megoldásához példákat mutat a <a href="mintanhf.html">minta nagyházi</a> oldal.</p>

<dl>
    <dt>NHF 1. – választás</dt>
    <dd>Ez a részfeladat a feladat kiválasztását jelenti. A lentebb látható feladatok
        közül is lehet választani, vagy saját, hasonló nehézségű feladatot is lehet hozni.</dd>
    
    <dt>NHF 2. – specifikáció</dt>
    <dd>A nagy házi választása után a portálon meghirdetett időpontig fel kell 
        tölteni a házi feladat specifikációját. Ez a kiadott feladat részletekbe 
        menő pontosítása. Ide tartozik a program feladatának leírása, a bemenetek 
        és a várt kimenetek rögzítése (formátumokkal együtt), a program 
        használatának leírása is. A specifikációban még nem kell a program belső 
        felépítésével, működésével kapcsolatos részleteket megadni. A pontosítás 
        célja az, hogy a program megrendelője, és a programot elkészítő 
        programozó ugyanarra gondoljon, és ne a munka végén derüljön fény a 
        félreértésekre. A pontosított specifikáció részletességére jellemző, hogy 
        ha két külön programozó elkészíti a programot ugyanabból a 
        specifikációból, de egymástól függetlenül dolgozva, akkor kívülről nézve 
        nagyon hasonló programoknak kell keletkezniük. Amennyiben az eredeti, 
        rövid specifikáció bármelyik része nem egyértelmű, akkor a pontosítás 
        során egy lehetőség mellett dönteni kell. Ebben segítenek a laborvezetők 
        is.</dd>
    
    <dt>NHF 3. – félkész megoldás</dt>
    <dd>A félkész megoldás lényege az, hogy a készülő program funkcionalitásának 
        egy részét már meg kell valósítsa: már látszania kell rajta akár 
        felhasználói, akár programozói szemmel, hogy mi készül. Nem elegendő egy 
        „hellóvilág” programot, vagy egy menüt feltölteni. A félkész változat még 
        nem kell hibamentes legyen, nem kell tartalmaznia az összes funkciót, sem 
        felépítésében és használt adatszerkezeteiben nem kell a végleges 
        programmal megegyezzen. A félkész házinak dokumentációt még egyáltalán 
        nem kell tartalmaznia. 
        <p class="megjegyzes">
            A laborvezető nem tud olyan részfeladatot elfogadni, amit nem vele 
            egyetértésben választottál, hiszen pl. nem lát rá arra, hogy még 
            mennyit kívánsz hozzáírni. Ez akkor fordulhat elő, ha nem konzultálsz 
            a feladatodról. Kukacos játék esetén félkész házi <em>lehet</em> egy 
            olyan program, amelyikben a kukac feje már mozog a képernyőn, és az 
            étkeket össze lehet gyűjteni, de a kukacnak még nincsen farka, és nem 
            nő. Telefonkönyves házi esetén félkész változat <em>lehet</em> az, 
            ahol az adatokat már be tudja kérni a program, és el tudja tárolni 
            egy tömbben; esetleg a fájlműveletek (írás, olvasás) is már működnek, 
            de dinamikus adatszerkezetet még nem használ, kereséseket még nem tud 
            végezni.
        </p>
    </dd>
    
    <dt>NHF 4. – végleges program</dt>
    <dd>Ez az elkészült, végleges program leadása, forráskódokkal és dokumentációkkal.</dd>
    
    <dt>NHF 5. – pótlás</dt>
    <dd>Akinek a házi feladata nem készült el időben vagy nem elfogadható, az utolsó oktatási
        hét végéig pótolhatja azt.</dd>
</dl>



<h3>A leadás módjáról</h3>
<ul>
    <li>A dokumentációkat és a forráskódot <em>elektronikusan kell le adni,</em> 
    az adminisztrációs portálon.

    <li>A nagy házit a 13. heti laborgyakorlaton személyesen is <em>be kell 
    mutatni</em> a laborvezetőnek. A laborvezető a megoldás saját elkészítését 
    ellenőrzi, mégpedig úgy, hogy a program forráskódjával kapcsolatban 
    kérdéseket tehet el, esetleg annak módosítását kéri.

    <li>A megoldás forrásfájljait (*.c, *.h) és dokumentációját (*.pdf vagy 
    *.html) kell feltölteni egy ZIP fájlban. A csomag egyéb, különösen a 
    fordítással automatikusan előállítható fájlokat (*.obj, *.exe, thumbs.db 
    stb.) nem tartalmazhat. Az ilyen feltöltéseket a portál automatikusan vissza 
    fogja utasítani, és automatikusan nem elfogadottnak minősülnek.

    <li>A dokumentáció elvárt formátuma a szabványos PDF formátum. Word dokumentum 
    nem megengedett. A javasolt PDF készítő letölthető innen: <a href=
    "http://www.cutepdf.com/products/cutepdf/writer.asp">CutePDF</a>. Telepítés után 
    megjelenik egy fiktív nyomtató; arra nyomtatva készül a PDF fájl.

    <li>A feltöltött csomag maximális mérete fél megabájt, forráskóddal és 
    dokumentációval együtt. Ebbe a feltöltött házinak bele kell férnie: fél 
    megabájt szöveg egy 4-500 oldalas könyvnek felel meg! Ha mégsem lenne így, 
    javasoljuk a dokumentációt egy fájlban leadni, továbbá abból a fölösleges 
    képeket, különösen a képernyőképeket törölni. A program tesztelése nem azt 
    jelenti, hogy az elindított programról képernyőképeket készültek.
    
    <li>A rossz formátumban feltölteni megpróbált megoldások nem különböznek a 
    fel sem töltött megoldásoktól: nem elfogadhatóak. Feltöltött fájlnak a házi
    feladatot tartalmaznia kell; internetes linkek, „emailben elküldve” megjegyzések
    nem elfogadhatóak.
</ul>


<h3>A házi feladat minőségéről</h3>

<p>Általános követelmény a programmal szemben az, hogy a <em>józan ész elvárásai</em> 
szerint működjön. A programnak olyan magától értetődő képességekkel is 
kellhet rendelkeznie, amelyek a specifikációban külön nincsenek rögzítve. 
Például ha a specifikáció annyit mond, hogy a program egy nevet megjegyez, akkor 
elvárható az is, hogy a névben lehessen szóköz karakter; vagy ha a specifikáció 
azt mondja, hogy a program bizonyos adatokat fájlba tud menteni, akkor elvárás az 
is, hogy vissza is tudja tölteni azokat.</p>

<p>Vannak olyan alapvető technikai hibák és hiányosságok, amelyek a nagy házi 
feladat értékelését rontják. Ezek közül némelyik olyan, hogy azzal együtt a beadott 
program egyáltalán nem elfogadható.</p>

<p>Súlyos hiányosságok (az ilyen program egyáltalán nem elfogadható):</p>
<ul>
    <li>Az egész program egy forrásfájlban van, nincsen több modulra szedve.
        A programot logikusan
        <a href="ea11.html#tobbmodul">több modulra</a>        kell bontani, tehát több *.c és *.h forrásfájlnak kell lennie.
    <li>Nyilvántartás jellegű feladat (pl. telefonkönyv) nem használ
        dinamikus adatszerkezetet, hanem helyette fájlokat nyit meg és zár be minden
        műveletnél. A programhoz megfelelő adatszerkezetet, pl.
        <a href="ea08.html#eadinamikustomb">dinamikus tömböt</a>,
        <a href="ea09.html#ealista">láncolt listát</a> vagy
        <a href="ea12.html#eabinarisfa">bináris fát</a> kell használni.
        Egyéb programokban is kötelező a dinamikus memóriakezelés, a feladat
        jellege által megkívánt módon.
</ul>

<p>Egyéb komoly hibák (ha több ilyen van, a program nem elfogadható):</p>
<ul>
    <li>A program nem a <a href="ea04.html#dekompozicio">funkcionális dekompozíció</a>        elve szerint épül fel: alig tartalmaz függvényeket, azok is nagyon hosszúak, vagy rengeteg
        benne a kódduplikáció (copy paste).
    <li><a href="ea11.html#tobbmodul">Forrásfájlok és fejlécfájlok</a>        helytelen használata (pl. <code>#include</code>-olt
        *.c fájl, vagy függvény-/változódefiníciót tartalmazó *.h fájl).
    <li>Feleslegesen, indokolatlanul használt globális változók vannak a programban.
        A globális változók sokszor indokoltak lehetnek, de nem arra valók, hogy a
        megfelelő függvényparaméterezést és a
        <a href="ea06.html#cimszerint">cím szerinti paraméterátadást</a>        kiváltsák.
    <li>Szinte semennyi komment a forráskódban. A függvények célját, paramétereit
        és a nem triviális algoritmusokat
        <a href="ea01.html#komment">kommentelni</a> kell.
    <li>A programkód tele van mágikus számokkal, nem használja a
        <a href="ea08.html#magikus">konstansokat</a>,
        sem a <a href="ea06.html#enum">felsorolt típust</a>.
</ul>        


<h3>A plágiumról</h3>

<p>A nagy házi egyéni feladat. A plágiumot a TVSZ bünteti. A plágiumot elkövető 
hallgatók ellen hivatalból fegyelmi eljárást kell indítani.</p>

<p>A tárgyban plágiumnak minősül más szellemi termékének minden forrásmegjelölés 
nélküli felhasználása. Ez független attól, hogy a házi feladatként beadott anyag 
milyen úton és formában jutott el az eredeti tulajdonostól a beadóhoz. Ide 
értjük többek között más házijának (módosított) beadását, a házi feladat 
megoldások ajándékozását és vásárlását, az Internetről letöltést is. Kivételt 
képeznek a tárgy honlapjáról letölthető kódrészletek (előadás, gyakorlat, labor 
feladatok megoldásai), továbbá a tárgy oktatóinak tanácsai, iránymutatásai.</p>

<p>A plagizált programokat évfolyam szinten, gépesítve keressük egy, a minta 
nagyháziban bemutatott plágiumkeresőhöz hasonló szoftverrel: <a href= 
"http://dickgrune.com/Programs/similarity_tester/">SIM</a>. Ez a szoftver 
forráskódok összehasonlítására van kihegyezve, és képes megtalálni azokat a 
programokat is, amelyek csak formázásban, változónevekben, sztringekben stb. 
különböznek egymásból. A szoftver által kiadott eredményeket minden esetben 
szemrevételezéssel ellenőrizzük.</p>

<div class="sticky">A tipikus<br>plágium</div>
<pre class="brush: c kicsinyit"  style="display: none;"  id="plagium1id">
huzas=0;
while(megtalalt&lt;parok)
{
    printf(&quot;\n\nLepesek: %d\n&quot;, huzas);
            kiir(&quot;\n\nElso kartya? \nSor: &quot;);
    scanf(&quot;%d&quot;, &amp;m);
    kiir(&quot;Oszlop: &quot;);
    scanf(&quot;%d&quot;, &amp;sz);
    while (m&lt;1 || m&gt;mag || sz&lt;1 || sz&gt;szel || keptabla[m-1][sz-1]==' ')
    {
        pkirajz();
        printf(&quot;\n\nLepesek: %d\n&quot;, huzas);
        kiir(&quot;\n\nElso kartya? \nSor: &quot;);
        scanf(&quot;%d&quot;, &amp;m);
        kiir(&quot;Oszlop: &quot;);
        scanf(&quot;%d&quot;, &amp;sz);
    }
    keptabla[m-1][sz-1]=tabla[m-1][sz-1];

    pkirajz();

    printf(&quot;\n\nLepesek: %d\n&quot;, huzas);</pre>

<pre class="brush: c kicsinyit"   id="plagium2id">
lepes=0;
while(megtalalt&lt;parok)
{
    printf(&quot;\n\nLepesek szama: %d\n&quot;, lepes);
    printf(&quot;\n\nMelyik legyen az elso kartya? \nSor: &quot;);
    scanf(&quot;%d&quot;, &amp;m);
    printf(&quot;Oszlop: &quot;);
    scanf(&quot;%d&quot;, &amp;sz);
    while (m&lt;1 || m&gt;height || sz&lt;1 || sz&gt;width || keptabla[m-1][sz-1]==' ')
    {
        tablarajzolas();
        printf(&quot;\n\nLepesek szama: %d\n&quot;, lepes);
        printf(&quot;\n\nMelyik legyen az elso kartya? \nSor: &quot;);
        scanf(&quot;%d&quot;, &amp;m);
        printf(&quot;Oszlop: &quot;);
        scanf(&quot;%d&quot;, &amp;sz);
    }
    keptabla[m-1][sz-1]=tabla[m-1][sz-1];

    tablarajzolas();

    printf(&quot;\n\nLepesek szama: %d\n&quot;, lepes);</pre>








</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>Segédlet – grafikus, szöveges képernyő és memóriakezelés</h2>
</div>

<p>A házi feladatnak nem követelménye a grafikus megjelenítés. Aki összetettebb konzolos 
felületet szeretne csinálni (pl. aknakereső, tetris), használhatja az <a 
href="nhf/econio.zip">econio</a>-t, amely a konzol képernyő kezelését segítő függvényeket 
tartalmaz (színek beállítása, adott pozícióra ugrás stb.) Ez egyszerűbb játékokhoz, teljes 
képernyőn futó programokhoz jól használható Windows alatt.</p>

<p>Gond szokott lenni Windowson a szöveges képernyőn az ékezetes karakterek megjelenítésével is. 
Ez azért van, mivel a Windows más karakterkódolást (betű&rarr;szám hozzárendelést) használ a 
grafikus és a konzolos programoknál. A probléma egy-két függvényhívással megoldható; erről 
bővebben a <a href="karakterkodolas.html">karakterkódolások</a> oldalon.</p>

<p>A grafikus programokhoz pl. a platformfüggetlen <a href="sdl.html">SDL</a> 
használható. A grafikus megjelenítés ebben a tárgyban nem tananyag, de önszorgalomból bárki 
készíthet grafikus programot is. Ezzel a házi feladat egyéb követelményeit nem lehet kiváltani.</p>

<p>A nagyházi memóriakezelési hibáinak felderítésére a
<a href="debugmalloc.html">Debugmalloc</a> modult javasoljuk.
Ezt csak hozzá kell linkelni a projekthez, és a szabványos hibakimenetre 
vagy fájlba írva jelzi a felszabadítatlan területeket, a túlindexeléseket és hasonlókat.
Ez nem mindenható, csodákra nem képes!</p>






</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>Matematikai jellegű programok</h2>
</div>

<img src="nhf/life.png" class="float">
<h3>Életjáték</h3>
<p>Készíts menüvezérelt C programot, mely a Conway féle LIFE (életjáték) modellt valósítja meg.
Részletek a <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life</a> címen. A program legyen képes:</p>
<ul>
    <li>választott méretű élettéren,
    <li>a felhasználó által,
    <li>illetve fájlból beolvasott kezdeti állapotból indulni,
    <li>a szimuláció folyamatos vagy lépésenkénti megjelenítésére.
</ul>

<h3>Egész aritmetika</h3>
<p>Készíts függvénykönyvtárat, amely nem korlátozott ábrázolási tartományú egész 
aritmetikát valósít meg – vagyis képes tetszőlegesen nagy, mondjuk 1000 (de akár 
még több) számjegyű egész számokkal is számolni. A program legyen képes a négy 
alapművelet elvégzésére – amelyekkel alkotott kifejezéseket a billentyűzetről 
vagy fájlból vár. (Ezek lehetnek <a 
href="http://hu.wikipedia.org/wiki/Ford%C3%ADtott_lengyel_jel%C3%B6l%C3%A9s">fordított lengyel jelöléssel</a> adottak is.)

<h3>Tizedes tört aritmetika</h3>

<p>Készíts függvénykönyvtárat, amellyel tetszőleges, előre meghatározott számú tizedesjegyig 
végezhetők el az alapműveletek! Pl. legyen képes 1000 tizedesjegyig, de akár még tovább 
számolni. Az első gyakorlati anyag alján mutatott algoritmussal számold ki a √<span class=
"felulhuzott">2</span> értékét 1000 tizedesjegyig! A program legyen képes a négy alapművelet 
elvégzésére – amelyekkel alkotott kifejezéseket a billentyűzetről vagy fájlból vár. (Ezek 
lehetnek <a href="http://hu.wikipedia.org/wiki/Ford%C3%ADtott_lengyel_jel%C3%B6l%C3%A9s">fordított lengyel jelöléssel</a> adottak is.)</p>

<h3>Numerikus integráló</h3>

<p>Készíts C programot, mely a felhasználó által megadott függvényt numerikusan 
integrálja. Gondosan tervezd meg az adatstruktúrát! Tervezz egy megfelelő 
bemeneti nyelvet. A program legyen képes:</p>
<ul>
   <li>alapműveletek, polinomok, 
   <li>a szokásos matematikai függvények (sin, log, exp stb.)
   <li>és tetszőleges kombinációjuk kezelésére.
</ul>
<p>A program legyen képes felhasználó által megadott kifejezéseket eltárolni és 
feldolgozni! (Ezek lehetnek <a 
href="http://hu.wikipedia.org/wiki/Ford%C3%ADtott_lengyel_jel%C3%B6l%C3%A9s">fordít
ott lengyel jelöléssel</a> adottak is.)</p>



<h3>Mátrix függvénykönyvtár</h3>

<p>Készíts függvénykönyvtárat, amellyel mátrixműveletek végezhetőek! Tárold egy 
mátrix szélességét, magasságát, valós értékeit! Legyen képes a programod 
bármilyen nagy mátrixokkal dolgozni, és a szokásos műveletek elvégzésén kívül a 
mátrixokat fájlba írni és fájlból visszaolvasni!</p>









</div>
</section>
<section id="4">
<div class="slide" id="slide_4">
<div class="slideheader">
<h2><span class="oldalszam">4</span>Játékok</h2>
</div>

<h3>Amőba</h3>
<p>Készíts menüvezérelt C programot, mely amőbát játszik. A program legyen képes:</p>
<ul>
   <li>a játék adminisztrálására egy tetszőleges méretű táblán,
   <li>több támadó és védekező stratégiát alkalmazni,
   <li>állás elmentésére és visszatöltésére.
</ul>




<img src="nhf/reversi.png" class="float">
<h3>Reversi</h3>
<p>
Írj reversi játékot, amelyben a gép ellen lehet játszani!
A program legyen képes:
</p>
<ul>
<li>Kirajzolni a pályát (szövegesen vagy grafikusan).
<li>Fájlba menteni és visszatölteni az állást.
<li>Ellenőrizni, hogy helyes-e a játékos lépése.
<li>Támadó stratégiákat alkalmazni.
</ul>
<p>(Vigyázat, ennél is kötelező dinamikus memóriakezelést használni,
bár az amőbával ellentétben ezt fix méretű pályán szokták játszani.
Konzultálj a laborvezetővel!)</p>



<img src="nhf/sokoban.jpg" class="float">
<h3>Sokoban</h3>
<p>A játékban egy figurával ládákat kell tologatni a képernyőn; úgy, hogy azok a megfelelő 
helyre kerüljenek. A pálya viszont olyan, hogy könnyű betolni olyan helyre a ládákat, ahonnan 
már elmozdítani nem lehet őket.
<p>Olvasd a pályák leírását fájlból! Vezess dicsőséglistát! (Melyik játékos, 
melyik pályát, hány lépésből tudta megoldani?) Ez könnyedén megoldható szöveges 
képernyőn is.</p>










<h3>Hexxagon</h3>

<p>Táblás játék. A pálya hatszögletű elemekből áll. Mindkét fél néhány bábuval indul. Minden 
lépésben a játékosok valamely bábuval a szomszédos helyre terjeszkedhetnek (ilyenkor nő a bábuk 
száma), vagy kettővel arrébb ugorhatnak (ilyenkor nem) egy szabadon választott bábujukkal. Az 
újonnan lerakott bábu mellett az ellenség bábui színt váltanak; a lépő játékos megnyeri azokat. 
YouTube videó itt: <a href="http://www.youtube.com/watch?v=_E10ydLaLE8">http://www.youtube.com/watch?v=_E10ydLaLE8</a>.</p>

<p>Írj programot, amelyben a gép különféle stratégiákkal játszik a felhasználó ellen!</p>





<img src="nhf/toltes.png" class="float">
<h3>Töltés-játék</h3>
<p>(Grafikus program.) A játék a következő. A program a képernyő adott pontjából, adott irányban
kilő egy pozitív töltéssel rendelkező részecskét. A játékos számára adott néhány másik töltés, 
amelyeket úgy kell elhelyeznie a képernyőn, hogy a mozgó töltés egy megadott célba jusson. Ezek 
az elhelyezendő töltések lehetnek különböző erősségűek, polaritásúak. Közben a pályán 
lehetnek fix töltések, falak stb. (Hasonló játék itt: 
<a href="http://kmk.blog.hu/2007/07/26/newton_kedvenc_jateka">http://kmk.blog.hu/2007/07/26/newton_kedvenc_jateka</a>)</p>

<p>A program számoljon pontszámot a játékos számára (pl. hány próbálkozásra
sikerült megoldania a pályákat), és ez alapján tartson nyilván dicsőséglistát is,
amelyet fájlba ment és vissza is olvas! A programnak tetszőlegesen sok töltést kell tudni kezelnie.
A pályák leírását (hol van töltés, hol van fal) olvasd fájlból!
Egy pályán lehessen tetszőlegesen sok mind a kettőből!</p>


<img src="nhf/atomix.png" class="float">
<h3>Atomix</h3>
<p>A játékban egy zegzugos pályán kell kirakni az elszórt atomokból egy molekulát. A játékos egy 
kattintással (vagy egy gomb megnyomásával) megfoghatja az atomokat, utána pedig egy irány 
megadásával (fel, le, jobbra vagy balra) elindíthatja azokat. A nehézség abban áll, hogy 
ilyenkor az atomok nem egyet ugranak arrébb, hanem addig mennek, amíg falba vagy egy másik 
atomba nem ütköznek.</p>
<p>A játékban a pálya lehessen tetszőlegesen nagy! Pályák letölthetőek innen: <a 
href="nhf/atomix.zip">atomix.zip</a>. Leírás megtalálható a ZIP-ben. Az 
<code>original.json</code> fájl viszonylag egyszerű pályákat tartalmaz.</p>



<h3>Kalandjáték</h3>
<p>Készíts szöveges kalandjáték programot, amely</p>
<ul>
    <li>felajánlja a választási lehetőségeket,
    <li>a küldetéseket egy szövegfájlból dinamikus adatszerkezetbe olvassa be,
    <li>képes a játék állásának elmentésére,
    <li>a játékban tetszőlegesen sok helyszín között lehet mozogni, és a játékosnál
        tetszőlegesen sok tárgy lehet.
</ul>





<h3>Kígyó játék</h3>
<p>Készíts kígyó játékot, ahol a kígyók ha megeszik a véletlenszerűen elhelyezett
étket, akkor nő a méretük. Ha önmaguknak, vagy egymásnak ütköznek, az
a játék végét jelenti. A program legyen képes:</p>
<ul>
    <li>egy, illetve két játékos üzemmódra
    <li>a pontok számolására és elmentésére
</ul>




<h3>Aknakereső játék</h3>
<p>Készíts aknakereső játékot. A pálya téglalap alakú, cellákból álló tábla. Egy cellára rálépve 
megtudhatjuk, hogy az adott cellán van-e akna (ebben az esetben felrobbanunk – vége a játéknak), 
illetve, hogy hány szomszédos cellán van. Legyen lehetőség:</p>
<ul>
    <li>a tábla méreteinek a meghatározására,
    <li>a táblán lévő aknák számának megadására,
    <li>a játékidő mérésére (esetleg limitálására),
    <li>a játékos által aknának gondolt cellák megjelölésére,
    <li>aknamentes környék automatikus felderítésére.
</ul>





<h3>További játékok</h3>
<p>Készíts egyszerű játékprogramot (PacMan, Tetris, stb.) A program legyen képes:</p>
<ul>
    <li>a játékot pontozással értékelni,
    <li>a pontszámokat a játékos nevekkel együtt elmenteni (tetszőleges számban),
    <li>az elmentett eredményeket a pontok szerint csökkenő sorrendben megjeleníteni,
    <li>pálya térképet fájlból beolvasni (pacmannél), tetszőleges méretű pályán játszani (tetrisnél) stb.
</ul>




<h3>Akasztófa</h3>

<blockquote class="float" style="width: 18em;">
<p>Az akasztófás és a szótáras programokhoz
használható szólisták: <a href="nhf/szotar.zip">szotar.zip</a>.</p>
</blockquote>

<p>A program a szavak listájából gondol egy feladványt, amelyet a felhasználónak ki kell 
találnia. Betűket tippel, amelyek ha a gondolt szóban szerepelnek, a gép felfedi őket. Pl. ha a 
gondolt szó <code>ökör</code>, a tippek <code>k</code> és <code>r</code>, akkor a felhasználó 
ezt látja: <code>_k_r</code>. A program legyen képes:</p>

<ul>
    <li>A felhasználó által megadott hosszúságú szóra gondolni (ha van olyan az adatbázisában).
    <li>Szólni, ha már tippelt egy adott betűt a felhasználó.
    <li>A szavak adatbázisát kezelni: a felhasználó által megadott új szót felvenni, ábécében listázni,
        hosszúság szerint válogatni, meglévő szavakat törölni.
    <li>A szavakat tároló bemeneti fájlt csak egyszer beolvasni és egyszer kiírni!
</ul>
<p>A szavak tömbben történő tárolása ennél a feladatnál nem elfogadható!</p>


<h3>Gonosz akasztófa</h3>
<p>Az alapfelállás a fentihez hasonló, de itt a gép nem kötelezi el magát egyetlen egy szó 
mellett sem. A felhasználó tippjei alapján mindig úgy szűkíti a szóba jöhető szavak halmazát, 
hogy a legkevesebb segítséget adjon a felhasználónak. Pl. a felhasználó idáig eljutott: _k_r, és 
az „akár” szóra gondol. Ezért tippel egy a-t, mire a gép azt mondja, hogy veszített, mert a szó 
az „ökör” volt. Miközben igazából eddig nem is gondolt egyetlen szóra sem.</p>





<img src="nhf/bagolystop.png" class="float">
<h3>KRESZ-teszt</h3>

<p>Készíts programot, amellyel a KRESZ vizsgára lehet gyakorolni! A programnak fájlból kell 
beolvasnia a kérdéseket, amelyekre természetesen a helyes választ is tudja. A felhasználónak ezt 
kell megmondania. Vagy passzolnia, de akkor a kérdések végére érve újra meg fogja kapni a 
kihagyott kérdést. Vegye figyelembe a program az időt is! (Csinálhatod úgy, hogy egy kérdésen 
akármennyi ideig lehet gondolkodni, de a válasz után nézi a program, hogy mennyi idő telt el a 
játék indítása óta.)</p>

<p>Készíts dicsőséglistát és szégyenpadot: dicsőséglistára azok kerülnek, akik nagyon gyorsan 
válaszoltak a kérdésekre, szégyenpadra azok, akik a legtöbb rossz választ adták.</p>

<p>(A kérdések adatbázisa e-mailben elkérhető.)</p>



<h3>Legyen Ön Is Milliomos!</h3>

<blockquote class="float" style="width: 18em;">
<p>A kérdések adatbázisa: <a href="nhf/loim.zip">loim.zip</a>. Ebben egy Excel tábla van, amiből 
tetszőleges kódolással szövegfájlt tudsz exportálni.</p>
</blockquote>

<p>Mint a tévés játék: egymás utáni kérdések, mindegyikre egy jó és három rossz válasz. Rossz 
válasz esetén rögtön kiesik a játékos; lehet kérni a gép segítségét (elvesz két rossz választ) 
és a közönség segítségét (szavaznak).</p>

<p>A program tartalmazzon dicsőséglistát a játékosokról: ki mennyi pénzt nyert, és mennyi ideig 
(perc) volt játékban. A programnak fájlból kell beolvasnia a kérdéseket, amelyekből 
tetszőlegesen sok lehet!</p>








</div>
</section>
<section id="5">
<div class="slide" id="slide_5">
<div class="slideheader">
<h2><span class="oldalszam">5</span>„Számítástechnika, algoritmusok” feladatok</h2>
</div>




<h3>Huffman kódoló</h3>

<p>Készíts parancssorból hívható C programot, amely a Huffman kódoló algoritmust felhasználva
tömörít fájlokat. Részleteket lásd a
<a href="http://en.wikipedia.org/wiki/Huffman_code">http://en.wikipedia.org/wiki/Huffman_code</a> címen.
Tervezz megfelelő fájl formátumot a tömörítés kódtáblázatának tárolására.
A program legyen képes:</p>

<ul>
    <li>fájlok tömörítése,
    <li>fájlok visszaállítása,
    <li>a tömörítés iránya parancssor kapcsolóval legyen megadható.
</ul>



<h3>Lempel-Ziv tömörítő</h3>

<p>Lempel és Ziv algoritmusa a következő ötlettel tömöríti a fájlokat. Tegyük fel, hogy adott 
egy fájl a következő tartalommal:</p>

<pre>
B<em>lah b</em><strong>lah b</strong>lah
</pre>

<p>Ebben a színnel jelölt részek egyformák, ezért a második előfordulást
egy hivatkozással lehet helyettesíteni:</p>

<pre>
B<em>lah b</em><strong>[D=5,L=5]</strong>lah
</pre>

<p>Ez azt jelenti, hogy D=5 bájtnyival ezelőtt volt egy L=5 hosszúságú
sorozat, amit az adott helyen meg kell ismételni. (Most hosszabbnak tűnik,
de binárisan tárolva ezt, rövidebb lesz.)</p>

<p>Írj programot, amely ilyen módszerrel képes tömöríteni és kicsomagolni
fájlokat! Teszteld a programodat szövegfájlokon és képeken is (pl. BMP. A .png
és .jpg fájlok már tömörítve vannak, azokat hiába próbálod tovább préselni.)
Az algoritmusról sok írást találsz a neten.</p>



<h3>Archív fájl függvénykönyvtár</h3>

<p>Készíts függvénykönyvtárat, amellyel egy archív fájlba becsomagolt fájlok nyithatók meg C 
programból! A függvénykönyvtár használata hasonlítson minél jobban az <code>stdio.h</code> 
fájlkezelésére!</p> <p>A fájlok becsomagolását egy parancssori segédprogrammal lehessen 
végezni:</p>

<pre class="screenshot">
pack archiv.dat file1.bmp file2.dat file3.doc
</pre>

<p>Ekkor keletkezzen egy <code>archiv.dat</code> nevű fájl.
Abból programból a <code>file2.dat</code> megnyitása:</p>

<pre class="brush: c "  >
ARCHIV_FILE *fp;
char tomb[1024];

fp = archiv_fopen(&quot;archiv.dat&quot;, &quot;file2.dat&quot;, &quot;rb&quot;);
archiv_fread(tomb, 1, 1024, fp);</pre>

<p>A fájlokat tömöríteni nem kell.</p>




<h3>Parancssor program</h3>

<p>Írj parancssor (shell, „héj”) programot! A program legyen képes arra, hogy</p>
<ul>
    <li>a begépelt nevű másik programokat elindítsa,</li>
    <li>a szabványos bemenet, szabványos kimenet átirányítására,</li>
    <li>csővezeték (pipe) létrehozására,</li>
    <li>változók létrehozására, értékük behelyettesítésére,</li>
    <li>parancsnév-rövidítések (aliasok) létrehozására.</li>
</ul>

<p><em>Figyelem:</em> ezt a feladatot kizárólag olyanoknak ajánljuk, akik
Unix (Linux) rendszereket valamennyire ismerik, és ilyenen szeretnék megvalósítani
a programot.</p>



<h3>Útvonaltervező</h3>

<p>Készíts útvonaltervező programot! A program legyen képes egy térkép szöveges reprezentációját 
fájlból beolvasni és az ebből felépített adatstruktúra alapján két megadott helyszín között 
útvonalat tervezni. Lehessen megadni az útvonaltervezés szempontját is (leggyorsabb, 
legrövidebb, stb)!</p>





<h3>Buszjáratok</h3>
<p>Készíts programot, amely egy közlekedési társaság buszjáratait képes nyilvántartani, és a 
menetrendek alapján útvonalakat felépíteni! Elvárások a programmal szemben:</p>
<ul>
   <li>tudja tárolni megállók neveit
   <li>tárolja járatok adatait, amiben a fenti megállónevek szerepelnek,
   <li>legyen képes útvonalakat megtalálni egy adott helytől egy másik helyig (két megállónévvel adott), átszállásokkal együtt
   <li>tárolja a járatok menetrendjeit is (melyik órában hány percenként)
   <li>ezek alapján számolja ki egy utazás minimum és maximum időtartamát is
   <li>minden adatot mentsen fájlba, hogy azokat később vissza lehessen tölteni és tovább szerkeszteni
</ul>






</div>
</section>
<section id="6">
<div class="slide" id="slide_6">
<div class="slideheader">
<h2><span class="oldalszam">6</span>Nyilvántartás jellegű programok</h2>
</div>

<p>Tömbös megoldások ezeknél nem elfogadhatóak! Ugyancsak elfogadhatatlan az olyan megoldás,
amelyik dinamikus memóriakezelést nem használ, hanem tisztán fájlműveletekkel próbál megoldani
mindent.</p>

<h3>Telefonkönyv</h3>
<p>Készíts menüvezérelt C programot, amely „rekordokban” tárolja bizonyos személyek nevét,
foglalkozását, telefonszámát, esetleg más jellemző adatait. A program legyen alkalmas:</p>
<ul>
    <li>új rekordok létrehozására,
    <li>a régiek módosítására,
    <li>a régiek törlésére,
    <li>név, telefonszám, foglalkozás szerinti keresésre (részinformáció alapján is),
    <li>az adatbázis fájlba mentésére.
</ul>

<h3>Határidő napló</h3>
<p>Készíts határidő napló programot, amely „rekordokban” tárolja az események dátumát, pontos
idejét, helyét, elnevezését, és egy hozzá kapcsolódó megjegyezést. Használj dinamikus
adatszerkezetet. A program legyen képes:</p>
<ul>
    <li>új rekodok létrehozására,
    <li>a régiek módosítására,
    <li>a régiek törlésére,
    <li>egy adott naphoz, illetve héthez tartozó események kilistázására,
    <li>esemény név szerinti keresésére,
    <li>az adatbázis fájlba mentésére.
</ul>



<h3>Oktatók hallgatói véleményezése</h3>
<p>Készíts programot, amely OHV kérdőíveket és azokra adott válaszokat tárol! A kérdőívek 
tetszőlegesen sok kérdést tartalmazhatnak, amelyekre tetszőlegesen sok válasz lehet. Ezen felül 
tartalmaznak egy szöveges mezőt, ahova a kitöltő bármit írhat.</p>
<p>Készítsen a program statisztikát a kitöltött kérdőívek alapján! Legyen képes a kérdőívek és 
az eredmények fájlba mentésére, illetve visszatöltésére!</p>



<h3>Prog1 nyilvántartás</h3>
<p>Készíts programot, amely képes hallgatók adatait nyilvántartani, és Prog1 eredményeiket
számolni! A megjegyzendő adatok a következők:</p>
<ul>
    <li>A hallgatók neve, neptun kódja, előadás- és gyakcsoportja.
    <li>Az oktatóik neve, csoportjaik.
    <li>Hiányzások, kis ZH eredmények, NZH pontok stb..
</ul>
<p>„Tanítsd meg” a programnak a tárgykövetelményeket! Legyen képes a program 
listát készíteni azokról, akiknek PZH-t kell írniuk vagy nagyházi pótlást kell 
leadniuk! Legyen képes rangsorokat készíteni (pontszámok alapján), és ehhez 
hasonló listákat kiírni a képernyőre!</p>





<h3>Könyvtár</h3>
<p>Készíts könyvtár-programot, amely képes könyvek adatait eltárolni „rekordokban”.
A program legyen képes:</p>
<ul>
    <li>új rekodok létrehozására,
    <li>a régiek módosítására,
    <li>a régiek törlésére,
    <li>könyvek szerző, cím, kiadási év, téma alapján való keresésére,
    <li>az adatbázis fájlba mentésére.
</ul>





<h3>Szótár</h3>
<p>Készíts szótár programot.  A program adjon lehetőséget:</p>
<ul>
    <li>a szótárfájl kiválasztására,
    <li>új szótárfájl létrehozására,
    <li>a szótárfájl bővítésére és a bejegyzések javítására,
    <li>minimum kettő nyelv kezelésére,
    <li>esetleg több, akár tetszőleges számú nyelv kezelésére.
</ul>





<h3>Étterem</h3>

<p>Készíts programot, amely egy étteremben az egyes asztalokhoz tartozó megrendeléseket
jegyzi meg. Legyen lehetőség:</p>

<ul>
   <li>Az asztalok megadására (az étterem nyitásakor)
   <li>Az étterem menüjének rögzítésére
   <li>Új asztal nyitására vendégek érkezése esetén
   <li>Rendelések felvételére a menü alapján
   <li>számla „nyomtatására” (képernyőre)
   <li>Asztalfoglalás rögzítésére
</ul>

<p>Az asztalfoglalásokat és a menüt mentse a program fájlba is, hiszen azokat nem
felejtheti el egy újraindítás vagy egy áramszünet miatt!</p>



<h3>Mini-Facebook</h3>

<p>Írj programot, amely emberek személyes adatait (név, nem, születési dátum stb.), továbbá 
ismeretségi viszonyait (kik ismerik egymást) képes nyilvántartani, és lehetővé teszi azt, hogy 
két ismerős üzenni tudjon egymásnak!</p>

<p>A programnak nem kell grafikusnak, se hálózatosnak lennie; elég, ha egyszerre egy ember tudja 
használni. (Utána ő kijelentkezik, és valaki más bejelentkezik.) Tegyen lehetővé ugyanakkor 
kereséseket (név szerint, iskola szerint, lakóhely szerint stb.), és ajánlja fel egy menüpontban 
a felhasználók számára az ismerősök ismerőseit! Tároljon el minden adatot fájlban (az üzeneteket 
is), és tegye lehetővé akárhány felhasználó és üzenet létezését!</p>




<h3>Morze</h3>

<p>Készíts parancssorból hívható C programot, amely Morze szövegeket kezel. Morze ábécét találsz 
az Interneten. A program tudjon:</p>

<ul>
<li>szöveget Morzésítani
<li>Morze szöveget visszakódolni
<li>adjon statisztikát a karakterekről és a Morze jelekről (ti, tá).
<li>a konverzió iránya parancssor kapcsolóval legyen megadható.
</ul>

<p>Tömbös, listás megoldás <em>nem elfogadható!</em></p>




<h3>Repülőjegyek</h3>

<p>Készíts menüvezérelt C programot, amellyel repülőjegyek foglalásait tudod nyilvántartani!
Legyen lehetőség a programban a járatok adatait megadni. Ezen felül
legyen lehetőség <em>külön menüpontban</em> elvégezni olyan műveleteket, amelyeket általában
internetes repülőjegy-vásárlásnál is lehet:</p>

<ul>
    <li>Járatokat keresni.
    <li>Adott névre repülőjegyet foglalni.
    <li>Egy megkeresett foglaláshoz ülőhelyet foglalni.
    <li>Egy megkeresett foglaláshoz menüt (normál, vega, laktózmentes stb.) választani.
</ul>

<p>Legyen képes a program:</p>
<ul>
    <li>Kezelni az ülőhelyek számát, nehogy túlfoglalás legyen
    <li>Ne engedje két utasnak ugyanazt az ülőhelyet kiadni
    <li>Összesíteni, hogy melyik járatra, melyik menüből hány adagot kell felvinni.
</ul>
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="nhf.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="index.html"><img src="modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="index.html">főoldal</a> · <a href="elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
