<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Kulturált sztringmásoló függvény</title>
<meta property="og:title" content="InfoC :: Kulturált sztringmásoló függvény">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="A C nyelv strcpy() függvénye nem biztonságos, a strncpy() pedig nehezen kezelhető. Ez az írás egy olyan biztonságos sztringmásoló függvényt mutat be, amelyet strlcpy() néven több rendszerben is megtalálunk.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="A C nyelv strcpy() függvénye nem biztonságos, a strncpy() pedig nehezen kezelhető. Ez az írás egy olyan biztonságos sztringmásoló függvényt mutat be, amelyet strlcpy() néven több rendszerben is megtalálunk.">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="modulz/logo_touch.png">
<link rel="image_src" href="modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="modulz/style/localfonts.css@v10.css">
<script src="modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="index.html">InfoC</a></div>
<ul>
<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="index.html">Kezdőlap</a>
<li><a href="nhf.html">Nagy házi feladat</a>
<li><a href="elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="ea01.html">1. hét: bevezetés</a>
<li><a href="ea02.html">2. hét: algoritmusok</a>
<li><a href="ea03.html">3. hét: tételek, tömbök</a>
<li><a href="ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="ea09.html">9. hét: láncolt listák</a>
<li><a href="ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="ea12.html">12. hét: bináris fák</a>
<li><a href="ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="gy02.html">2. hét: algoritmizálás</a>
<li><a href="gy03.html">3. hét: egyszerű programok</a>
<li><a href="gy04.html">4. hét: tételek és tömbök</a>
<li><a href="gy05.html">5. hét: függvények</a>
<li><a href="gy06.html">6. hét: származtatott típusok</a>
<li><a href="gy07.html">7. hét: mutatók használata</a>
<li><a href="gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="gy11.html">11. hét: láncolt listák I.</a>
<li><a href="gy12.html">12. hét: láncolt listák II.</a>
<li><a href="gy13.html">13. hét: bináris fák</a>
<li><a href="gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="lab01.html">1. hét: operációs rendszer</a>
<li><a href="lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="lab03.html">3. hét: egyszerű programok</a>
<li><a href="lab04.html">4. hét: tömbök</a>
<li><a href="lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="lab11.html">11. hét: láncolt listák</a>
<li><a href="lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="lab13.html">13. hét: bináris fák</a>
<li><a href="lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="f01.html">1. hét: egyszerű programok</a>
<li><a href="f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="f09.html">9. hét: láncolt listák</a>
<li><a href="f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="jegyzet.html">Jegyzet és puska</a>
<li><a href="fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="stilus.html">Kódolási stílus</a>
<li><a href="tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="debugmalloc.html">Debugmalloc</a>
<li><a href="mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="orak.html">SVG óra galéria</a>
<li><a href="angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="turing.html">Mit tud a számítógép?</a>
<li><a href="bf.html">BF</a>
<li><a href="bitturmix.html">Bitturmix</a>
<li><a href="labirintus.html">Labirintusok</a>
<li><a href="tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="karakterkodolas.html">Karakterkódolások</a>
<li><a href="strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="internet.html">Internet</a>
</ul>

<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="sdl.html">SDL grafika</a>
<li><a href="sdl_telepito.html">SDL telepítés</a>
<li><a href="fa.html">Fák rajzolása</a>
<li><a href="lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="strlcpy.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="mondatelemzo.html">Mondatelemző</a>
<li><a href="kifejezesek.html">Kifejezések</a>
<li><a href="derivalas.html">Deriválás</a>
<li><a href="ast_epit.html">AST: szintaxisfák</a>
<li><a href="ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<h1 class="eloadascim">Kulturált sztringmásoló függvény</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán · <i class="ido"></i> 2015.02.18 · Frissítve: 2015.02.15</p>
<p class="kivonat">A C nyelv strcpy() függvénye nem biztonságos, a strncpy() pedig nehezen kezelhető. Ez az írás egy olyan biztonságos sztringmásoló függvényt mutat be, amelyet strlcpy() néven több rendszerben is megtalálunk.</p>
</div>

<p>A C nyelvnek egyszerre előnye és hátránya is az, hogy a tömbök használatakor 
nem ellenőrzi futási időben a túlindexelést. Előnye azért, mert gyors: ha tudjuk, 
hogy a program helyes, akkor felesleges futási időben minden indexeléskor 
ellenőrizni a határokat. (Nehéz is lenne, tekintve a nyelv tömbmodelljét.) 
Hátránya pedig azért, mert ha hibázunk, az nem mindig derül ki egyértelműen, 
determinisztikusan. Olyankor a legváltozatosabb hibajelenségeket tapasztalhatjuk: 
memóriaelérési hibák, helytelen eredmények, program lefagyások, a rendszer 
biztonságának sérülése. Vagy egyszerűen az is előfordulhat, hogy semmi hatását nem 
észleljük a hibának.</p>

<p>Bár a gondolat csábító, hogy a program írásakor mindig biztosítani lehessen 
valahogy a helyes tömbméret megválasztását, ez sokszor nem egyszerű. A probléma 
talán a sztringeknél érzékelhető a legjobban: bármekkorára is választjuk a 
karaktertömb méretét, mindig előfordulhat, hogy a felhasználó hosszabb sort vagy 
szót ad meg, mint amire gondoltunk. Emiatt a programokban a tömbök túlindexelése 
egyébként gyakoribb szokott lenni, mint az alulindexelés. A két leghírhedtebb, 
Interneten terjedő féregprogram, a
<a href="http://en.wikipedia.org/wiki/Code_Red_%28computer_worm%29">Code Red</a>
és a
<a href="http://en.wikipedia.org/wiki/SQL_Slammer">Slammer</a>
is éppen ilyen túlindexelési problémát – tulajdonképpen figyelmetlenül megírt
programot – használt ki.
</p>

<p>Nincs persze szó arról, hogy elvi akadály miatt megoldhatatlan probléma lenne 
ez. A félév második felében szereplő dinamikus memóriakezelés és dinamikus 
adatszerkezetek témakör éppen azt mutatja be, hogyan léphetünk túl a fix méretű 
tömbökön. Ez is egy megoldás lehet, csak éppen ezt sokszor egyszerűen a lustaság 
akadályozza meg. Ha maradunk a rögzített méretű tömböknél, akkor is el tudjuk 
kerülni az ilyen jellegű hibákat. Azonban sajnos a szabványos C függvénykönyvtár 
sztringkezelő függvényei sem túl szerencsésen lettek megtervezve. Nézzük meg, 
miért; utána pedig azt, hogyan lehetne javítani a helyzeten.</p>






<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="strlcpy.html#1">A C könyvtár sztringkezelő függvényei</a>
<li><a href="strlcpy.html#2">Sztringmásoló függvény – elvárások</a>
<li><a href="strlcpy.html#3">Miért kell az ilyen paraméterezés?</a>
<li><a href="strlcpy.html#4">Sztringmásoló függvény – egy konkrét implementáció</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>A C könyvtár sztringkezelő függvényei</h2>
</div>

<p>Idézzük csak fel a C sztringek lelkivilágát! A C sztringek
nullával lezárt karaktertömbök. Adott a következő, száz elemű tömb:</p>

<pre class="brush: c "  >
char sztring[100];</pre>

<p>Ebben a tömbben egy legfeljebb 99 karakterből álló szöveget
tárolhatunk, hiszen legkésőbb a tömb utolsó elemének, <code>sztring[99]</code>-nek
a lezáró nullát kell tartalmaznia. Ezt az elvárást a C sztringkezelő
függvényei néha nem teljesítik, máskor pedig nagyon körülményesen kell
felparaméterezni őket:</p>

<ul>
    <li><code>strcpy(cél, forrás)</code>. A <code>strcpy()</code> függvény
    a cél tömb méretére való tekintet nélkül bemásolja a pointer által
    mutatótt memóriaterülettől kezdődően a forrás sztringet. Vagyis ha
    a forrás sztring egy 1000 karakteres szöveget tartalmaz, akkor
    a függvény 1001 karaktert másol a cél tömbbe, akkor is, ha az csak
    tíz elemű.

    <li><code>strncpy(cél, forrás, maxbájt)</code>. Ez kicsit jobbnak tűnik,
    mint az előző, hiszen meg lehet neki adni, hogy maximum hány bájtot
    másoljon. Csakhogy van egy kis probléma: a másolandó bájtok számába
    a <code>strncpy()</code> beleérti a lezáró nullát is, és nem kezeli
    azt különlegesen. Azaz ha a forrás
    sztring első <code>maxbájt</code> karaktere között nincsen lezáró nulla,
    akkor a cél sztring sem lesz nullával lezárva! Ez horror. Így lehetne
    megbízhatóvá tenni:
<pre class="brush: c "  >
strncpy(cel, forras, cel_tomb_merete);
cel[cel_tomb_merete-1] = '\0';</pre>
    Tudva persze, hogy ha nem fér bele a tömbbe a sztring, akkor le lesz vágva.
    A másik furcsaság, amit a <code>strncpy()</code> csinál, az az, hogy a
    tömb fennmaradó részeit (ha a forrás sztring rövidebb, mint a cél tömb)
    nullákkal tölti ki, ami pedig általában felesleges, és időbe telik.
    

    <li>A <code>strcat(cél, forrás)</code> függvénnyel két sztringet fűzhetünk
    össze, cél+=forrás módon. A cél tömb méretére ez sincs tekintettel.
    Nem is lehet, hiszen nem kapja paraméterként, nem tudja miből megállapítani
    – nekünk kell figyelnünk arra, hogy a tömb legalább strlen(cél)+strlen(forrás)+1
    bájt méretű legyen.

    <li>A <code>strncat(cél, forrás, maxbájt)</code> függvény talán egy
    fokkal jobban használható, mint a <code>'cpy</code> párja, hiszen ez legalább
    biztosan lezárja nullával a cél tömböt. A baj csak az, hogy a maxbájt
    paraméter által megadott méretet a másolt bájtok számára érti, ráadásul a lezáró
    nulla még efölé jön. Arról nem is beszélve, hogy a maximum másolható bájtok
    tényleges száma az összefűzés miatt nem csak a forrás sztring méretétől függ, hanem a cél sztring
    eredeti tartalmától is. Ezt valahogy így lehetne megbízhatóvá tenni:
<pre class="brush: c "  >
strncat(cel, forras, cel_tomb_merete-strlen(forras)-1);</pre>
    
</ul>


</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>Sztringmásoló függvény – elvárások</h2>
</div>

<p>Mit várnánk egy sztringet másoló függvénytől?</p>

<ul>
    <li>Ne írja túl a cél tömböt.
    <li>Ha a cél tömbbe nem fér bele az a sztring, amit bele szeretnénk másolni,
        akkor azt jelezze valahogyan.
    <li>Könnyű legyen használni.
    <li>Az utóbbi leginkább azt jelenti, hogy a cél tömb méretét kelljen neki
        megadni. És pontosan azt, ne &minus;1-et stb., mert azt úgyis előbb-utóbb
        el fogjuk felejteni.
    <li>Mindezek vonatkoznak az összefűzést végző függvényre is: ott is a méretet
        meghatározó paraméter a cél tömb mérete legyen, és ne függjön annak eredeti
        tartalmától.
    <li>És végül: garantáltan zárja le a cél tömböt nullával.
</ul>

<p>Ilyen tulajdonságokkal rendelkezik a könyvtári 
<code>snprintf()</code> függvény. Ennek első paramétere a cél tömb, 
a második paramétere pedig a cél tömb mérete kell legyen. (A többi 
paramétere a <code>printf()</code>-éhez hasonló.) Figyelembe veszi az 
írás közben azt, hogy csak méret-1 karaktert írhat, és akármi is 
történik, lezárja nullával a tömböt. A visszatérési értéke pedig 
annak a sztringnek a hossza, aminek az előállítására kértük – még 
akkor is, ha az a cél tömbbe nem fért bele. Ehhez hasonlóan 
viselkedő <code>'cpy</code> és <code>'cat</code> függvényeket több 
operációs rendszer C könyvtára is tartalmaz, általában
<a href="http://static.usenix.org/event/usenix99/full_papers/millert/millert.pdf"><code>strlcpy()</code>
és <code>strlcat()</code> 
néven</a>.</p>




</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>Miért kell az ilyen paraméterezés?</h2>
</div>

<p>Tegyük fel a fent linkelt cikk nyomán, hogy egy fájl elérési útját szeretnénk
összebarkácsolni egy sztringben, saját_mappa + / + fájl.txt módon:</p>

<pre class="brush: c "  >
char eleresiut[100];

strcpy(eleresiut, sajat_mappa);
strcat(eleresiut, &quot;/&quot;);
strcat(eleresiut, &quot;fajl.txt&quot;);</pre>

<p>Ez potenciálisan több túlindexelést is tartalmaz. A saját mappa neve különböző
lehet, hiszen a felhasználó határozza meg. A könyvtári <code>strncpy()</code> és <code>strncat()</code>
függvényekkel a következőképpen lehetne biztonságossá tenni a kódrészletet:</p>

<pre class="brush: c "  >
enum { MERET = 100 };
char eleresiut[MERET];

strncpy(eleresiut, sajat_mappa, MERET - 1);
eleresiut[MERET - 1] = '\0';
strncat(eleresiut, &quot;/&quot;, MERET - strlen(eleresiut) - 1);
strncat(eleresiut, &quot;fajl.txt&quot;, MERET - strlen(eleresiut) - 1);</pre>

<p>Ezen már minden látszik, csak az nem, hogy mit csinál. Tele van mindenhol &minus;1-ekkel,
amik a lezáró nullák miatt kellenek; néhol pedig figyelembe kell venni azt is, hogy az
összefűzésnél a sztring hány karaktert tartalmaz már. Ha a sztringmásoló
és -összefűző függvényünk az előbb említett tulajdonságokkal rendelkezik, akkor
a biztonságossá tétel sokkal egyszerűbb, sőt triviális:</p>

<pre class="brush: c "  >
enum { MERET = 100 };
char eleresiut[100];

strlcpy(eleresiut, sajat_mappa, MERET);
strlcat(eleresiut, &quot;/&quot;, MERET);
strlcat(eleresiut, &quot;fajl.txt&quot;, MERET);</pre>

<p>Ezek a függvények egyébként a <code>snprintf()</code>-hez 
hasonlóan azt a sztringhosszt szokták visszaadni, amekkora a 
másolt/keletkező sztring lett volna. Így bármelyik pillanatban, ha 
azt látjuk, hogy a visszatérési értékük &ge; <code>MERET</code>,
akkor tudjuk, hogy le kellett vágni a sztringet, mert nem fért bele 
a cél tömbbe.</p>





</div>
</section>
<section id="4">
<div class="slide" id="slide_4">
<div class="slideheader">
<h2><span class="oldalszam">4</span>Sztringmásoló függvény – egy konkrét implementáció</h2>
</div>

<p>Az OpenBSD <code>strlcpy()</code> függvénye így néz ki, magyarra fordított megjegyzésekkel:</p>

<pre class="brush: c "  >
/*
 * src-t dst sztringbe másolja, ahol az utóbbi tömb mérete siz.
 * Legfeljebb siz-1 karakter kerül másolásra.
 * Mindig lezárja 0-val a dst tömböt (kivétel ha siz == 0).
 * strlen(src)-vel tér vissza; ha ez &gt;= siz, akkor a cél sztring
 * le lett vágva.
 */
size_t
strlcpy(char *dst, const char *src, size_t siz) {
    char *d = dst;
    const char *s = src;
    size_t n = siz;

    /* Annyi bájtot másol, amennyi belefér */
    if (n != 0) {
        while (--n != 0) {
            if ((*d++ = *s++) == '\0')
                break;
        }
    }

    /* Nincs elég hely dst-ben: nullával lezárás és src végének megkeresése */
    if (n == 0) {
        if (siz != 0)
            *d = '\0';      /* dst 0-val lezárása */
        while (*s++)
            ;
    }

    return s - src - 1;    /* a méretbe nem számít bele a lezáró 0 */
}</pre>

<p>Így néz ki az a függvény, amely figyel a sztringek játékszabályaira,
és egyúttal könnyű is használni. (A <code>size_t</code> típus egy olyan egész
számot jelöl, amely tömb méretét adja meg. Általában egyenértékű a normál egész
típussal.)</p>



</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="strlcpy.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="index.html"><img src="modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="index.html">főoldal</a> · <a href="elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
