<!DOCTYPE html>
<html lang="hu" class="no-js">

<head>
<meta charset="utf-8">
<title>InfoC :: Tripla indirekció</title>
<meta property="og:title" content="InfoC :: Tripla indirekció">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="X*** – tripla indirekció egy olyan feladatban, amelyben szó nem esik tömbről!">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="X*** – tripla indirekció egy olyan feladatban, amelyben szó nem esik tömbről!">
<meta name="keywords" content="bme eet infoc programozás prog1 szoftlab1">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="modulz/logo_touch.png">
<link rel="image_src" href="modulz/logo.png"> 
<script>var infoc = { onloads: [], onresize: [] };</script>
<link rel="stylesheet" href="modulz/style/style-vik.css@v10.css">
<link rel="stylesheet" href="modulz/style/localfonts.css@v10.css">
<script src="modulz/siteui.js@v10" async></script>
</head>

<body class="doksibody">
<!--[if lt IE 9]>
<blockquote><p>A régi Internet Explorer böngésző, amit használsz, nem támogatott!
Az oldal használatához keress egy <a href="http://browsehappy.com/">jobb, újabb böngészőprogramot</a>!</p></blockquote>
<![endif]-->
<div id="bodycontent">

<nav role="navigation">
<div id="menubg">
<div id="menu" class="shaper dropdown">
<div class="infoc"><a href="index.html">InfoC</a></div>
<ul>
<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Infó</a>
<ul>
<li><a href="index.html">Kezdőlap</a>
<li><a href="nhf.html">Nagy házi feladat</a>
<li><a href="elerhetoseg.html">Elérhetőség</a>
</ul>

<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Tananyag</a>
<ul>
<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Előadás</a>
<ul>
<li><a href="ea01.html">1. hét: bevezetés</a>
<li><a href="ea02.html">2. hét: algoritmusok</a>
<li><a href="ea03.html">3. hét: tételek, tömbök</a>
<li><a href="ea04.html">4. hét: függvények, számábrázolás</a>
<li><a href="ea05.html">5. hét: operátorok, struktúrák</a>
<li><a href="ea06.html">6. hét: pointerek, állapotgépek</a>
<li><a href="ea07.html">7. hét: rendezések, rekurzió</a>
<li><a href="ea08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="ea09.html">9. hét: láncolt listák</a>
<li><a href="ea11.html">11. hét: fájlkezelés, modulok</a>
<li><a href="ea12.html">12. hét: bináris fák</a>
<li><a href="ea13.html">13. hét: generikus algoritmusok</a>
<li><a href="ea14.html">14. hét: nagy program tervezése</a>
</ul>

<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="gy01.html">1. hét: tanult algoritmusok</a>
<li><a href="gy02.html">2. hét: algoritmizálás</a>
<li><a href="gy03.html">3. hét: egyszerű programok</a>
<li><a href="gy04.html">4. hét: tételek és tömbök</a>
<li><a href="gy05.html">5. hét: függvények</a>
<li><a href="gy06.html">6. hét: származtatott típusok</a>
<li><a href="gy07.html">7. hét: mutatók használata</a>
<li><a href="gy08.html">8. hét: rekurzió, állapotgép</a>
<li><a href="gy09.html">9. hét: dinamikus tömbök</a>
<li><a href="gy11.html">11. hét: láncolt listák I.</a>
<li><a href="gy12.html">12. hét: láncolt listák II.</a>
<li><a href="gy13.html">13. hét: bináris fák</a>
<li><a href="gy14.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Labor</a>
<ul>
<li><a href="lab01.html">1. hét: operációs rendszer</a>
<li><a href="lab02.html">2. hét: fejlesztőkörnyezet használata</a>
<li><a href="lab03.html">3. hét: egyszerű programok</a>
<li><a href="lab04.html">4. hét: tömbök</a>
<li><a href="lab06.html">6. hét: struktúrák és függvények</a>
<li><a href="lab06sz.html">6. hét, szombat: gyakorlófeladatok</a>
<li><a href="lab08.html">8. hét: mutatók, sztringek</a>
<li><a href="lab09.html">9. hét: dinamikus tömbök</a>
<li><a href="lab10.html">10. hét: rekurzió és állapotgépek</a>
<li><a href="lab11.html">11. hét: láncolt listák</a>
<li><a href="lab12.html">12. hét: duplán láncolt listák</a>
<li><a href="lab13.html">13. hét: bináris fák</a>
<li><a href="lab14.html">14. hét: labirintus játék</a>
</ul>

<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Példatár</a>
<ul>
<li><a href="f01.html">1. hét: egyszerű programok</a>
<li><a href="f02.html">2. hét: vezérlési szerkezetek</a>
<li><a href="f03.html">3. hét: logika, sorozatok, tömbök</a>
<li><a href="f04.html">4. hét: számábrázolás, bitek, függvények</a>
<li><a href="f05.html">5. hét: operátorok, struktúrák</a>
<li><a href="f06.html">6. hét: pointerek, sztringek, állapotgépek</a>
<li><a href="f07.html">7. hét: rendezések, rekurzió</a>
<li><a href="f08.html">8. hét: dinamikus memóriakezelés</a>
<li><a href="f09.html">9. hét: láncolt listák</a>
<li><a href="f11.html">11. hét: parancssor, fájlkezelés, modulok</a>
<li><a href="f12.html">12. hét: bináris fák, többszörös indirekció</a>
<li><a href="f13.html">13. hét: generikus algoritmusok</a>
</ul>

</ul>

<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Segédlet</a>
<ul>
<li><a href="jegyzet.html">Jegyzet és puska</a>
<li><a href="fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a href="stilus.html">Kódolási stílus</a>
<li><a href="tanacsok.html">Tanácsok a tanuláshoz</a>
<li><a href="debugmalloc.html">Debugmalloc</a>
<li><a href="mintanhf.html">NHF minta</a>
</ul>

<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Extrák</a>
<ul>
<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Szorgalmik, versenyek</a>
<ul>
<li><a href="nhfszepsegverseny2014.html">NHF szépségverseny 2014</a>
<li><a href="nhfszepsegverseny2013.html">NHF szépségverseny 2013</a>
<li><a href="nhfszepsegverseny2012.html">NHF szépségverseny 2012</a>
<li><a href="orak.html">SVG óra galéria</a>
<li><a href="angrybirds.html">SVG Angry Birds</a>
</ul>

<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Elmélet</a>
<ul>
<li><a href="turing.html">Mit tud a számítógép?</a>
<li><a href="bf.html">BF</a>
<li><a href="bitturmix.html">Bitturmix</a>
<li><a href="labirintus.html">Labirintusok</a>
<li><a href="tripla.html">Tripla indirekció</a>
</ul>

<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Gyakorlat</a>
<ul>
<li><a href="karakterkodolas.html">Karakterkódolások</a>
<li><a href="strlcpy.html">Kulturált sztringmásoló</a>
<li><a href="internet.html">Internet</a>
</ul>

<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Grafika</a>
<ul>
<li><a href="sdl.html">SDL grafika</a>
<li><a href="sdl_telepito.html">SDL telepítés</a>
<li><a href="fa.html">Fák rajzolása</a>
<li><a href="lathatatlan.html">Láthatatlan zongorista</a>
</ul>

<li class="al "><a href="tripla.html#" onclick="menu_click(this)">Nyelvészet</a>
<ul>
<li><a href="mondatelemzo.html">Mondatelemző</a>
<li><a href="kifejezesek.html">Kifejezések</a>
<li><a href="derivalas.html">Deriválás</a>
<li><a href="ast_epit.html">AST: szintaxisfák</a>
<li><a href="ast_epit_copa.html">AST: értékadás I.</a>
<li><a href="ast_epit_parameteres.html">AST: értékadás II.</a>
</ul>

<li><a href="advent.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</nav>

<main role="main">
<div id="doksi" class="shaper">
<section id="0">
<div class="slide" id="slide_0">
<h1 class="eloadascim">Tripla indirekció</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán · <i class="ido"></i> 2015.02.18 · Frissítve: 2015.02.15</p>
<p class="kivonat">X*** – tripla indirekció egy olyan feladatban, amelyben szó nem esik tömbről!</p>
</div>

<p>Feladat a következő: adott egy bináris keresőfa, amely egész számokat tartalmaz. Minden bal 
oldali részfában a gyökérnél kisebb elemek, jobb oldali részfákban pedig a gyökérnél nagyobb 
elemek vannak. A feladat az, hogy építsünk egy egész számokból álló listát, amely ugyanazokat a 
számokat tartalmazza, mint a fa – természetesen növekvő sorrendben.</p>

<div class="columns">
    <div>
        <img class="kozep" src="tripla/fa.svg" style="width: 16em;">
    </div>
    <div>
        <img class="kozep" src="tripla/lista.svg" style="width: 16em;">
    </div>
</div>
<div class="columns">
    <div>
<pre class="brush: c "  >
typedef struct Fa {
    int adat;
    struct Fa *bal, *jobb;
} Fa;</pre>
    </div>
    <div>
<pre class="brush: c "  >
typedef struct Lista {
    int adat;
    struct Lista *kov;
} Lista;</pre>
    </div>
</div>





<nav><div id="tartalom">
<h3>Tartalom</h3>
<ol>
<li><a href="tripla.html#1">A triviális megoldás</a>
<li><a href="tripla.html#2">Megoldás O(n) lépésben</a>
<li><a href="tripla.html#3">A rávezető gyakorlat</a>
<li><a href="tripla.html#4">A tripla indirekció</a>
<li><a href="tripla.html#5">Utolsó simítások</a>
<li><a href="tripla.html#6">A tanulság</a>
</ol>
</div>
</nav>
</div>
</section>
<section id="1">
<div class="slide" id="slide_1">
<div class="slideheader">
<h2><span class="oldalszam">1</span>A triviális megoldás</h2>
</div>

<p>A feladat megoldása tulajdonképpen két részből áll. Először is, be kell járnunk a fát úgy, 
hogy növekvő sorrendben megkapjuk az elemeket. Eközben minden számot a keletkező lista végére 
kell fűznünk:</p>

<pre class="brush: c "  >
void fat_bejar(Fa *gyoker, Lista **peleje) {
    if (gyoker==NULL)
        return;
    fat_bejar(gyoker-&gt;bal, peleje);
    listaba(peleje, gyoker-&gt;adat);
    fat_bejar(gyoker-&gt;jobb, peleje);
}</pre>

<p>Ez egyszerű, a szokásos bal&rarr;gyökér&rarr;jobb bejárás, az előadás kiírás (printf) példája 
lecserélve egy lista végére fűzésre. A lista építése is a szokásos, lista eleje mutató, 
megváltozik, kettős indirekció, utolsó elem megkeresése stb.:</p>

<pre class="brush: c "  >
void listaba(Lista **peleje, int adat) {
    Lista *uj = (Lista*) malloc(sizeof(Lista));
    uj-&gt;adat = adat;
    uj-&gt;kov = NULL;
    if (*peleje == NULL)
        *peleje = uj;
    else {
        Lista *iter;
        for (iter = *peleje; iter-&gt;kov != NULL; iter = iter-&gt;kov)
            ;
        iter-&gt;kov = uj;
    }
}</pre>

<p>A feladatot már meg is oldottuk. A függvény használatához a hívónak rendelkeznie kell egy 
fával, és egy üres listával. A listának azért kell üresnek lennie (vagyis a pointernek, amit 
átad a hívó a fát bejáró függvénynek, <code>NULL</code> pointernek), mivel a fenti <code>
listaba()</code> függvény mindig egy már meglévő listához fűz hozzá. A fa bal szélső elemét 
pedig egy üres listához kell hozzáfűzni. Hogy még ilyen elvárásunk se legyen a hívóval szemben, 
azaz ezzel se neki kelljen törődnie, írhatunk egy csomagoló (wrapper) függvény erre:</p>

<pre class="brush: cbub "  >
Lista *fabol_lista(Fa *gyoker) {
    Lista *ujlista = NULL;       // üres listával indulunk
    fat_bejar(gyoker, &amp;ujlista);
    return ujlista;
}</pre>

<p>Példa ennek használatára:</p>

<pre class="brush: c "  >
Fa *fa = valahonnan_van_egy_fa();

Lista *szamok;
szamok = fabol_lista(fa);</pre>

</div>
</section>
<section id="2">
<div class="slide" id="slide_2">
<div class="slideheader">
<h2><span class="oldalszam">2</span>Megoldás O(n) lépésben</h2>
</div>

<p>Észrevehetjük, hogy a létrehozott algoritmusunk O(n<sup>2</sup>) időben fut, mivel a fa 
minden elemére (n darab) újra megkeressük a lista végét (újabb n-es szorzó). Ha kicsit 
gondolkodunk, akkor rájöhetünk, két lehetőség is kínálkozik arra, hogy sokkal gyorsabb, O(n) 
időben futó algoritmust adjunk:</p>

<ol>
    <li>Megjegyezhetjük, hogy hol van a lista vége, és akkor nem kell minden lépésben
        újra megkeresni.
    <li>Vagy trükközünk: nem a lista végére, hanem a lista elejére szúrjuk be az elemeket,
        hiszen az sokkal egyszerűbb, O(1) lépésben megtehető. Ettől ugyan a sorrendjük
        megfordul, de nem gond, járjuk be a fát is fordítva, jobb&rarr;gyökér&rarr;bal
        sorrendben.
</ol>

<p>A fordított bejárás az igazán trükkös, hiszen nem csak gyorsabb, hanem még rövidebb is, mint 
az előbb adott. A másik, listavéget nyilvántartó módszernek viszont elvi és nyelvi érdekességei 
is vannak. Nézzük meg azt!</p>



</div>
</section>
<section id="3">
<div class="slide" id="slide_3">
<div class="slideheader">
<h2><span class="oldalszam">3</span>A rávezető gyakorlat</h2>
</div>

<p>De előtte nézzünk meg egy egyszerűbb feladatot. Tegyük fel, nem listát, hanem tömböt kell 
építeni egy fából, pontosan ugyanilyen módszerrel. Hogyan tesszük azt? Először is, megszámoljuk, 
hány eleme van a fának, és foglalunk egy akkora tömböt. Aztán pedig, a fát bejáró függvénynek 
tudnia kell a tömb helyét (ez egy pointer a tömb elejére), és egyben kapnia kell egy tömbindexet 
is, hogy a tömbben hova kell tenni a következő elemet. Azonban ezt a tömbindexet módosítania is 
kell tudni, hogy később a további elemek is jó helyre kerüljenek. Ezért azt cím szerint adjuk át 
neki.</p>

<p>Miért? A lényeg az, hogy ez az <code>int n</code> nem lehet a bejáró függvénynek lokális 
változója, mert akkor annyi példány lenne belőle, amilyen mély a rekurzió – viszont csak egy 
kell legyen belőle. Tehát a függvényen kívül kell léteznie. Ezt úgy oldhatjuk meg, ha valahol 
máshol létrehozzuk azt a változót, és csak egy pointert kap rá a függvény. Ugyan a rá mutató 
pointerből (<code>pn</code>) sok másolat képződik a rekurzív hívások során, de azok mind 
ugyanarra az egyetlen egy <code>int</code>-re mutatnak: mindig ugyanaz az <code>int</code> 
indexel és az növelődik:</p>

<pre class="brush: c "  >
void fat_bejar_tombbemasol(Fa *gyoker, int *tomb, int *pn) {
    if (gyoker==NULL)
        return;
    
    fat_bejar_tombbemasol(gyoker-&gt;bal, tomb, pn);

    tomb[*pn] = gyoker-&gt;adat;
    ++*pn;
    
    fat_bejar_tombbemasol(gyoker-&gt;jobb, tomb, pn);
}</pre>

<p>Bár ennek az <code>n</code> számank a bejáró függvényen kívül kell lennie, ez nem jelenti 
azt, hogy globális kell legyen. Elég, ha van egy másik függvény, amely létrehozza azt a bejárás 
idejére. Tehát kell legyen egy másik függvény is, amely létrehozza ezt az egész számot és 
nullára inicializálja (első tömbindex), és ad egy pointert a bejáró függvénynek erre a számra. 
Azért is kell neki pointert adni, mivel a bejáró függvénynek ezt módosítania kell tudni.</p>

<pre class="brush: c "  >
int *fabol_tomb(Fa *gyoker) {
    int *tomb = (int*) malloc(sizeof(int) * elemszam(gyoker));
    int n;

    n = 0;
    fat_bejar_tombbemasol(gyoker, tomb, &amp;n);

    return tomb; /* meg a méretét is vissza kellene adni */
}</pre>

<p>Mire a bejáró végez, éppen annyi elem kerül bele a tömbbe, ahány csomópontja a fának van. 
Vagyis annyiszor növelődik meg <code>*pn</code>.




</div>
</section>
<section id="4">
<div class="slide" id="slide_4">
<div class="slideheader">
<h2><span class="oldalszam">4</span>A tripla indirekció</h2>
</div>

<p>Ott tartottunk a listás verzió kapcsán, hogy jegyezzük meg, hol van a lista vége. Jó ötletnek 
tűnik az utolsó listaelemet nyilvántartani, de ez a gondolat mégsem vezet messzire, ugyanis üres 
listánál az még nem is létezik. Ehelyett azt kell tudnunk mindig, hova kell tennünk az újonnan 
létrejött elem pointerét: ez lehet a lista eleje pointer, de lehet valamelyik listaelemnek a 
<code>kov</code> pointere is.</p>


<p>Egy új elem hozzáfűzése a következőképpen néz ki. Adott egy beszúrandó adat,
és egy <code>*phova</code> pointer, ahova a beszúrt elem címe kell kerüljön.</p>

<ol>
    <li>Lefoglaljuk a memóriát a csillaggal jelölt új elem számára, amire az <code>uj</code> pointer
        mutat.
    <li>Belemásoljuk az adatot.
    <li><code>NULL</code> pointert teszünk a <code>kov</code> pointerébe (hiszen lista végi
        elem lesz).
    <li>Beállítjuk a pointert, amelynek erre az elemre kell mutatnia: <code>*phova</code>.
        (Ha ez a legelső elem, akkor ez különálló a lista eleje pointer; ha egy későbbi,
        akkor pedig egy listaelem által tartalmazott.)
    <li>A <code>phova</code> pointert végül átállítjuk az új elem <code>kov</code> pointerére,
        mert a következő elem <code>uj</code> pointerét (ha lesz még olyan) ide kell majd másolni.
</ol>

<img src="tripla/lista_uj.svg" class="kozep" style="width: 24em;">

<p>C nyelven a kódkezdeményünk:</p>

<pre class="brush: c "  >
void fat_bejar_hozzafuz(Fa *gyoker, Lista **phova???) {
    Lista *uj;
    
    if (gyoker==NULL)
        return;
    
    fat_bejar_hozzafuz(gyoker-&gt;bal, phova???);

    uj = (Lista*) malloc(sizeof(Lista)); /* 1 */
    uj-&gt;adat = gyoker-&gt;adat;             /* 2 */
    uj-&gt;kov = NULL;                      /* 3 */
    *phova = uj;                         /* 4 */
    phova??? = &amp;uj-&gt;kov;                 /* 5 */

    fat_bejar_hozzafuz(gyoker-&gt;jobb, phova???);
}</pre>

<p>A ??? jelű részeknél látszik, hogy ez egyelőre még sántít. Miért? Elvileg a <code>phova</code>
munkaváltozóból, amely pointerként azt mutatja, hogy hova kell majd tenni a következőleg 
létrehozott listaelem pointerét, az egész listaépítés során egy darabnak kell lennie. Akármilyen 
mélyre is megyünk a rekurzióban, ebből nem jöhet létre több, és mindegyik rekurzív 
függvénypéldának ugyanarról a <code>phova</code> pointerről kell beszélnie. Emiatt ez lokális 
változója nem lehet a <code>fat_bejar_hozzafuz</code> függvénynek, és így érték szerint átvett 
paramétere sem, mert akkor hívásonként több lenne belőle.</p>

<img src="tripla/lista_uj2.svg" class="float" style="width: 24em;">

<p>Vagyis ezt a változót a függvényen kívül kell létrehoznunk. Ugyanakkor e függvény képes kell 
legyen arra is, hogy megváltoztassa ennek a pointernek az értékét, hiszen mindig más helyre 
(mindig egy új listaelemben lévő <code>kov</code> pointerre) kell mutasson. Mi következik ebből? 
(Ha kizárjuk a globális változót, amit természetesen elvből megteszünk, hiszen nem arról van 
szó, hogy sok függvény és sok modul kell lássa ezt a pointert, hanem csak ez az egyetlen egy!) 
Az, hogy kell legyen egy hívó függvény, amely létrehozza a <code>phova</code> változót, és a fát 
bejáró függvény ezt cím szerint kapja! Na és mi a típusa annak a pointernek, amely egy 
<code>Lista**</code> típusú változóra mutat? Természetesen <code>Lista***</code>!</p>

<p>A fát bejáró függvény, és a bejárást elindító, <code>phova</code> változót létrehozó függvény:</p>

<pre class="brush: cbub "  >
void fat_bejar_hozzafuz(Fa *gyoker, Lista ***pphova) { // OMG 3× indirekció
    Lista *uj;
 
    if (gyoker==NULL)
        return;
 
    fat_bejar_hozzafuz(gyoker-&gt;bal, pphova);
 
    uj = (Lista*) malloc(sizeof(Lista));
    uj-&gt;adat = gyoker-&gt;adat;
    uj-&gt;kov = NULL;
    **pphova = uj;
    *pphova = &amp;uj-&gt;kov;
 
    fat_bejar_hozzafuz(gyoker-&gt;jobb, pphova);
}

Lista *fabol_lista(Fa *gyoker) {
    Lista *eleje = NULL;       /* a keletkező lista */
    Lista **phova = &amp;eleje;    /* a lépegető pointer */
    
    fat_bejar_hozzafuz(gyoker, &amp;phova);
    
    return eleje;
}</pre>

<p>A <code>phova</code> változó természetesen lehet lokális, de a bejárást indító függvény 
lokálisa kell legyen. A bejárás előtt létrejön, és a bejárás alatt van rá csak szükség, tehát a 
bejárás után megszűnhet.</p>






</div>
</section>
<section id="5">
<div class="slide" id="slide_5">
<div class="slideheader">
<h2><span class="oldalszam">5</span>Utolsó simítások</h2>
</div>

<p>Egy dolgot érdemes még megfigyelni. A fát bejáró függvény, amikor az újonnan létrejött 
listaelemet beilleszti a listába, nem figyeli, hogy mi van az adott pointerben. Csak simán 
felülírja azt: <code>**pphova=uj</code>. Emiatt az indító függvényben felesleges <code>NULL
</code> pointerrel inicializálni a lista eleje pointert. Mindegy, mi van ott, mert úgyis felül 
lesz írva.</p>

<p>Sőt ez az összes többi pointerre is igaz! Bár a fenti kódban minden létrejövő listaelem 
<code>kov</code> pointerét <code>NULL</code>-ra állítjuk, ezt az utolsó elem kivételével 
mindegyiknél feleslegesen tesszük, mert azok is felül lesznek írva a következő elem létrehozása 
után. Így azokat sem kell <code>NULL</code>-ra állítani, hanem ott lehet hagyni őket 
inicializálatlanul, mert a következő listaelemnél felülíródnak majd. Csak a legutolsóba kell 
<code>NULL</code>-t tenni. Ezt a bejárás után könnyedén meg tudjuk tenni a 
<code>fabol_lista()</code> csomagoló függvényben is, kérdés csak, hogy hol is van az a pointer, amit most 
<code>NULL</code>-ra kéne állítani?! Elvileg a lista végén, de ezt nem kell megkeresni. 
Észrevehetjük, hogy ez pont az a pointer, ahova a következő listaelem pointere is került volna… 
Azt pedig tudjuk, hol van, hiszen a <code>fat_bejar_hozzafuz()</code> függvény mindvégig kezelte 
a <code>phova</code> változót, és az most pont oda mutat, ahova kell! Tehát egy
<code>*phova = NULL</code> megoldja a dolgot.</p>

<p>A függvények teljes pompájukban:</p>

<pre class="brush: cbub "  >
void fat_bejar_hozzafuz(Fa *gyoker, Lista ***pphova) {
    Lista *uj;
 
    if (gyoker==NULL)
        return;
 
    fat_bejar_hozzafuz(gyoker-&gt;bal, pphova);
 
    uj = (Lista*) malloc(sizeof(Lista));
    uj-&gt;adat = gyoker-&gt;adat;
    **pphova = uj;
    *pphova = &amp;uj-&gt;kov;
 
    fat_bejar_hozzafuz(gyoker-&gt;jobb, pphova);
}

Lista *fabol_lista(Fa *gyoker) {
    Lista *eleje;
    Lista **phova = &amp;eleje;
    
    fat_bejar_hozzafuz(gyoker, &amp;phova);
    *phova = NULL;
    
    return eleje;
}</pre>

<p>Vegyük észre: ha a fa üres, a bejáró függvény nem csinál semmit. Ilyenkor a <code>phova</code>
pointer az <code>eleje</code> változóra mutat, amit rajta keresztül <code>NULL</code>-ra 
állítunk… És visszatérünk egy üres listával.</p>

<p>A program letölthető innen: <a href="tripla/fabol_lista.c">fabol_lista.c</a>.</p>





</div>
</section>
<section id="6">
<div class="slide" id="slide_6">
<div class="slideheader">
<h2><span class="oldalszam">6</span>A tanulság</h2>
</div>

<p>A tanulság ebből az is, hogy a kettős indirekció segítségével is könnyedén építhetünk
O(n) időben nem megfordított listát. Az alábbi program számokat olvas be -1-ig, és
a beolvasás sorrendjében teszi őket egy listába:</p>

<pre class="brush: c "  >
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Lista {
    int szam;
    struct Lista *kov;
} Lista;

int main(void) {
    Lista *eleje;

    /* beolvasás */
    {
        int i;
        Lista **pmozgo = &amp;eleje;
        while (scanf(&quot;%d&quot;, &amp;i) == 1 &amp;&amp; i != -1) {
            Lista *uj = (Lista *) malloc(sizeof(Lista));
            uj-&gt;szam = i;
            *pmozgo = uj;
            pmozgo = &amp;uj-&gt;kov;
        }
        *pmozgo = NULL;
    }

    /* csak teszt: kiírás és felszabadítás */
    {
        Lista *iter;
        for (iter = eleje; iter != NULL; iter = iter-&gt;kov)
            printf(&quot;%d &quot;, iter-&gt;szam);
        while (eleje != NULL) {
            Lista *temp = eleje-&gt;kov;
            free(eleje);
            eleje = temp;
        }
    }
    
    return 0;
}</pre>

<p>A <code>*pmozgo = uj</code> kifejezés mindig azt a pointert írja felül,
ahova a következő listaelem kerül; vagy a lista elejét mutató pointert,
vagy a legutóbbi listaelem következő pointerét. Az új elemek <code>kov</code>
pointerét a cikluson belül nem is kell <code>NULL</code>-ra állítani, mert
úgyis lesz következő elem; vagy ha nem volt, akkor a ciklus utáni
<code>*pmozgo = NULL</code> fogja ezt megtenni. Az <code>eleje</code> pointer
sem kap értéket a program legelején, hiszen úgyis felül lesz írva, vagy az
első listaelemmel, vagy ha egyáltalán nincs, a <code>NULL</code> pointerrel.</p>

<p class="megjegyzes">Az O(n) idejű „előrefelé” listaépítésre jó megoldás
a visszafelé építés és utólagos megfordítás (az is O(n) idejű). Jó az is,
ha külön esetként kezeljük az üres listát, illetve azt, ha már volt beszúrt
elem (és az utóbbi pointerét tartjuk nyilván). Az utóbbiak is szép megoldások,
sőt könnyebben megérthetőek, mint a fenti. Csak az a buta megoldás,
ha minden beszúrásnál megkeressük a legutolsó elemet, hiszen az nem O(n),
hanem O(n²) ideig tart – nagyobb listáknál vészesen belassul.</p>
</div>
</section>
</div>
</main>

<nav role="navigation">
<a href="tripla.html#menu" id="scrolltotop"></a>
</nav>

<footer role="contentinfo">
<div id="footer" class="shaper">
<a href="index.html"><img src="modulz/logo.png" id="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon"><a href="index.html">főoldal</a> · <a href="elerhetoseg.html">elérhetőség</a> · <a href="https://www.facebook.com/infoceetbmehu">facebook</a></div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2014.</div>
</footer>

</div>
</body>

</html>
